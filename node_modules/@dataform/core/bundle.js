'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var semver = require('semver');
var $protobuf = require('protobufjs/minimal');
var moo = require('moo');
var protobufjs = require('protobufjs');
var TarjanGraphConstructor = _interopDefault(require('tarjan-graph'));
require('long');

class ErrorWithCause extends Error {
    constructor(message, cause) {
        super(typeof message === "string" ? message : undefined);
        this.cause = cause;
        if (typeof message !== "string") {
            this.cause = message;
        }
        if (this.cause) {
            this.stack += `\nCaused by: ${this.cause.stack}`;
        }
    }
}

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

const dataform = $root.dataform = (() => {

    /**
     * Namespace dataform.
     * @exports dataform
     * @namespace
     */
    const dataform = {};

    dataform.ProjectConfig = (function() {

        /**
         * Properties of a ProjectConfig.
         * @memberof dataform
         * @interface IProjectConfig
         * @property {string|null} [warehouse] ProjectConfig warehouse
         * @property {string|null} [defaultDatabase] ProjectConfig defaultDatabase
         * @property {string|null} [defaultSchema] ProjectConfig defaultSchema
         * @property {string|null} [defaultLocation] ProjectConfig defaultLocation
         * @property {string|null} [assertionSchema] ProjectConfig assertionSchema
         * @property {Object.<string,string>|null} [vars] ProjectConfig vars
         * @property {number|null} [concurrentQueryLimit] ProjectConfig concurrentQueryLimit
         * @property {number|null} [idempotentActionRetries] ProjectConfig idempotentActionRetries
         * @property {string|null} [databaseSuffix] ProjectConfig databaseSuffix
         * @property {string|null} [schemaSuffix] ProjectConfig schemaSuffix
         * @property {string|null} [tablePrefix] ProjectConfig tablePrefix
         * @property {string|null} [gcloudProjectId] ProjectConfig gcloudProjectId
         * @property {boolean|null} [useRunCache] ProjectConfig useRunCache
         */

        /**
         * Constructs a new ProjectConfig.
         * @memberof dataform
         * @classdesc Represents a ProjectConfig.
         * @implements IProjectConfig
         * @constructor
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         */
        function ProjectConfig(properties) {
            this.vars = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProjectConfig warehouse.
         * @member {string} warehouse
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.warehouse = "";

        /**
         * ProjectConfig defaultDatabase.
         * @member {string} defaultDatabase
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultDatabase = "";

        /**
         * ProjectConfig defaultSchema.
         * @member {string} defaultSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultSchema = "";

        /**
         * ProjectConfig defaultLocation.
         * @member {string} defaultLocation
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.defaultLocation = "";

        /**
         * ProjectConfig assertionSchema.
         * @member {string} assertionSchema
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.assertionSchema = "";

        /**
         * ProjectConfig vars.
         * @member {Object.<string,string>} vars
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.vars = $util.emptyObject;

        /**
         * ProjectConfig concurrentQueryLimit.
         * @member {number} concurrentQueryLimit
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.concurrentQueryLimit = 0;

        /**
         * ProjectConfig idempotentActionRetries.
         * @member {number} idempotentActionRetries
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.idempotentActionRetries = 0;

        /**
         * ProjectConfig databaseSuffix.
         * @member {string} databaseSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.databaseSuffix = "";

        /**
         * ProjectConfig schemaSuffix.
         * @member {string} schemaSuffix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.schemaSuffix = "";

        /**
         * ProjectConfig tablePrefix.
         * @member {string} tablePrefix
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.tablePrefix = "";

        /**
         * ProjectConfig gcloudProjectId.
         * @member {string} gcloudProjectId
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.gcloudProjectId = "";

        /**
         * ProjectConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.ProjectConfig
         * @instance
         */
        ProjectConfig.prototype.useRunCache = false;

        /**
         * Creates a new ProjectConfig instance using the specified properties.
         * @function create
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig=} [properties] Properties to set
         * @returns {dataform.ProjectConfig} ProjectConfig instance
         */
        ProjectConfig.create = function create(properties) {
            return new ProjectConfig(properties);
        };

        /**
         * Encodes the specified ProjectConfig message. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.warehouse != null && Object.hasOwnProperty.call(message, "warehouse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.warehouse);
            if (message.defaultSchema != null && Object.hasOwnProperty.call(message, "defaultSchema"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.defaultSchema);
            if (message.assertionSchema != null && Object.hasOwnProperty.call(message, "assertionSchema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.assertionSchema);
            if (message.gcloudProjectId != null && Object.hasOwnProperty.call(message, "gcloudProjectId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gcloudProjectId);
            if (message.schemaSuffix != null && Object.hasOwnProperty.call(message, "schemaSuffix"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.schemaSuffix);
            if (message.idempotentActionRetries != null && Object.hasOwnProperty.call(message, "idempotentActionRetries"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.idempotentActionRetries);
            if (message.defaultDatabase != null && Object.hasOwnProperty.call(message, "defaultDatabase"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.defaultDatabase);
            if (message.useRunCache != null && Object.hasOwnProperty.call(message, "useRunCache"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.useRunCache);
            if (message.tablePrefix != null && Object.hasOwnProperty.call(message, "tablePrefix"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.tablePrefix);
            if (message.concurrentQueryLimit != null && Object.hasOwnProperty.call(message, "concurrentQueryLimit"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.concurrentQueryLimit);
            if (message.vars != null && Object.hasOwnProperty.call(message, "vars"))
                for (let keys = Object.keys(message.vars), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.vars[keys[i]]).ldelim();
            if (message.databaseSuffix != null && Object.hasOwnProperty.call(message, "databaseSuffix"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.databaseSuffix);
            if (message.defaultLocation != null && Object.hasOwnProperty.call(message, "defaultLocation"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.defaultLocation);
            return writer;
        };

        /**
         * Encodes the specified ProjectConfig message, length delimited. Does not implicitly {@link dataform.ProjectConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.IProjectConfig} message ProjectConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProjectConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ProjectConfig(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.warehouse = reader.string();
                        break;
                    }
                case 9: {
                        message.defaultDatabase = reader.string();
                        break;
                    }
                case 2: {
                        message.defaultSchema = reader.string();
                        break;
                    }
                case 16: {
                        message.defaultLocation = reader.string();
                        break;
                    }
                case 5: {
                        message.assertionSchema = reader.string();
                        break;
                    }
                case 14: {
                        if (message.vars === $util.emptyObject)
                            message.vars = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.vars[key] = value;
                        break;
                    }
                case 13: {
                        message.concurrentQueryLimit = reader.int32();
                        break;
                    }
                case 8: {
                        message.idempotentActionRetries = reader.int32();
                        break;
                    }
                case 15: {
                        message.databaseSuffix = reader.string();
                        break;
                    }
                case 7: {
                        message.schemaSuffix = reader.string();
                        break;
                    }
                case 11: {
                        message.tablePrefix = reader.string();
                        break;
                    }
                case 6: {
                        message.gcloudProjectId = reader.string();
                        break;
                    }
                case 10: {
                        message.useRunCache = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProjectConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ProjectConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ProjectConfig} ProjectConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProjectConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProjectConfig message.
         * @function verify
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProjectConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                if (!$util.isString(message.defaultDatabase))
                    return "defaultDatabase: string expected";
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                if (!$util.isString(message.defaultSchema))
                    return "defaultSchema: string expected";
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                if (!$util.isString(message.defaultLocation))
                    return "defaultLocation: string expected";
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                if (!$util.isString(message.assertionSchema))
                    return "assertionSchema: string expected";
            if (message.vars != null && message.hasOwnProperty("vars")) {
                if (!$util.isObject(message.vars))
                    return "vars: object expected";
                let key = Object.keys(message.vars);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.vars[key[i]]))
                        return "vars: string{k:string} expected";
            }
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                if (!$util.isInteger(message.concurrentQueryLimit))
                    return "concurrentQueryLimit: integer expected";
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                if (!$util.isInteger(message.idempotentActionRetries))
                    return "idempotentActionRetries: integer expected";
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                if (!$util.isString(message.databaseSuffix))
                    return "databaseSuffix: string expected";
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                if (!$util.isString(message.schemaSuffix))
                    return "schemaSuffix: string expected";
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                if (!$util.isString(message.tablePrefix))
                    return "tablePrefix: string expected";
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                if (!$util.isString(message.gcloudProjectId))
                    return "gcloudProjectId: string expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            return null;
        };

        /**
         * Creates a ProjectConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ProjectConfig} ProjectConfig
         */
        ProjectConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ProjectConfig)
                return object;
            let message = new $root.dataform.ProjectConfig();
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            if (object.defaultDatabase != null)
                message.defaultDatabase = String(object.defaultDatabase);
            if (object.defaultSchema != null)
                message.defaultSchema = String(object.defaultSchema);
            if (object.defaultLocation != null)
                message.defaultLocation = String(object.defaultLocation);
            if (object.assertionSchema != null)
                message.assertionSchema = String(object.assertionSchema);
            if (object.vars) {
                if (typeof object.vars !== "object")
                    throw TypeError(".dataform.ProjectConfig.vars: object expected");
                message.vars = {};
                for (let keys = Object.keys(object.vars), i = 0; i < keys.length; ++i)
                    message.vars[keys[i]] = String(object.vars[keys[i]]);
            }
            if (object.concurrentQueryLimit != null)
                message.concurrentQueryLimit = object.concurrentQueryLimit | 0;
            if (object.idempotentActionRetries != null)
                message.idempotentActionRetries = object.idempotentActionRetries | 0;
            if (object.databaseSuffix != null)
                message.databaseSuffix = String(object.databaseSuffix);
            if (object.schemaSuffix != null)
                message.schemaSuffix = String(object.schemaSuffix);
            if (object.tablePrefix != null)
                message.tablePrefix = String(object.tablePrefix);
            if (object.gcloudProjectId != null)
                message.gcloudProjectId = String(object.gcloudProjectId);
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            return message;
        };

        /**
         * Creates a plain object from a ProjectConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ProjectConfig
         * @static
         * @param {dataform.ProjectConfig} message ProjectConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ProjectConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.vars = {};
            if (options.defaults) {
                object.warehouse = "";
                object.defaultSchema = "";
                object.assertionSchema = "";
                object.gcloudProjectId = "";
                object.schemaSuffix = "";
                object.idempotentActionRetries = 0;
                object.defaultDatabase = "";
                object.useRunCache = false;
                object.tablePrefix = "";
                object.concurrentQueryLimit = 0;
                object.databaseSuffix = "";
                object.defaultLocation = "";
            }
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            if (message.defaultSchema != null && message.hasOwnProperty("defaultSchema"))
                object.defaultSchema = message.defaultSchema;
            if (message.assertionSchema != null && message.hasOwnProperty("assertionSchema"))
                object.assertionSchema = message.assertionSchema;
            if (message.gcloudProjectId != null && message.hasOwnProperty("gcloudProjectId"))
                object.gcloudProjectId = message.gcloudProjectId;
            if (message.schemaSuffix != null && message.hasOwnProperty("schemaSuffix"))
                object.schemaSuffix = message.schemaSuffix;
            if (message.idempotentActionRetries != null && message.hasOwnProperty("idempotentActionRetries"))
                object.idempotentActionRetries = message.idempotentActionRetries;
            if (message.defaultDatabase != null && message.hasOwnProperty("defaultDatabase"))
                object.defaultDatabase = message.defaultDatabase;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.tablePrefix != null && message.hasOwnProperty("tablePrefix"))
                object.tablePrefix = message.tablePrefix;
            if (message.concurrentQueryLimit != null && message.hasOwnProperty("concurrentQueryLimit"))
                object.concurrentQueryLimit = message.concurrentQueryLimit;
            let keys2;
            if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                object.vars = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.vars[keys2[j]] = message.vars[keys2[j]];
            }
            if (message.databaseSuffix != null && message.hasOwnProperty("databaseSuffix"))
                object.databaseSuffix = message.databaseSuffix;
            if (message.defaultLocation != null && message.hasOwnProperty("defaultLocation"))
                object.defaultLocation = message.defaultLocation;
            return object;
        };

        /**
         * Converts this ProjectConfig to JSON.
         * @function toJSON
         * @memberof dataform.ProjectConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ProjectConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ProjectConfig
         * @function getTypeUrl
         * @memberof dataform.ProjectConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ProjectConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ProjectConfig";
        };

        return ProjectConfig;
    })();

    dataform.GenerateIndexConfig = (function() {

        /**
         * Properties of a GenerateIndexConfig.
         * @memberof dataform
         * @interface IGenerateIndexConfig
         * @property {dataform.ICompileConfig|null} [compileConfig] GenerateIndexConfig compileConfig
         * @property {Array.<string>|null} [includePaths] GenerateIndexConfig includePaths
         * @property {Array.<string>|null} [definitionPaths] GenerateIndexConfig definitionPaths
         */

        /**
         * Constructs a new GenerateIndexConfig.
         * @memberof dataform
         * @classdesc Represents a GenerateIndexConfig.
         * @implements IGenerateIndexConfig
         * @constructor
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         */
        function GenerateIndexConfig(properties) {
            this.includePaths = [];
            this.definitionPaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GenerateIndexConfig compileConfig.
         * @member {dataform.ICompileConfig|null|undefined} compileConfig
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.compileConfig = null;

        /**
         * GenerateIndexConfig includePaths.
         * @member {Array.<string>} includePaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.includePaths = $util.emptyArray;

        /**
         * GenerateIndexConfig definitionPaths.
         * @member {Array.<string>} definitionPaths
         * @memberof dataform.GenerateIndexConfig
         * @instance
         */
        GenerateIndexConfig.prototype.definitionPaths = $util.emptyArray;

        /**
         * Creates a new GenerateIndexConfig instance using the specified properties.
         * @function create
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig=} [properties] Properties to set
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig instance
         */
        GenerateIndexConfig.create = function create(properties) {
            return new GenerateIndexConfig(properties);
        };

        /**
         * Encodes the specified GenerateIndexConfig message. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compileConfig != null && Object.hasOwnProperty.call(message, "compileConfig"))
                $root.dataform.CompileConfig.encode(message.compileConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.includePaths != null && message.includePaths.length)
                for (let i = 0; i < message.includePaths.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.includePaths[i]);
            if (message.definitionPaths != null && message.definitionPaths.length)
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.definitionPaths[i]);
            return writer;
        };

        /**
         * Encodes the specified GenerateIndexConfig message, length delimited. Does not implicitly {@link dataform.GenerateIndexConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.IGenerateIndexConfig} message GenerateIndexConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenerateIndexConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GenerateIndexConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compileConfig = $root.dataform.CompileConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.includePaths && message.includePaths.length))
                            message.includePaths = [];
                        message.includePaths.push(reader.string());
                        break;
                    }
                case 3: {
                        if (!(message.definitionPaths && message.definitionPaths.length))
                            message.definitionPaths = [];
                        message.definitionPaths.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenerateIndexConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenerateIndexConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenerateIndexConfig message.
         * @function verify
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenerateIndexConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig")) {
                let error = $root.dataform.CompileConfig.verify(message.compileConfig);
                if (error)
                    return "compileConfig." + error;
            }
            if (message.includePaths != null && message.hasOwnProperty("includePaths")) {
                if (!Array.isArray(message.includePaths))
                    return "includePaths: array expected";
                for (let i = 0; i < message.includePaths.length; ++i)
                    if (!$util.isString(message.includePaths[i]))
                        return "includePaths: string[] expected";
            }
            if (message.definitionPaths != null && message.hasOwnProperty("definitionPaths")) {
                if (!Array.isArray(message.definitionPaths))
                    return "definitionPaths: array expected";
                for (let i = 0; i < message.definitionPaths.length; ++i)
                    if (!$util.isString(message.definitionPaths[i]))
                        return "definitionPaths: string[] expected";
            }
            return null;
        };

        /**
         * Creates a GenerateIndexConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GenerateIndexConfig} GenerateIndexConfig
         */
        GenerateIndexConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GenerateIndexConfig)
                return object;
            let message = new $root.dataform.GenerateIndexConfig();
            if (object.compileConfig != null) {
                if (typeof object.compileConfig !== "object")
                    throw TypeError(".dataform.GenerateIndexConfig.compileConfig: object expected");
                message.compileConfig = $root.dataform.CompileConfig.fromObject(object.compileConfig);
            }
            if (object.includePaths) {
                if (!Array.isArray(object.includePaths))
                    throw TypeError(".dataform.GenerateIndexConfig.includePaths: array expected");
                message.includePaths = [];
                for (let i = 0; i < object.includePaths.length; ++i)
                    message.includePaths[i] = String(object.includePaths[i]);
            }
            if (object.definitionPaths) {
                if (!Array.isArray(object.definitionPaths))
                    throw TypeError(".dataform.GenerateIndexConfig.definitionPaths: array expected");
                message.definitionPaths = [];
                for (let i = 0; i < object.definitionPaths.length; ++i)
                    message.definitionPaths[i] = String(object.definitionPaths[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a GenerateIndexConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {dataform.GenerateIndexConfig} message GenerateIndexConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenerateIndexConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.includePaths = [];
                object.definitionPaths = [];
            }
            if (options.defaults)
                object.compileConfig = null;
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                object.compileConfig = $root.dataform.CompileConfig.toObject(message.compileConfig, options);
            if (message.includePaths && message.includePaths.length) {
                object.includePaths = [];
                for (let j = 0; j < message.includePaths.length; ++j)
                    object.includePaths[j] = message.includePaths[j];
            }
            if (message.definitionPaths && message.definitionPaths.length) {
                object.definitionPaths = [];
                for (let j = 0; j < message.definitionPaths.length; ++j)
                    object.definitionPaths[j] = message.definitionPaths[j];
            }
            return object;
        };

        /**
         * Converts this GenerateIndexConfig to JSON.
         * @function toJSON
         * @memberof dataform.GenerateIndexConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenerateIndexConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GenerateIndexConfig
         * @function getTypeUrl
         * @memberof dataform.GenerateIndexConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GenerateIndexConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.GenerateIndexConfig";
        };

        return GenerateIndexConfig;
    })();

    dataform.CompileConfig = (function() {

        /**
         * Properties of a CompileConfig.
         * @memberof dataform
         * @interface ICompileConfig
         * @property {string|null} [projectDir] CompileConfig projectDir
         * @property {Array.<string>|null} [filePaths] CompileConfig filePaths
         * @property {dataform.IProjectConfig|null} [projectConfigOverride] CompileConfig projectConfigOverride
         * @property {number|null} [timeoutMillis] CompileConfig timeoutMillis
         * @property {boolean|null} [useMain] CompileConfig useMain
         */

        /**
         * Constructs a new CompileConfig.
         * @memberof dataform
         * @classdesc Represents a CompileConfig.
         * @implements ICompileConfig
         * @constructor
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         */
        function CompileConfig(properties) {
            this.filePaths = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileConfig projectDir.
         * @member {string} projectDir
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectDir = "";

        /**
         * CompileConfig filePaths.
         * @member {Array.<string>} filePaths
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.filePaths = $util.emptyArray;

        /**
         * CompileConfig projectConfigOverride.
         * @member {dataform.IProjectConfig|null|undefined} projectConfigOverride
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.projectConfigOverride = null;

        /**
         * CompileConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.timeoutMillis = 0;

        /**
         * CompileConfig useMain.
         * @member {boolean} useMain
         * @memberof dataform.CompileConfig
         * @instance
         */
        CompileConfig.prototype.useMain = false;

        /**
         * Creates a new CompileConfig instance using the specified properties.
         * @function create
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig=} [properties] Properties to set
         * @returns {dataform.CompileConfig} CompileConfig instance
         */
        CompileConfig.create = function create(properties) {
            return new CompileConfig(properties);
        };

        /**
         * Encodes the specified CompileConfig message. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectDir != null && Object.hasOwnProperty.call(message, "projectDir"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
            if (message.projectConfigOverride != null && Object.hasOwnProperty.call(message, "projectConfigOverride"))
                $root.dataform.ProjectConfig.encode(message.projectConfigOverride, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timeoutMillis != null && Object.hasOwnProperty.call(message, "timeoutMillis"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.timeoutMillis);
            if (message.filePaths != null && message.filePaths.length)
                for (let i = 0; i < message.filePaths.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.filePaths[i]);
            if (message.useMain != null && Object.hasOwnProperty.call(message, "useMain"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.useMain);
            return writer;
        };

        /**
         * Encodes the specified CompileConfig message, length delimited. Does not implicitly {@link dataform.CompileConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.ICompileConfig} message CompileConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectDir = reader.string();
                        break;
                    }
                case 8: {
                        if (!(message.filePaths && message.filePaths.length))
                            message.filePaths = [];
                        message.filePaths.push(reader.string());
                        break;
                    }
                case 3: {
                        message.projectConfigOverride = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.timeoutMillis = reader.int32();
                        break;
                    }
                case 9: {
                        message.useMain = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileConfig} CompileConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileConfig message.
         * @function verify
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                if (!$util.isString(message.projectDir))
                    return "projectDir: string expected";
            if (message.filePaths != null && message.hasOwnProperty("filePaths")) {
                if (!Array.isArray(message.filePaths))
                    return "filePaths: array expected";
                for (let i = 0; i < message.filePaths.length; ++i)
                    if (!$util.isString(message.filePaths[i]))
                        return "filePaths: string[] expected";
            }
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfigOverride);
                if (error)
                    return "projectConfigOverride." + error;
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.useMain != null && message.hasOwnProperty("useMain"))
                if (typeof message.useMain !== "boolean")
                    return "useMain: boolean expected";
            return null;
        };

        /**
         * Creates a CompileConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileConfig} CompileConfig
         */
        CompileConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileConfig)
                return object;
            let message = new $root.dataform.CompileConfig();
            if (object.projectDir != null)
                message.projectDir = String(object.projectDir);
            if (object.filePaths) {
                if (!Array.isArray(object.filePaths))
                    throw TypeError(".dataform.CompileConfig.filePaths: array expected");
                message.filePaths = [];
                for (let i = 0; i < object.filePaths.length; ++i)
                    message.filePaths[i] = String(object.filePaths[i]);
            }
            if (object.projectConfigOverride != null) {
                if (typeof object.projectConfigOverride !== "object")
                    throw TypeError(".dataform.CompileConfig.projectConfigOverride: object expected");
                message.projectConfigOverride = $root.dataform.ProjectConfig.fromObject(object.projectConfigOverride);
            }
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.useMain != null)
                message.useMain = Boolean(object.useMain);
            return message;
        };

        /**
         * Creates a plain object from a CompileConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileConfig
         * @static
         * @param {dataform.CompileConfig} message CompileConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.filePaths = [];
            if (options.defaults) {
                object.projectDir = "";
                object.projectConfigOverride = null;
                object.timeoutMillis = 0;
                object.useMain = false;
            }
            if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                object.projectDir = message.projectDir;
            if (message.projectConfigOverride != null && message.hasOwnProperty("projectConfigOverride"))
                object.projectConfigOverride = $root.dataform.ProjectConfig.toObject(message.projectConfigOverride, options);
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.filePaths && message.filePaths.length) {
                object.filePaths = [];
                for (let j = 0; j < message.filePaths.length; ++j)
                    object.filePaths[j] = message.filePaths[j];
            }
            if (message.useMain != null && message.hasOwnProperty("useMain"))
                object.useMain = message.useMain;
            return object;
        };

        /**
         * Converts this CompileConfig to JSON.
         * @function toJSON
         * @memberof dataform.CompileConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileConfig
         * @function getTypeUrl
         * @memberof dataform.CompileConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileConfig";
        };

        return CompileConfig;
    })();

    dataform.Target = (function() {

        /**
         * Properties of a Target.
         * @memberof dataform
         * @interface ITarget
         * @property {string|null} [database] Target database
         * @property {string|null} [schema] Target schema
         * @property {string|null} [name] Target name
         */

        /**
         * Constructs a new Target.
         * @memberof dataform
         * @classdesc Represents a Target.
         * @implements ITarget
         * @constructor
         * @param {dataform.ITarget=} [properties] Properties to set
         */
        function Target(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Target database.
         * @member {string} database
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.database = "";

        /**
         * Target schema.
         * @member {string} schema
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.schema = "";

        /**
         * Target name.
         * @member {string} name
         * @memberof dataform.Target
         * @instance
         */
        Target.prototype.name = "";

        /**
         * Creates a new Target instance using the specified properties.
         * @function create
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget=} [properties] Properties to set
         * @returns {dataform.Target} Target instance
         */
        Target.create = function create(properties) {
            return new Target(properties);
        };

        /**
         * Encodes the specified Target message. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encode
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.schema);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified Target message, length delimited. Does not implicitly {@link dataform.Target.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {dataform.ITarget} message Target message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Target.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Target message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Target();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.database = reader.string();
                        break;
                    }
                case 1: {
                        message.schema = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Target message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Target
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Target} Target
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Target.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Target message.
         * @function verify
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Target.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a Target message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Target
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Target} Target
         */
        Target.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Target)
                return object;
            let message = new $root.dataform.Target();
            if (object.database != null)
                message.database = String(object.database);
            if (object.schema != null)
                message.schema = String(object.schema);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a Target message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Target
         * @static
         * @param {dataform.Target} message Target
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Target.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.schema = "";
                object.name = "";
                object.database = "";
            }
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this Target to JSON.
         * @function toJSON
         * @memberof dataform.Target
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Target.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Target
         * @function getTypeUrl
         * @memberof dataform.Target
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Target.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Target";
        };

        return Target;
    })();

    dataform.BigQueryOptions = (function() {

        /**
         * Properties of a BigQueryOptions.
         * @memberof dataform
         * @interface IBigQueryOptions
         * @property {string|null} [partitionBy] BigQueryOptions partitionBy
         * @property {Array.<string>|null} [clusterBy] BigQueryOptions clusterBy
         * @property {string|null} [updatePartitionFilter] BigQueryOptions updatePartitionFilter
         * @property {Object.<string,string>|null} [labels] BigQueryOptions labels
         * @property {number|null} [partitionExpirationDays] BigQueryOptions partitionExpirationDays
         * @property {boolean|null} [requirePartitionFilter] BigQueryOptions requirePartitionFilter
         * @property {Object.<string,string>|null} [additionalOptions] BigQueryOptions additionalOptions
         */

        /**
         * Constructs a new BigQueryOptions.
         * @memberof dataform
         * @classdesc Represents a BigQueryOptions.
         * @implements IBigQueryOptions
         * @constructor
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         */
        function BigQueryOptions(properties) {
            this.clusterBy = [];
            this.labels = {};
            this.additionalOptions = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQueryOptions partitionBy.
         * @member {string} partitionBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionBy = "";

        /**
         * BigQueryOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * BigQueryOptions updatePartitionFilter.
         * @member {string} updatePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.updatePartitionFilter = "";

        /**
         * BigQueryOptions labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.labels = $util.emptyObject;

        /**
         * BigQueryOptions partitionExpirationDays.
         * @member {number} partitionExpirationDays
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.partitionExpirationDays = 0;

        /**
         * BigQueryOptions requirePartitionFilter.
         * @member {boolean} requirePartitionFilter
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.requirePartitionFilter = false;

        /**
         * BigQueryOptions additionalOptions.
         * @member {Object.<string,string>} additionalOptions
         * @memberof dataform.BigQueryOptions
         * @instance
         */
        BigQueryOptions.prototype.additionalOptions = $util.emptyObject;

        /**
         * Creates a new BigQueryOptions instance using the specified properties.
         * @function create
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions=} [properties] Properties to set
         * @returns {dataform.BigQueryOptions} BigQueryOptions instance
         */
        BigQueryOptions.create = function create(properties) {
            return new BigQueryOptions(properties);
        };

        /**
         * Encodes the specified BigQueryOptions message. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && Object.hasOwnProperty.call(message, "partitionBy"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.partitionBy);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clusterBy[i]);
            if (message.updatePartitionFilter != null && Object.hasOwnProperty.call(message, "updatePartitionFilter"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.updatePartitionFilter);
            if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.partitionExpirationDays != null && Object.hasOwnProperty.call(message, "partitionExpirationDays"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.partitionExpirationDays);
            if (message.requirePartitionFilter != null && Object.hasOwnProperty.call(message, "requirePartitionFilter"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.requirePartitionFilter);
            if (message.additionalOptions != null && Object.hasOwnProperty.call(message, "additionalOptions"))
                for (let keys = Object.keys(message.additionalOptions), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.additionalOptions[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BigQueryOptions message, length delimited. Does not implicitly {@link dataform.BigQueryOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.IBigQueryOptions} message BigQueryOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQueryOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQueryOptions(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.partitionBy = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.clusterBy && message.clusterBy.length))
                            message.clusterBy = [];
                        message.clusterBy.push(reader.string());
                        break;
                    }
                case 3: {
                        message.updatePartitionFilter = reader.string();
                        break;
                    }
                case 4: {
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    }
                case 5: {
                        message.partitionExpirationDays = reader.int32();
                        break;
                    }
                case 6: {
                        message.requirePartitionFilter = reader.bool();
                        break;
                    }
                case 7: {
                        if (message.additionalOptions === $util.emptyObject)
                            message.additionalOptions = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.additionalOptions[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQueryOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQueryOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQueryOptions message.
         * @function verify
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQueryOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                if (!$util.isString(message.partitionBy))
                    return "partitionBy: string expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                if (!$util.isString(message.updatePartitionFilter))
                    return "updatePartitionFilter: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                if (!$util.isInteger(message.partitionExpirationDays))
                    return "partitionExpirationDays: integer expected";
            if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                if (typeof message.requirePartitionFilter !== "boolean")
                    return "requirePartitionFilter: boolean expected";
            if (message.additionalOptions != null && message.hasOwnProperty("additionalOptions")) {
                if (!$util.isObject(message.additionalOptions))
                    return "additionalOptions: object expected";
                let key = Object.keys(message.additionalOptions);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.additionalOptions[key[i]]))
                        return "additionalOptions: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a BigQueryOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQueryOptions} BigQueryOptions
         */
        BigQueryOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQueryOptions)
                return object;
            let message = new $root.dataform.BigQueryOptions();
            if (object.partitionBy != null)
                message.partitionBy = String(object.partitionBy);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.BigQueryOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            if (object.updatePartitionFilter != null)
                message.updatePartitionFilter = String(object.updatePartitionFilter);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.BigQueryOptions.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.partitionExpirationDays != null)
                message.partitionExpirationDays = object.partitionExpirationDays | 0;
            if (object.requirePartitionFilter != null)
                message.requirePartitionFilter = Boolean(object.requirePartitionFilter);
            if (object.additionalOptions) {
                if (typeof object.additionalOptions !== "object")
                    throw TypeError(".dataform.BigQueryOptions.additionalOptions: object expected");
                message.additionalOptions = {};
                for (let keys = Object.keys(object.additionalOptions), i = 0; i < keys.length; ++i)
                    message.additionalOptions[keys[i]] = String(object.additionalOptions[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a BigQueryOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {dataform.BigQueryOptions} message BigQueryOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQueryOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.objects || options.defaults) {
                object.labels = {};
                object.additionalOptions = {};
            }
            if (options.defaults) {
                object.partitionBy = "";
                object.updatePartitionFilter = "";
                object.partitionExpirationDays = 0;
                object.requirePartitionFilter = false;
            }
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy"))
                object.partitionBy = message.partitionBy;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            if (message.updatePartitionFilter != null && message.hasOwnProperty("updatePartitionFilter"))
                object.updatePartitionFilter = message.updatePartitionFilter;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.partitionExpirationDays != null && message.hasOwnProperty("partitionExpirationDays"))
                object.partitionExpirationDays = message.partitionExpirationDays;
            if (message.requirePartitionFilter != null && message.hasOwnProperty("requirePartitionFilter"))
                object.requirePartitionFilter = message.requirePartitionFilter;
            if (message.additionalOptions && (keys2 = Object.keys(message.additionalOptions)).length) {
                object.additionalOptions = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.additionalOptions[keys2[j]] = message.additionalOptions[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this BigQueryOptions to JSON.
         * @function toJSON
         * @memberof dataform.BigQueryOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQueryOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BigQueryOptions
         * @function getTypeUrl
         * @memberof dataform.BigQueryOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BigQueryOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.BigQueryOptions";
        };

        return BigQueryOptions;
    })();

    dataform.RedshiftOptions = (function() {

        /**
         * Properties of a RedshiftOptions.
         * @memberof dataform
         * @interface IRedshiftOptions
         * @property {string|null} [distKey] RedshiftOptions distKey
         * @property {string|null} [distStyle] RedshiftOptions distStyle
         * @property {Array.<string>|null} [sortKeys] RedshiftOptions sortKeys
         * @property {string|null} [sortStyle] RedshiftOptions sortStyle
         * @property {boolean|null} [bind] RedshiftOptions bind
         */

        /**
         * Constructs a new RedshiftOptions.
         * @memberof dataform
         * @classdesc Represents a RedshiftOptions.
         * @implements IRedshiftOptions
         * @constructor
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         */
        function RedshiftOptions(properties) {
            this.sortKeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RedshiftOptions distKey.
         * @member {string} distKey
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distKey = "";

        /**
         * RedshiftOptions distStyle.
         * @member {string} distStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.distStyle = "";

        /**
         * RedshiftOptions sortKeys.
         * @member {Array.<string>} sortKeys
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortKeys = $util.emptyArray;

        /**
         * RedshiftOptions sortStyle.
         * @member {string} sortStyle
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.sortStyle = "";

        /**
         * RedshiftOptions bind.
         * @member {boolean} bind
         * @memberof dataform.RedshiftOptions
         * @instance
         */
        RedshiftOptions.prototype.bind = false;

        /**
         * Creates a new RedshiftOptions instance using the specified properties.
         * @function create
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions=} [properties] Properties to set
         * @returns {dataform.RedshiftOptions} RedshiftOptions instance
         */
        RedshiftOptions.create = function create(properties) {
            return new RedshiftOptions(properties);
        };

        /**
         * Encodes the specified RedshiftOptions message. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distKey != null && Object.hasOwnProperty.call(message, "distKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distKey);
            if (message.distStyle != null && Object.hasOwnProperty.call(message, "distStyle"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.distStyle);
            if (message.sortKeys != null && message.sortKeys.length)
                for (let i = 0; i < message.sortKeys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sortKeys[i]);
            if (message.sortStyle != null && Object.hasOwnProperty.call(message, "sortStyle"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sortStyle);
            if (message.bind != null && Object.hasOwnProperty.call(message, "bind"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.bind);
            return writer;
        };

        /**
         * Encodes the specified RedshiftOptions message, length delimited. Does not implicitly {@link dataform.RedshiftOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.IRedshiftOptions} message RedshiftOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedshiftOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RedshiftOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.distKey = reader.string();
                        break;
                    }
                case 2: {
                        message.distStyle = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.sortKeys && message.sortKeys.length))
                            message.sortKeys = [];
                        message.sortKeys.push(reader.string());
                        break;
                    }
                case 4: {
                        message.sortStyle = reader.string();
                        break;
                    }
                case 5: {
                        message.bind = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RedshiftOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedshiftOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RedshiftOptions message.
         * @function verify
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RedshiftOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                if (!$util.isString(message.distKey))
                    return "distKey: string expected";
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                if (!$util.isString(message.distStyle))
                    return "distStyle: string expected";
            if (message.sortKeys != null && message.hasOwnProperty("sortKeys")) {
                if (!Array.isArray(message.sortKeys))
                    return "sortKeys: array expected";
                for (let i = 0; i < message.sortKeys.length; ++i)
                    if (!$util.isString(message.sortKeys[i]))
                        return "sortKeys: string[] expected";
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                if (!$util.isString(message.sortStyle))
                    return "sortStyle: string expected";
            if (message.bind != null && message.hasOwnProperty("bind"))
                if (typeof message.bind !== "boolean")
                    return "bind: boolean expected";
            return null;
        };

        /**
         * Creates a RedshiftOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RedshiftOptions} RedshiftOptions
         */
        RedshiftOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RedshiftOptions)
                return object;
            let message = new $root.dataform.RedshiftOptions();
            if (object.distKey != null)
                message.distKey = String(object.distKey);
            if (object.distStyle != null)
                message.distStyle = String(object.distStyle);
            if (object.sortKeys) {
                if (!Array.isArray(object.sortKeys))
                    throw TypeError(".dataform.RedshiftOptions.sortKeys: array expected");
                message.sortKeys = [];
                for (let i = 0; i < object.sortKeys.length; ++i)
                    message.sortKeys[i] = String(object.sortKeys[i]);
            }
            if (object.sortStyle != null)
                message.sortStyle = String(object.sortStyle);
            if (object.bind != null)
                message.bind = Boolean(object.bind);
            return message;
        };

        /**
         * Creates a plain object from a RedshiftOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {dataform.RedshiftOptions} message RedshiftOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedshiftOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.sortKeys = [];
            if (options.defaults) {
                object.distKey = "";
                object.distStyle = "";
                object.sortStyle = "";
                object.bind = false;
            }
            if (message.distKey != null && message.hasOwnProperty("distKey"))
                object.distKey = message.distKey;
            if (message.distStyle != null && message.hasOwnProperty("distStyle"))
                object.distStyle = message.distStyle;
            if (message.sortKeys && message.sortKeys.length) {
                object.sortKeys = [];
                for (let j = 0; j < message.sortKeys.length; ++j)
                    object.sortKeys[j] = message.sortKeys[j];
            }
            if (message.sortStyle != null && message.hasOwnProperty("sortStyle"))
                object.sortStyle = message.sortStyle;
            if (message.bind != null && message.hasOwnProperty("bind"))
                object.bind = message.bind;
            return object;
        };

        /**
         * Converts this RedshiftOptions to JSON.
         * @function toJSON
         * @memberof dataform.RedshiftOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedshiftOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RedshiftOptions
         * @function getTypeUrl
         * @memberof dataform.RedshiftOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RedshiftOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.RedshiftOptions";
        };

        return RedshiftOptions;
    })();

    dataform.SnowflakeOptions = (function() {

        /**
         * Properties of a SnowflakeOptions.
         * @memberof dataform
         * @interface ISnowflakeOptions
         * @property {boolean|null} [secure] SnowflakeOptions secure
         * @property {boolean|null} [transient] SnowflakeOptions transient
         * @property {Array.<string>|null} [clusterBy] SnowflakeOptions clusterBy
         */

        /**
         * Constructs a new SnowflakeOptions.
         * @memberof dataform
         * @classdesc Represents a SnowflakeOptions.
         * @implements ISnowflakeOptions
         * @constructor
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         */
        function SnowflakeOptions(properties) {
            this.clusterBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SnowflakeOptions secure.
         * @member {boolean} secure
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.secure = false;

        /**
         * SnowflakeOptions transient.
         * @member {boolean} transient
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.transient = false;

        /**
         * SnowflakeOptions clusterBy.
         * @member {Array.<string>} clusterBy
         * @memberof dataform.SnowflakeOptions
         * @instance
         */
        SnowflakeOptions.prototype.clusterBy = $util.emptyArray;

        /**
         * Creates a new SnowflakeOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions=} [properties] Properties to set
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions instance
         */
        SnowflakeOptions.create = function create(properties) {
            return new SnowflakeOptions(properties);
        };

        /**
         * Encodes the specified SnowflakeOptions message. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.secure != null && Object.hasOwnProperty.call(message, "secure"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.secure);
            if (message.transient != null && Object.hasOwnProperty.call(message, "transient"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.transient);
            if (message.clusterBy != null && message.clusterBy.length)
                for (let i = 0; i < message.clusterBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clusterBy[i]);
            return writer;
        };

        /**
         * Encodes the specified SnowflakeOptions message, length delimited. Does not implicitly {@link dataform.SnowflakeOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.ISnowflakeOptions} message SnowflakeOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SnowflakeOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SnowflakeOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.secure = reader.bool();
                        break;
                    }
                case 2: {
                        message.transient = reader.bool();
                        break;
                    }
                case 3: {
                        if (!(message.clusterBy && message.clusterBy.length))
                            message.clusterBy = [];
                        message.clusterBy.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SnowflakeOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SnowflakeOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SnowflakeOptions message.
         * @function verify
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SnowflakeOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.secure != null && message.hasOwnProperty("secure"))
                if (typeof message.secure !== "boolean")
                    return "secure: boolean expected";
            if (message.transient != null && message.hasOwnProperty("transient"))
                if (typeof message.transient !== "boolean")
                    return "transient: boolean expected";
            if (message.clusterBy != null && message.hasOwnProperty("clusterBy")) {
                if (!Array.isArray(message.clusterBy))
                    return "clusterBy: array expected";
                for (let i = 0; i < message.clusterBy.length; ++i)
                    if (!$util.isString(message.clusterBy[i]))
                        return "clusterBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a SnowflakeOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SnowflakeOptions} SnowflakeOptions
         */
        SnowflakeOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SnowflakeOptions)
                return object;
            let message = new $root.dataform.SnowflakeOptions();
            if (object.secure != null)
                message.secure = Boolean(object.secure);
            if (object.transient != null)
                message.transient = Boolean(object.transient);
            if (object.clusterBy) {
                if (!Array.isArray(object.clusterBy))
                    throw TypeError(".dataform.SnowflakeOptions.clusterBy: array expected");
                message.clusterBy = [];
                for (let i = 0; i < object.clusterBy.length; ++i)
                    message.clusterBy[i] = String(object.clusterBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SnowflakeOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {dataform.SnowflakeOptions} message SnowflakeOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SnowflakeOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.clusterBy = [];
            if (options.defaults) {
                object.secure = false;
                object.transient = false;
            }
            if (message.secure != null && message.hasOwnProperty("secure"))
                object.secure = message.secure;
            if (message.transient != null && message.hasOwnProperty("transient"))
                object.transient = message.transient;
            if (message.clusterBy && message.clusterBy.length) {
                object.clusterBy = [];
                for (let j = 0; j < message.clusterBy.length; ++j)
                    object.clusterBy[j] = message.clusterBy[j];
            }
            return object;
        };

        /**
         * Converts this SnowflakeOptions to JSON.
         * @function toJSON
         * @memberof dataform.SnowflakeOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SnowflakeOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SnowflakeOptions
         * @function getTypeUrl
         * @memberof dataform.SnowflakeOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SnowflakeOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.SnowflakeOptions";
        };

        return SnowflakeOptions;
    })();

    dataform.SQLDataWarehouseOptions = (function() {

        /**
         * Properties of a SQLDataWarehouseOptions.
         * @memberof dataform
         * @interface ISQLDataWarehouseOptions
         * @property {string|null} [distribution] SQLDataWarehouseOptions distribution
         */

        /**
         * Constructs a new SQLDataWarehouseOptions.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouseOptions.
         * @implements ISQLDataWarehouseOptions
         * @constructor
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         */
        function SQLDataWarehouseOptions(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouseOptions distribution.
         * @member {string} distribution
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         */
        SQLDataWarehouseOptions.prototype.distribution = "";

        /**
         * Creates a new SQLDataWarehouseOptions instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions instance
         */
        SQLDataWarehouseOptions.create = function create(properties) {
            return new SQLDataWarehouseOptions(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.distribution != null && Object.hasOwnProperty.call(message, "distribution"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.distribution);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouseOptions message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouseOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.ISQLDataWarehouseOptions} message SQLDataWarehouseOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouseOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouseOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.distribution = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouseOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouseOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouseOptions message.
         * @function verify
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouseOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                if (!$util.isString(message.distribution))
                    return "distribution: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouseOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouseOptions} SQLDataWarehouseOptions
         */
        SQLDataWarehouseOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouseOptions)
                return object;
            let message = new $root.dataform.SQLDataWarehouseOptions();
            if (object.distribution != null)
                message.distribution = String(object.distribution);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouseOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {dataform.SQLDataWarehouseOptions} message SQLDataWarehouseOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouseOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.distribution = "";
            if (message.distribution != null && message.hasOwnProperty("distribution"))
                object.distribution = message.distribution;
            return object;
        };

        /**
         * Converts this SQLDataWarehouseOptions to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouseOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouseOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SQLDataWarehouseOptions
         * @function getTypeUrl
         * @memberof dataform.SQLDataWarehouseOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SQLDataWarehouseOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.SQLDataWarehouseOptions";
        };

        return SQLDataWarehouseOptions;
    })();

    dataform.PrestoOptions = (function() {

        /**
         * Properties of a PrestoOptions.
         * @memberof dataform
         * @interface IPrestoOptions
         * @property {Array.<string>|null} [partitionBy] PrestoOptions partitionBy
         */

        /**
         * Constructs a new PrestoOptions.
         * @memberof dataform
         * @classdesc Represents a PrestoOptions.
         * @implements IPrestoOptions
         * @constructor
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         */
        function PrestoOptions(properties) {
            this.partitionBy = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrestoOptions partitionBy.
         * @member {Array.<string>} partitionBy
         * @memberof dataform.PrestoOptions
         * @instance
         */
        PrestoOptions.prototype.partitionBy = $util.emptyArray;

        /**
         * Creates a new PrestoOptions instance using the specified properties.
         * @function create
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions=} [properties] Properties to set
         * @returns {dataform.PrestoOptions} PrestoOptions instance
         */
        PrestoOptions.create = function create(properties) {
            return new PrestoOptions(properties);
        };

        /**
         * Encodes the specified PrestoOptions message. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.partitionBy != null && message.partitionBy.length)
                for (let i = 0; i < message.partitionBy.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.partitionBy[i]);
            return writer;
        };

        /**
         * Encodes the specified PrestoOptions message, length delimited. Does not implicitly {@link dataform.PrestoOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.IPrestoOptions} message PrestoOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrestoOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.PrestoOptions();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        if (!(message.partitionBy && message.partitionBy.length))
                            message.partitionBy = [];
                        message.partitionBy.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrestoOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.PrestoOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.PrestoOptions} PrestoOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrestoOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrestoOptions message.
         * @function verify
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrestoOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.partitionBy != null && message.hasOwnProperty("partitionBy")) {
                if (!Array.isArray(message.partitionBy))
                    return "partitionBy: array expected";
                for (let i = 0; i < message.partitionBy.length; ++i)
                    if (!$util.isString(message.partitionBy[i]))
                        return "partitionBy: string[] expected";
            }
            return null;
        };

        /**
         * Creates a PrestoOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.PrestoOptions} PrestoOptions
         */
        PrestoOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.PrestoOptions)
                return object;
            let message = new $root.dataform.PrestoOptions();
            if (object.partitionBy) {
                if (!Array.isArray(object.partitionBy))
                    throw TypeError(".dataform.PrestoOptions.partitionBy: array expected");
                message.partitionBy = [];
                for (let i = 0; i < object.partitionBy.length; ++i)
                    message.partitionBy[i] = String(object.partitionBy[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a PrestoOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.PrestoOptions
         * @static
         * @param {dataform.PrestoOptions} message PrestoOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PrestoOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.partitionBy = [];
            if (message.partitionBy && message.partitionBy.length) {
                object.partitionBy = [];
                for (let j = 0; j < message.partitionBy.length; ++j)
                    object.partitionBy[j] = message.partitionBy[j];
            }
            return object;
        };

        /**
         * Converts this PrestoOptions to JSON.
         * @function toJSON
         * @memberof dataform.PrestoOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PrestoOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PrestoOptions
         * @function getTypeUrl
         * @memberof dataform.PrestoOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PrestoOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.PrestoOptions";
        };

        return PrestoOptions;
    })();

    dataform.GraphErrors = (function() {

        /**
         * Properties of a GraphErrors.
         * @memberof dataform
         * @interface IGraphErrors
         * @property {Array.<dataform.ICompilationError>|null} [compilationErrors] GraphErrors compilationErrors
         */

        /**
         * Constructs a new GraphErrors.
         * @memberof dataform
         * @classdesc Represents a GraphErrors.
         * @implements IGraphErrors
         * @constructor
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         */
        function GraphErrors(properties) {
            this.compilationErrors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphErrors compilationErrors.
         * @member {Array.<dataform.ICompilationError>} compilationErrors
         * @memberof dataform.GraphErrors
         * @instance
         */
        GraphErrors.prototype.compilationErrors = $util.emptyArray;

        /**
         * Creates a new GraphErrors instance using the specified properties.
         * @function create
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors=} [properties] Properties to set
         * @returns {dataform.GraphErrors} GraphErrors instance
         */
        GraphErrors.create = function create(properties) {
            return new GraphErrors(properties);
        };

        /**
         * Encodes the specified GraphErrors message. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encode
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compilationErrors != null && message.compilationErrors.length)
                for (let i = 0; i < message.compilationErrors.length; ++i)
                    $root.dataform.CompilationError.encode(message.compilationErrors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphErrors message, length delimited. Does not implicitly {@link dataform.GraphErrors.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.IGraphErrors} message GraphErrors message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphErrors.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.GraphErrors();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.compilationErrors && message.compilationErrors.length))
                            message.compilationErrors = [];
                        message.compilationErrors.push($root.dataform.CompilationError.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphErrors message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.GraphErrors
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.GraphErrors} GraphErrors
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphErrors.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphErrors message.
         * @function verify
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphErrors.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compilationErrors != null && message.hasOwnProperty("compilationErrors")) {
                if (!Array.isArray(message.compilationErrors))
                    return "compilationErrors: array expected";
                for (let i = 0; i < message.compilationErrors.length; ++i) {
                    let error = $root.dataform.CompilationError.verify(message.compilationErrors[i]);
                    if (error)
                        return "compilationErrors." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphErrors message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.GraphErrors} GraphErrors
         */
        GraphErrors.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.GraphErrors)
                return object;
            let message = new $root.dataform.GraphErrors();
            if (object.compilationErrors) {
                if (!Array.isArray(object.compilationErrors))
                    throw TypeError(".dataform.GraphErrors.compilationErrors: array expected");
                message.compilationErrors = [];
                for (let i = 0; i < object.compilationErrors.length; ++i) {
                    if (typeof object.compilationErrors[i] !== "object")
                        throw TypeError(".dataform.GraphErrors.compilationErrors: object expected");
                    message.compilationErrors[i] = $root.dataform.CompilationError.fromObject(object.compilationErrors[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphErrors message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.GraphErrors
         * @static
         * @param {dataform.GraphErrors} message GraphErrors
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphErrors.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.compilationErrors = [];
            if (message.compilationErrors && message.compilationErrors.length) {
                object.compilationErrors = [];
                for (let j = 0; j < message.compilationErrors.length; ++j)
                    object.compilationErrors[j] = $root.dataform.CompilationError.toObject(message.compilationErrors[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphErrors to JSON.
         * @function toJSON
         * @memberof dataform.GraphErrors
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphErrors.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GraphErrors
         * @function getTypeUrl
         * @memberof dataform.GraphErrors
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GraphErrors.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.GraphErrors";
        };

        return GraphErrors;
    })();

    dataform.CompilationError = (function() {

        /**
         * Properties of a CompilationError.
         * @memberof dataform
         * @interface ICompilationError
         * @property {string|null} [fileName] CompilationError fileName
         * @property {string|null} [actionName] CompilationError actionName
         * @property {dataform.ITarget|null} [actionTarget] CompilationError actionTarget
         * @property {string|null} [message] CompilationError message
         * @property {string|null} [stack] CompilationError stack
         */

        /**
         * Constructs a new CompilationError.
         * @memberof dataform
         * @classdesc Represents a CompilationError.
         * @implements ICompilationError
         * @constructor
         * @param {dataform.ICompilationError=} [properties] Properties to set
         */
        function CompilationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompilationError fileName.
         * @member {string} fileName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.fileName = "";

        /**
         * CompilationError actionName.
         * @member {string} actionName
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionName = "";

        /**
         * CompilationError actionTarget.
         * @member {dataform.ITarget|null|undefined} actionTarget
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.actionTarget = null;

        /**
         * CompilationError message.
         * @member {string} message
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.message = "";

        /**
         * CompilationError stack.
         * @member {string} stack
         * @memberof dataform.CompilationError
         * @instance
         */
        CompilationError.prototype.stack = "";

        /**
         * Creates a new CompilationError instance using the specified properties.
         * @function create
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError=} [properties] Properties to set
         * @returns {dataform.CompilationError} CompilationError instance
         */
        CompilationError.create = function create(properties) {
            return new CompilationError(properties);
        };

        /**
         * Encodes the specified CompilationError message. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileName);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
            if (message.stack != null && Object.hasOwnProperty.call(message, "stack"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.stack);
            if (message.actionName != null && Object.hasOwnProperty.call(message, "actionName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.actionName);
            if (message.actionTarget != null && Object.hasOwnProperty.call(message, "actionTarget"))
                $root.dataform.Target.encode(message.actionTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompilationError message, length delimited. Does not implicitly {@link dataform.CompilationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.ICompilationError} message CompilationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompilationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompilationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.fileName = reader.string();
                        break;
                    }
                case 4: {
                        message.actionName = reader.string();
                        break;
                    }
                case 5: {
                        message.actionTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.message = reader.string();
                        break;
                    }
                case 3: {
                        message.stack = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompilationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompilationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompilationError} CompilationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompilationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompilationError message.
         * @function verify
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompilationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                if (!$util.isString(message.actionName))
                    return "actionName: string expected";
            if (message.actionTarget != null && message.hasOwnProperty("actionTarget")) {
                let error = $root.dataform.Target.verify(message.actionTarget);
                if (error)
                    return "actionTarget." + error;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.stack != null && message.hasOwnProperty("stack"))
                if (!$util.isString(message.stack))
                    return "stack: string expected";
            return null;
        };

        /**
         * Creates a CompilationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompilationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompilationError} CompilationError
         */
        CompilationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompilationError)
                return object;
            let message = new $root.dataform.CompilationError();
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.actionName != null)
                message.actionName = String(object.actionName);
            if (object.actionTarget != null) {
                if (typeof object.actionTarget !== "object")
                    throw TypeError(".dataform.CompilationError.actionTarget: object expected");
                message.actionTarget = $root.dataform.Target.fromObject(object.actionTarget);
            }
            if (object.message != null)
                message.message = String(object.message);
            if (object.stack != null)
                message.stack = String(object.stack);
            return message;
        };

        /**
         * Creates a plain object from a CompilationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompilationError
         * @static
         * @param {dataform.CompilationError} message CompilationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompilationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.fileName = "";
                object.message = "";
                object.stack = "";
                object.actionName = "";
                object.actionTarget = null;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.stack != null && message.hasOwnProperty("stack"))
                object.stack = message.stack;
            if (message.actionName != null && message.hasOwnProperty("actionName"))
                object.actionName = message.actionName;
            if (message.actionTarget != null && message.hasOwnProperty("actionTarget"))
                object.actionTarget = $root.dataform.Target.toObject(message.actionTarget, options);
            return object;
        };

        /**
         * Converts this CompilationError to JSON.
         * @function toJSON
         * @memberof dataform.CompilationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompilationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompilationError
         * @function getTypeUrl
         * @memberof dataform.CompilationError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompilationError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompilationError";
        };

        return CompilationError;
    })();

    dataform.ActionDescriptor = (function() {

        /**
         * Properties of an ActionDescriptor.
         * @memberof dataform
         * @interface IActionDescriptor
         * @property {string|null} [description] ActionDescriptor description
         * @property {Array.<dataform.IColumnDescriptor>|null} [columns] ActionDescriptor columns
         * @property {Object.<string,string>|null} [bigqueryLabels] ActionDescriptor bigqueryLabels
         */

        /**
         * Constructs a new ActionDescriptor.
         * @memberof dataform
         * @classdesc Represents an ActionDescriptor.
         * @implements IActionDescriptor
         * @constructor
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         */
        function ActionDescriptor(properties) {
            this.columns = [];
            this.bigqueryLabels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionDescriptor description.
         * @member {string} description
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.description = "";

        /**
         * ActionDescriptor columns.
         * @member {Array.<dataform.IColumnDescriptor>} columns
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.columns = $util.emptyArray;

        /**
         * ActionDescriptor bigqueryLabels.
         * @member {Object.<string,string>} bigqueryLabels
         * @memberof dataform.ActionDescriptor
         * @instance
         */
        ActionDescriptor.prototype.bigqueryLabels = $util.emptyObject;

        /**
         * Creates a new ActionDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor=} [properties] Properties to set
         * @returns {dataform.ActionDescriptor} ActionDescriptor instance
         */
        ActionDescriptor.create = function create(properties) {
            return new ActionDescriptor(properties);
        };

        /**
         * Encodes the specified ActionDescriptor message. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.columns != null && message.columns.length)
                for (let i = 0; i < message.columns.length; ++i)
                    $root.dataform.ColumnDescriptor.encode(message.columns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.bigqueryLabels != null && Object.hasOwnProperty.call(message, "bigqueryLabels"))
                for (let keys = Object.keys(message.bigqueryLabels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.bigqueryLabels[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionDescriptor message, length delimited. Does not implicitly {@link dataform.ActionDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.IActionDescriptor} message ActionDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionDescriptor(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.description = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.columns && message.columns.length))
                            message.columns = [];
                        message.columns.push($root.dataform.ColumnDescriptor.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (message.bigqueryLabels === $util.emptyObject)
                            message.bigqueryLabels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.bigqueryLabels[key] = value;
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionDescriptor message.
         * @function verify
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.columns != null && message.hasOwnProperty("columns")) {
                if (!Array.isArray(message.columns))
                    return "columns: array expected";
                for (let i = 0; i < message.columns.length; ++i) {
                    let error = $root.dataform.ColumnDescriptor.verify(message.columns[i]);
                    if (error)
                        return "columns." + error;
                }
            }
            if (message.bigqueryLabels != null && message.hasOwnProperty("bigqueryLabels")) {
                if (!$util.isObject(message.bigqueryLabels))
                    return "bigqueryLabels: object expected";
                let key = Object.keys(message.bigqueryLabels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.bigqueryLabels[key[i]]))
                        return "bigqueryLabels: string{k:string} expected";
            }
            return null;
        };

        /**
         * Creates an ActionDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionDescriptor} ActionDescriptor
         */
        ActionDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionDescriptor)
                return object;
            let message = new $root.dataform.ActionDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.columns) {
                if (!Array.isArray(object.columns))
                    throw TypeError(".dataform.ActionDescriptor.columns: array expected");
                message.columns = [];
                for (let i = 0; i < object.columns.length; ++i) {
                    if (typeof object.columns[i] !== "object")
                        throw TypeError(".dataform.ActionDescriptor.columns: object expected");
                    message.columns[i] = $root.dataform.ColumnDescriptor.fromObject(object.columns[i]);
                }
            }
            if (object.bigqueryLabels) {
                if (typeof object.bigqueryLabels !== "object")
                    throw TypeError(".dataform.ActionDescriptor.bigqueryLabels: object expected");
                message.bigqueryLabels = {};
                for (let keys = Object.keys(object.bigqueryLabels), i = 0; i < keys.length; ++i)
                    message.bigqueryLabels[keys[i]] = String(object.bigqueryLabels[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {dataform.ActionDescriptor} message ActionDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.columns = [];
            if (options.objects || options.defaults)
                object.bigqueryLabels = {};
            if (options.defaults)
                object.description = "";
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.columns && message.columns.length) {
                object.columns = [];
                for (let j = 0; j < message.columns.length; ++j)
                    object.columns[j] = $root.dataform.ColumnDescriptor.toObject(message.columns[j], options);
            }
            let keys2;
            if (message.bigqueryLabels && (keys2 = Object.keys(message.bigqueryLabels)).length) {
                object.bigqueryLabels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.bigqueryLabels[keys2[j]] = message.bigqueryLabels[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this ActionDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ActionDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionDescriptor
         * @function getTypeUrl
         * @memberof dataform.ActionDescriptor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionDescriptor";
        };

        return ActionDescriptor;
    })();

    dataform.ColumnDescriptor = (function() {

        /**
         * Properties of a ColumnDescriptor.
         * @memberof dataform
         * @interface IColumnDescriptor
         * @property {string|null} [description] ColumnDescriptor description
         * @property {Array.<string>|null} [path] ColumnDescriptor path
         * @property {string|null} [displayName] ColumnDescriptor displayName
         * @property {dataform.ColumnDescriptor.DimensionType|null} [dimensionType] ColumnDescriptor dimensionType
         * @property {dataform.ColumnDescriptor.Aggregation|null} [aggregation] ColumnDescriptor aggregation
         * @property {string|null} [expression] ColumnDescriptor expression
         * @property {Array.<string>|null} [tags] ColumnDescriptor tags
         * @property {Array.<string>|null} [bigqueryPolicyTags] ColumnDescriptor bigqueryPolicyTags
         */

        /**
         * Constructs a new ColumnDescriptor.
         * @memberof dataform
         * @classdesc Represents a ColumnDescriptor.
         * @implements IColumnDescriptor
         * @constructor
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         */
        function ColumnDescriptor(properties) {
            this.path = [];
            this.tags = [];
            this.bigqueryPolicyTags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ColumnDescriptor description.
         * @member {string} description
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.description = "";

        /**
         * ColumnDescriptor path.
         * @member {Array.<string>} path
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.path = $util.emptyArray;

        /**
         * ColumnDescriptor displayName.
         * @member {string} displayName
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.displayName = "";

        /**
         * ColumnDescriptor dimensionType.
         * @member {dataform.ColumnDescriptor.DimensionType} dimensionType
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.dimensionType = 0;

        /**
         * ColumnDescriptor aggregation.
         * @member {dataform.ColumnDescriptor.Aggregation} aggregation
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.aggregation = 0;

        /**
         * ColumnDescriptor expression.
         * @member {string} expression
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.expression = "";

        /**
         * ColumnDescriptor tags.
         * @member {Array.<string>} tags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.tags = $util.emptyArray;

        /**
         * ColumnDescriptor bigqueryPolicyTags.
         * @member {Array.<string>} bigqueryPolicyTags
         * @memberof dataform.ColumnDescriptor
         * @instance
         */
        ColumnDescriptor.prototype.bigqueryPolicyTags = $util.emptyArray;

        /**
         * Creates a new ColumnDescriptor instance using the specified properties.
         * @function create
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor=} [properties] Properties to set
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor instance
         */
        ColumnDescriptor.create = function create(properties) {
            return new ColumnDescriptor(properties);
        };

        /**
         * Encodes the specified ColumnDescriptor message. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.path != null && message.path.length)
                for (let i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path[i]);
            if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.displayName);
            if (message.dimensionType != null && Object.hasOwnProperty.call(message, "dimensionType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.dimensionType);
            if (message.aggregation != null && Object.hasOwnProperty.call(message, "aggregation"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.aggregation);
            if (message.expression != null && Object.hasOwnProperty.call(message, "expression"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.expression);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.tags[i]);
            if (message.bigqueryPolicyTags != null && message.bigqueryPolicyTags.length)
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.bigqueryPolicyTags[i]);
            return writer;
        };

        /**
         * Encodes the specified ColumnDescriptor message, length delimited. Does not implicitly {@link dataform.ColumnDescriptor.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.IColumnDescriptor} message ColumnDescriptor message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ColumnDescriptor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ColumnDescriptor();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.description = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push(reader.string());
                        break;
                    }
                case 3: {
                        message.displayName = reader.string();
                        break;
                    }
                case 4: {
                        message.dimensionType = reader.int32();
                        break;
                    }
                case 5: {
                        message.aggregation = reader.int32();
                        break;
                    }
                case 6: {
                        message.expression = reader.string();
                        break;
                    }
                case 7: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 8: {
                        if (!(message.bigqueryPolicyTags && message.bigqueryPolicyTags.length))
                            message.bigqueryPolicyTags = [];
                        message.bigqueryPolicyTags.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ColumnDescriptor message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ColumnDescriptor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ColumnDescriptor message.
         * @function verify
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ColumnDescriptor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (let i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                if (!$util.isString(message.displayName))
                    return "displayName: string expected";
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                switch (message.dimensionType) {
                default:
                    return "dimensionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                switch (message.aggregation) {
                default:
                    return "aggregation: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.expression != null && message.hasOwnProperty("expression"))
                if (!$util.isString(message.expression))
                    return "expression: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.bigqueryPolicyTags != null && message.hasOwnProperty("bigqueryPolicyTags")) {
                if (!Array.isArray(message.bigqueryPolicyTags))
                    return "bigqueryPolicyTags: array expected";
                for (let i = 0; i < message.bigqueryPolicyTags.length; ++i)
                    if (!$util.isString(message.bigqueryPolicyTags[i]))
                        return "bigqueryPolicyTags: string[] expected";
            }
            return null;
        };

        /**
         * Creates a ColumnDescriptor message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ColumnDescriptor} ColumnDescriptor
         */
        ColumnDescriptor.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ColumnDescriptor)
                return object;
            let message = new $root.dataform.ColumnDescriptor();
            if (object.description != null)
                message.description = String(object.description);
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".dataform.ColumnDescriptor.path: array expected");
                message.path = [];
                for (let i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.displayName != null)
                message.displayName = String(object.displayName);
            switch (object.dimensionType) {
            case "UNKNOWN_DIMENSION":
            case 0:
                message.dimensionType = 0;
                break;
            case "CATEGORY":
            case 1:
                message.dimensionType = 1;
                break;
            case "TIMESTAMP":
            case 2:
                message.dimensionType = 2;
                break;
            case "NUMBER":
            case 3:
                message.dimensionType = 3;
                break;
            }
            switch (object.aggregation) {
            case "UNKNOWN_AGGREGATION":
            case 0:
                message.aggregation = 0;
                break;
            case "SUM":
            case 1:
                message.aggregation = 1;
                break;
            case "DISTINCT":
            case 2:
                message.aggregation = 2;
                break;
            case "DERIVED":
            case 3:
                message.aggregation = 3;
                break;
            }
            if (object.expression != null)
                message.expression = String(object.expression);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.ColumnDescriptor.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.bigqueryPolicyTags) {
                if (!Array.isArray(object.bigqueryPolicyTags))
                    throw TypeError(".dataform.ColumnDescriptor.bigqueryPolicyTags: array expected");
                message.bigqueryPolicyTags = [];
                for (let i = 0; i < object.bigqueryPolicyTags.length; ++i)
                    message.bigqueryPolicyTags[i] = String(object.bigqueryPolicyTags[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a ColumnDescriptor message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {dataform.ColumnDescriptor} message ColumnDescriptor
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ColumnDescriptor.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.path = [];
                object.tags = [];
                object.bigqueryPolicyTags = [];
            }
            if (options.defaults) {
                object.description = "";
                object.displayName = "";
                object.dimensionType = options.enums === String ? "UNKNOWN_DIMENSION" : 0;
                object.aggregation = options.enums === String ? "UNKNOWN_AGGREGATION" : 0;
                object.expression = "";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.path && message.path.length) {
                object.path = [];
                for (let j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.displayName != null && message.hasOwnProperty("displayName"))
                object.displayName = message.displayName;
            if (message.dimensionType != null && message.hasOwnProperty("dimensionType"))
                object.dimensionType = options.enums === String ? $root.dataform.ColumnDescriptor.DimensionType[message.dimensionType] : message.dimensionType;
            if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                object.aggregation = options.enums === String ? $root.dataform.ColumnDescriptor.Aggregation[message.aggregation] : message.aggregation;
            if (message.expression != null && message.hasOwnProperty("expression"))
                object.expression = message.expression;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.bigqueryPolicyTags && message.bigqueryPolicyTags.length) {
                object.bigqueryPolicyTags = [];
                for (let j = 0; j < message.bigqueryPolicyTags.length; ++j)
                    object.bigqueryPolicyTags[j] = message.bigqueryPolicyTags[j];
            }
            return object;
        };

        /**
         * Converts this ColumnDescriptor to JSON.
         * @function toJSON
         * @memberof dataform.ColumnDescriptor
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ColumnDescriptor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ColumnDescriptor
         * @function getTypeUrl
         * @memberof dataform.ColumnDescriptor
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ColumnDescriptor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ColumnDescriptor";
        };

        /**
         * DimensionType enum.
         * @name dataform.ColumnDescriptor.DimensionType
         * @enum {number}
         * @property {number} UNKNOWN_DIMENSION=0 UNKNOWN_DIMENSION value
         * @property {number} CATEGORY=1 CATEGORY value
         * @property {number} TIMESTAMP=2 TIMESTAMP value
         * @property {number} NUMBER=3 NUMBER value
         */
        ColumnDescriptor.DimensionType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_DIMENSION"] = 0;
            values[valuesById[1] = "CATEGORY"] = 1;
            values[valuesById[2] = "TIMESTAMP"] = 2;
            values[valuesById[3] = "NUMBER"] = 3;
            return values;
        })();

        /**
         * Aggregation enum.
         * @name dataform.ColumnDescriptor.Aggregation
         * @enum {number}
         * @property {number} UNKNOWN_AGGREGATION=0 UNKNOWN_AGGREGATION value
         * @property {number} SUM=1 SUM value
         * @property {number} DISTINCT=2 DISTINCT value
         * @property {number} DERIVED=3 DERIVED value
         */
        ColumnDescriptor.Aggregation = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_AGGREGATION"] = 0;
            values[valuesById[1] = "SUM"] = 1;
            values[valuesById[2] = "DISTINCT"] = 2;
            values[valuesById[3] = "DERIVED"] = 3;
            return values;
        })();

        return ColumnDescriptor;
    })();

    dataform.Table = (function() {

        /**
         * Properties of a Table.
         * @memberof dataform
         * @interface ITable
         * @property {dataform.ITarget|null} [target] Table target
         * @property {dataform.ITarget|null} [canonicalTarget] Table canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Table dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Table hermeticity
         * @property {boolean|null} [disabled] Table disabled
         * @property {string|null} [type] Table type
         * @property {string|null} [query] Table query
         * @property {boolean|null} ["protected"] Table protected
         * @property {boolean|null} [materialized] Table materialized
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Table actionDescriptor
         * @property {Array.<string>|null} [tags] Table tags
         * @property {string|null} [where] Table where
         * @property {string|null} [incrementalQuery] Table incrementalQuery
         * @property {Array.<string>|null} [uniqueKey] Table uniqueKey
         * @property {Array.<string>|null} [preOps] Table preOps
         * @property {Array.<string>|null} [postOps] Table postOps
         * @property {Array.<string>|null} [incrementalPreOps] Table incrementalPreOps
         * @property {Array.<string>|null} [incrementalPostOps] Table incrementalPostOps
         * @property {dataform.IRedshiftOptions|null} [redshift] Table redshift
         * @property {dataform.IBigQueryOptions|null} [bigquery] Table bigquery
         * @property {dataform.ISnowflakeOptions|null} [snowflake] Table snowflake
         * @property {dataform.ISQLDataWarehouseOptions|null} [sqlDataWarehouse] Table sqlDataWarehouse
         * @property {dataform.IPrestoOptions|null} [presto] Table presto
         * @property {string|null} [fileName] Table fileName
         */

        /**
         * Constructs a new Table.
         * @memberof dataform
         * @classdesc Represents a Table.
         * @implements ITable
         * @constructor
         * @param {dataform.ITable=} [properties] Properties to set
         */
        function Table(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            this.uniqueKey = [];
            this.preOps = [];
            this.postOps = [];
            this.incrementalPreOps = [];
            this.incrementalPostOps = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Table target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.target = null;

        /**
         * Table canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.canonicalTarget = null;

        /**
         * Table dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Table hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.hermeticity = 0;

        /**
         * Table disabled.
         * @member {boolean} disabled
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.disabled = false;

        /**
         * Table type.
         * @member {string} type
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.type = "";

        /**
         * Table query.
         * @member {string} query
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.query = "";

        /**
         * Table protected.
         * @member {boolean} protected
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype["protected"] = false;

        /**
         * Table materialized.
         * @member {boolean} materialized
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.materialized = false;

        /**
         * Table actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.actionDescriptor = null;

        /**
         * Table tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.tags = $util.emptyArray;

        /**
         * Table where.
         * @member {string} where
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.where = "";

        /**
         * Table incrementalQuery.
         * @member {string} incrementalQuery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalQuery = "";

        /**
         * Table uniqueKey.
         * @member {Array.<string>} uniqueKey
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.uniqueKey = $util.emptyArray;

        /**
         * Table preOps.
         * @member {Array.<string>} preOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.preOps = $util.emptyArray;

        /**
         * Table postOps.
         * @member {Array.<string>} postOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.postOps = $util.emptyArray;

        /**
         * Table incrementalPreOps.
         * @member {Array.<string>} incrementalPreOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPreOps = $util.emptyArray;

        /**
         * Table incrementalPostOps.
         * @member {Array.<string>} incrementalPostOps
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.incrementalPostOps = $util.emptyArray;

        /**
         * Table redshift.
         * @member {dataform.IRedshiftOptions|null|undefined} redshift
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.redshift = null;

        /**
         * Table bigquery.
         * @member {dataform.IBigQueryOptions|null|undefined} bigquery
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.bigquery = null;

        /**
         * Table snowflake.
         * @member {dataform.ISnowflakeOptions|null|undefined} snowflake
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.snowflake = null;

        /**
         * Table sqlDataWarehouse.
         * @member {dataform.ISQLDataWarehouseOptions|null|undefined} sqlDataWarehouse
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.sqlDataWarehouse = null;

        /**
         * Table presto.
         * @member {dataform.IPrestoOptions|null|undefined} presto
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.presto = null;

        /**
         * Table fileName.
         * @member {string} fileName
         * @memberof dataform.Table
         * @instance
         */
        Table.prototype.fileName = "";

        /**
         * Creates a new Table instance using the specified properties.
         * @function create
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable=} [properties] Properties to set
         * @returns {dataform.Table} Table instance
         */
        Table.create = function create(properties) {
            return new Table(properties);
        };

        /**
         * Encodes the specified Table message. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encode
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.type);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.query);
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disabled);
            if (message.where != null && Object.hasOwnProperty.call(message, "where"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.where);
            if (message["protected"] != null && Object.hasOwnProperty.call(message, "protected"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message["protected"]);
            if (message.preOps != null && message.preOps.length)
                for (let i = 0; i < message.preOps.length; ++i)
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.preOps[i]);
            if (message.postOps != null && message.postOps.length)
                for (let i = 0; i < message.postOps.length; ++i)
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.postOps[i]);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.fileName);
            if (message.redshift != null && Object.hasOwnProperty.call(message, "redshift"))
                $root.dataform.RedshiftOptions.encode(message.redshift, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.BigQueryOptions.encode(message.bigquery, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 23, wireType 2 =*/186).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.sqlDataWarehouse != null && Object.hasOwnProperty.call(message, "sqlDataWarehouse"))
                $root.dataform.SQLDataWarehouseOptions.encode(message.sqlDataWarehouse, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.incrementalQuery != null && Object.hasOwnProperty.call(message, "incrementalQuery"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.incrementalQuery);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.incrementalPreOps != null && message.incrementalPreOps.length)
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    writer.uint32(/* id 28, wireType 2 =*/226).string(message.incrementalPreOps[i]);
            if (message.incrementalPostOps != null && message.incrementalPostOps.length)
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    writer.uint32(/* id 29, wireType 2 =*/234).string(message.incrementalPostOps[i]);
            if (message.uniqueKey != null && message.uniqueKey.length)
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    writer.uint32(/* id 30, wireType 2 =*/242).string(message.uniqueKey[i]);
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 31, wireType 0 =*/248).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.snowflake != null && Object.hasOwnProperty.call(message, "snowflake"))
                $root.dataform.SnowflakeOptions.encode(message.snowflake, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.presto != null && Object.hasOwnProperty.call(message, "presto"))
                $root.dataform.PrestoOptions.encode(message.presto, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.materialized != null && Object.hasOwnProperty.call(message, "materialized"))
                writer.uint32(/* id 35, wireType 0 =*/280).bool(message.materialized);
            return writer;
        };

        /**
         * Encodes the specified Table message, length delimited. Does not implicitly {@link dataform.Table.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {dataform.ITable} message Table message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Table.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Table message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Table();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 31: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 6: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 3: {
                        message.type = reader.string();
                        break;
                    }
                case 5: {
                        message.query = reader.string();
                        break;
                    }
                case 9: {
                        message["protected"] = reader.bool();
                        break;
                    }
                case 35: {
                        message.materialized = reader.bool();
                        break;
                    }
                case 24: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 8: {
                        message.where = reader.string();
                        break;
                    }
                case 26: {
                        message.incrementalQuery = reader.string();
                        break;
                    }
                case 30: {
                        if (!(message.uniqueKey && message.uniqueKey.length))
                            message.uniqueKey = [];
                        message.uniqueKey.push(reader.string());
                        break;
                    }
                case 13: {
                        if (!(message.preOps && message.preOps.length))
                            message.preOps = [];
                        message.preOps.push(reader.string());
                        break;
                    }
                case 14: {
                        if (!(message.postOps && message.postOps.length))
                            message.postOps = [];
                        message.postOps.push(reader.string());
                        break;
                    }
                case 28: {
                        if (!(message.incrementalPreOps && message.incrementalPreOps.length))
                            message.incrementalPreOps = [];
                        message.incrementalPreOps.push(reader.string());
                        break;
                    }
                case 29: {
                        if (!(message.incrementalPostOps && message.incrementalPostOps.length))
                            message.incrementalPostOps = [];
                        message.incrementalPostOps.push(reader.string());
                        break;
                    }
                case 21: {
                        message.redshift = $root.dataform.RedshiftOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.bigquery = $root.dataform.BigQueryOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 33: {
                        message.snowflake = $root.dataform.SnowflakeOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 34: {
                        message.presto = $root.dataform.PrestoOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Table message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Table
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Table} Table
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Table.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Table message.
         * @function verify
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Table.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                if (typeof message["protected"] !== "boolean")
                    return "protected: boolean expected";
            if (message.materialized != null && message.hasOwnProperty("materialized"))
                if (typeof message.materialized !== "boolean")
                    return "materialized: boolean expected";
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.where != null && message.hasOwnProperty("where"))
                if (!$util.isString(message.where))
                    return "where: string expected";
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                if (!$util.isString(message.incrementalQuery))
                    return "incrementalQuery: string expected";
            if (message.uniqueKey != null && message.hasOwnProperty("uniqueKey")) {
                if (!Array.isArray(message.uniqueKey))
                    return "uniqueKey: array expected";
                for (let i = 0; i < message.uniqueKey.length; ++i)
                    if (!$util.isString(message.uniqueKey[i]))
                        return "uniqueKey: string[] expected";
            }
            if (message.preOps != null && message.hasOwnProperty("preOps")) {
                if (!Array.isArray(message.preOps))
                    return "preOps: array expected";
                for (let i = 0; i < message.preOps.length; ++i)
                    if (!$util.isString(message.preOps[i]))
                        return "preOps: string[] expected";
            }
            if (message.postOps != null && message.hasOwnProperty("postOps")) {
                if (!Array.isArray(message.postOps))
                    return "postOps: array expected";
                for (let i = 0; i < message.postOps.length; ++i)
                    if (!$util.isString(message.postOps[i]))
                        return "postOps: string[] expected";
            }
            if (message.incrementalPreOps != null && message.hasOwnProperty("incrementalPreOps")) {
                if (!Array.isArray(message.incrementalPreOps))
                    return "incrementalPreOps: array expected";
                for (let i = 0; i < message.incrementalPreOps.length; ++i)
                    if (!$util.isString(message.incrementalPreOps[i]))
                        return "incrementalPreOps: string[] expected";
            }
            if (message.incrementalPostOps != null && message.hasOwnProperty("incrementalPostOps")) {
                if (!Array.isArray(message.incrementalPostOps))
                    return "incrementalPostOps: array expected";
                for (let i = 0; i < message.incrementalPostOps.length; ++i)
                    if (!$util.isString(message.incrementalPostOps[i]))
                        return "incrementalPostOps: string[] expected";
            }
            if (message.redshift != null && message.hasOwnProperty("redshift")) {
                let error = $root.dataform.RedshiftOptions.verify(message.redshift);
                if (error)
                    return "redshift." + error;
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.BigQueryOptions.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            if (message.snowflake != null && message.hasOwnProperty("snowflake")) {
                let error = $root.dataform.SnowflakeOptions.verify(message.snowflake);
                if (error)
                    return "snowflake." + error;
            }
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse")) {
                let error = $root.dataform.SQLDataWarehouseOptions.verify(message.sqlDataWarehouse);
                if (error)
                    return "sqlDataWarehouse." + error;
            }
            if (message.presto != null && message.hasOwnProperty("presto")) {
                let error = $root.dataform.PrestoOptions.verify(message.presto);
                if (error)
                    return "presto." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Table message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Table
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Table} Table
         */
        Table.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Table)
                return object;
            let message = new $root.dataform.Table();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Table.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Table.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Table.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Table.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.type != null)
                message.type = String(object.type);
            if (object.query != null)
                message.query = String(object.query);
            if (object["protected"] != null)
                message["protected"] = Boolean(object["protected"]);
            if (object.materialized != null)
                message.materialized = Boolean(object.materialized);
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Table.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Table.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.where != null)
                message.where = String(object.where);
            if (object.incrementalQuery != null)
                message.incrementalQuery = String(object.incrementalQuery);
            if (object.uniqueKey) {
                if (!Array.isArray(object.uniqueKey))
                    throw TypeError(".dataform.Table.uniqueKey: array expected");
                message.uniqueKey = [];
                for (let i = 0; i < object.uniqueKey.length; ++i)
                    message.uniqueKey[i] = String(object.uniqueKey[i]);
            }
            if (object.preOps) {
                if (!Array.isArray(object.preOps))
                    throw TypeError(".dataform.Table.preOps: array expected");
                message.preOps = [];
                for (let i = 0; i < object.preOps.length; ++i)
                    message.preOps[i] = String(object.preOps[i]);
            }
            if (object.postOps) {
                if (!Array.isArray(object.postOps))
                    throw TypeError(".dataform.Table.postOps: array expected");
                message.postOps = [];
                for (let i = 0; i < object.postOps.length; ++i)
                    message.postOps[i] = String(object.postOps[i]);
            }
            if (object.incrementalPreOps) {
                if (!Array.isArray(object.incrementalPreOps))
                    throw TypeError(".dataform.Table.incrementalPreOps: array expected");
                message.incrementalPreOps = [];
                for (let i = 0; i < object.incrementalPreOps.length; ++i)
                    message.incrementalPreOps[i] = String(object.incrementalPreOps[i]);
            }
            if (object.incrementalPostOps) {
                if (!Array.isArray(object.incrementalPostOps))
                    throw TypeError(".dataform.Table.incrementalPostOps: array expected");
                message.incrementalPostOps = [];
                for (let i = 0; i < object.incrementalPostOps.length; ++i)
                    message.incrementalPostOps[i] = String(object.incrementalPostOps[i]);
            }
            if (object.redshift != null) {
                if (typeof object.redshift !== "object")
                    throw TypeError(".dataform.Table.redshift: object expected");
                message.redshift = $root.dataform.RedshiftOptions.fromObject(object.redshift);
            }
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.Table.bigquery: object expected");
                message.bigquery = $root.dataform.BigQueryOptions.fromObject(object.bigquery);
            }
            if (object.snowflake != null) {
                if (typeof object.snowflake !== "object")
                    throw TypeError(".dataform.Table.snowflake: object expected");
                message.snowflake = $root.dataform.SnowflakeOptions.fromObject(object.snowflake);
            }
            if (object.sqlDataWarehouse != null) {
                if (typeof object.sqlDataWarehouse !== "object")
                    throw TypeError(".dataform.Table.sqlDataWarehouse: object expected");
                message.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.fromObject(object.sqlDataWarehouse);
            }
            if (object.presto != null) {
                if (typeof object.presto !== "object")
                    throw TypeError(".dataform.Table.presto: object expected");
                message.presto = $root.dataform.PrestoOptions.fromObject(object.presto);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Table message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Table
         * @static
         * @param {dataform.Table} message Table
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Table.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.preOps = [];
                object.postOps = [];
                object.tags = [];
                object.dependencyTargets = [];
                object.incrementalPreOps = [];
                object.incrementalPostOps = [];
                object.uniqueKey = [];
            }
            if (options.defaults) {
                object.type = "";
                object.target = null;
                object.query = "";
                object.disabled = false;
                object.where = "";
                object["protected"] = false;
                object.fileName = "";
                object.redshift = null;
                object.bigquery = null;
                object.actionDescriptor = null;
                object.sqlDataWarehouse = null;
                object.incrementalQuery = "";
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.snowflake = null;
                object.presto = null;
                object.materialized = false;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.where != null && message.hasOwnProperty("where"))
                object.where = message.where;
            if (message["protected"] != null && message.hasOwnProperty("protected"))
                object["protected"] = message["protected"];
            if (message.preOps && message.preOps.length) {
                object.preOps = [];
                for (let j = 0; j < message.preOps.length; ++j)
                    object.preOps[j] = message.preOps[j];
            }
            if (message.postOps && message.postOps.length) {
                object.postOps = [];
                for (let j = 0; j < message.postOps.length; ++j)
                    object.postOps[j] = message.postOps[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.redshift != null && message.hasOwnProperty("redshift"))
                object.redshift = $root.dataform.RedshiftOptions.toObject(message.redshift, options);
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.BigQueryOptions.toObject(message.bigquery, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.sqlDataWarehouse != null && message.hasOwnProperty("sqlDataWarehouse"))
                object.sqlDataWarehouse = $root.dataform.SQLDataWarehouseOptions.toObject(message.sqlDataWarehouse, options);
            if (message.incrementalQuery != null && message.hasOwnProperty("incrementalQuery"))
                object.incrementalQuery = message.incrementalQuery;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.incrementalPreOps && message.incrementalPreOps.length) {
                object.incrementalPreOps = [];
                for (let j = 0; j < message.incrementalPreOps.length; ++j)
                    object.incrementalPreOps[j] = message.incrementalPreOps[j];
            }
            if (message.incrementalPostOps && message.incrementalPostOps.length) {
                object.incrementalPostOps = [];
                for (let j = 0; j < message.incrementalPostOps.length; ++j)
                    object.incrementalPostOps[j] = message.incrementalPostOps[j];
            }
            if (message.uniqueKey && message.uniqueKey.length) {
                object.uniqueKey = [];
                for (let j = 0; j < message.uniqueKey.length; ++j)
                    object.uniqueKey[j] = message.uniqueKey[j];
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.snowflake != null && message.hasOwnProperty("snowflake"))
                object.snowflake = $root.dataform.SnowflakeOptions.toObject(message.snowflake, options);
            if (message.presto != null && message.hasOwnProperty("presto"))
                object.presto = $root.dataform.PrestoOptions.toObject(message.presto, options);
            if (message.materialized != null && message.hasOwnProperty("materialized"))
                object.materialized = message.materialized;
            return object;
        };

        /**
         * Converts this Table to JSON.
         * @function toJSON
         * @memberof dataform.Table
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Table.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Table
         * @function getTypeUrl
         * @memberof dataform.Table
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Table.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Table";
        };

        return Table;
    })();

    dataform.Operation = (function() {

        /**
         * Properties of an Operation.
         * @memberof dataform
         * @interface IOperation
         * @property {dataform.ITarget|null} [target] Operation target
         * @property {dataform.ITarget|null} [canonicalTarget] Operation canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Operation dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Operation hermeticity
         * @property {boolean|null} [disabled] Operation disabled
         * @property {Array.<string>|null} [queries] Operation queries
         * @property {boolean|null} [hasOutput] Operation hasOutput
         * @property {Array.<string>|null} [tags] Operation tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Operation actionDescriptor
         * @property {string|null} [fileName] Operation fileName
         */

        /**
         * Constructs a new Operation.
         * @memberof dataform
         * @classdesc Represents an Operation.
         * @implements IOperation
         * @constructor
         * @param {dataform.IOperation=} [properties] Properties to set
         */
        function Operation(properties) {
            this.dependencyTargets = [];
            this.queries = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Operation target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.target = null;

        /**
         * Operation canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.canonicalTarget = null;

        /**
         * Operation dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Operation hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hermeticity = 0;

        /**
         * Operation disabled.
         * @member {boolean} disabled
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.disabled = false;

        /**
         * Operation queries.
         * @member {Array.<string>} queries
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.queries = $util.emptyArray;

        /**
         * Operation hasOutput.
         * @member {boolean} hasOutput
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.hasOutput = false;

        /**
         * Operation tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.tags = $util.emptyArray;

        /**
         * Operation actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.actionDescriptor = null;

        /**
         * Operation fileName.
         * @member {string} fileName
         * @memberof dataform.Operation
         * @instance
         */
        Operation.prototype.fileName = "";

        /**
         * Creates a new Operation instance using the specified properties.
         * @function create
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation=} [properties] Properties to set
         * @returns {dataform.Operation} Operation instance
         */
        Operation.create = function create(properties) {
            return new Operation(properties);
        };

        /**
         * Encodes the specified Operation message. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encode
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.queries != null && message.queries.length)
                for (let i = 0; i < message.queries.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.queries[i]);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.hasOutput != null && Object.hasOwnProperty.call(message, "hasOutput"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.hasOutput);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            return writer;
        };

        /**
         * Encodes the specified Operation message, length delimited. Does not implicitly {@link dataform.Operation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {dataform.IOperation} message Operation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Operation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Operation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Operation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 14: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 6: {
                        if (!(message.queries && message.queries.length))
                            message.queries = [];
                        message.queries.push(reader.string());
                        break;
                    }
                case 8: {
                        message.hasOutput = reader.bool();
                        break;
                    }
                case 9: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 10: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Operation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Operation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Operation} Operation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Operation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Operation message.
         * @function verify
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Operation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.queries != null && message.hasOwnProperty("queries")) {
                if (!Array.isArray(message.queries))
                    return "queries: array expected";
                for (let i = 0; i < message.queries.length; ++i)
                    if (!$util.isString(message.queries[i]))
                        return "queries: string[] expected";
            }
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                if (typeof message.hasOutput !== "boolean")
                    return "hasOutput: boolean expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates an Operation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Operation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Operation} Operation
         */
        Operation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Operation)
                return object;
            let message = new $root.dataform.Operation();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Operation.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Operation.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Operation.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Operation.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.queries) {
                if (!Array.isArray(object.queries))
                    throw TypeError(".dataform.Operation.queries: array expected");
                message.queries = [];
                for (let i = 0; i < object.queries.length; ++i)
                    message.queries[i] = String(object.queries[i]);
            }
            if (object.hasOutput != null)
                message.hasOutput = Boolean(object.hasOutput);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Operation.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Operation.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from an Operation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Operation
         * @static
         * @param {dataform.Operation} message Operation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Operation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.queries = [];
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.target = null;
                object.fileName = "";
                object.hasOutput = false;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.queries && message.queries.length) {
                object.queries = [];
                for (let j = 0; j < message.queries.length; ++j)
                    object.queries[j] = message.queries[j];
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.hasOutput != null && message.hasOwnProperty("hasOutput"))
                object.hasOutput = message.hasOutput;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            return object;
        };

        /**
         * Converts this Operation to JSON.
         * @function toJSON
         * @memberof dataform.Operation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Operation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Operation
         * @function getTypeUrl
         * @memberof dataform.Operation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Operation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Operation";
        };

        return Operation;
    })();

    dataform.Assertion = (function() {

        /**
         * Properties of an Assertion.
         * @memberof dataform
         * @interface IAssertion
         * @property {dataform.ITarget|null} [target] Assertion target
         * @property {dataform.ITarget|null} [canonicalTarget] Assertion canonicalTarget
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] Assertion dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] Assertion hermeticity
         * @property {boolean|null} [disabled] Assertion disabled
         * @property {string|null} [query] Assertion query
         * @property {Array.<string>|null} [tags] Assertion tags
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Assertion actionDescriptor
         * @property {dataform.ITarget|null} [parentAction] Assertion parentAction
         * @property {string|null} [fileName] Assertion fileName
         */

        /**
         * Constructs a new Assertion.
         * @memberof dataform
         * @classdesc Represents an Assertion.
         * @implements IAssertion
         * @constructor
         * @param {dataform.IAssertion=} [properties] Properties to set
         */
        function Assertion(properties) {
            this.dependencyTargets = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Assertion target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.target = null;

        /**
         * Assertion canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.canonicalTarget = null;

        /**
         * Assertion dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.dependencyTargets = $util.emptyArray;

        /**
         * Assertion hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.hermeticity = 0;

        /**
         * Assertion disabled.
         * @member {boolean} disabled
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.disabled = false;

        /**
         * Assertion query.
         * @member {string} query
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.query = "";

        /**
         * Assertion tags.
         * @member {Array.<string>} tags
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.tags = $util.emptyArray;

        /**
         * Assertion actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.actionDescriptor = null;

        /**
         * Assertion parentAction.
         * @member {dataform.ITarget|null|undefined} parentAction
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.parentAction = null;

        /**
         * Assertion fileName.
         * @member {string} fileName
         * @memberof dataform.Assertion
         * @instance
         */
        Assertion.prototype.fileName = "";

        /**
         * Creates a new Assertion instance using the specified properties.
         * @function create
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion=} [properties] Properties to set
         * @returns {dataform.Assertion} Assertion instance
         */
        Assertion.create = function create(properties) {
            return new Assertion(properties);
        };

        /**
         * Encodes the specified Assertion message. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encode
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.query);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.fileName);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.tags[i]);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.hermeticity);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.disabled);
            if (message.parentAction != null && Object.hasOwnProperty.call(message, "parentAction"))
                $root.dataform.Target.encode(message.parentAction, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Assertion message, length delimited. Does not implicitly {@link dataform.Assertion.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.IAssertion} message Assertion message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Assertion.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Assertion();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 8: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 14: {
                        message.disabled = reader.bool();
                        break;
                    }
                case 3: {
                        message.query = reader.string();
                        break;
                    }
                case 9: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 10: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.parentAction = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Assertion message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Assertion
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Assertion} Assertion
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Assertion.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Assertion message.
         * @function verify
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Assertion.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.parentAction != null && message.hasOwnProperty("parentAction")) {
                let error = $root.dataform.Target.verify(message.parentAction);
                if (error)
                    return "parentAction." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates an Assertion message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Assertion
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Assertion} Assertion
         */
        Assertion.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Assertion)
                return object;
            let message = new $root.dataform.Assertion();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Assertion.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Assertion.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.Assertion.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.Assertion.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.query != null)
                message.query = String(object.query);
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.Assertion.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Assertion.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.parentAction != null) {
                if (typeof object.parentAction !== "object")
                    throw TypeError(".dataform.Assertion.parentAction: object expected");
                message.parentAction = $root.dataform.Target.fromObject(object.parentAction);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from an Assertion message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Assertion
         * @static
         * @param {dataform.Assertion} message Assertion
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Assertion.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tags = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.query = "";
                object.fileName = "";
                object.target = null;
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
                object.canonicalTarget = null;
                object.disabled = false;
                object.parentAction = null;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.parentAction != null && message.hasOwnProperty("parentAction"))
                object.parentAction = $root.dataform.Target.toObject(message.parentAction, options);
            return object;
        };

        /**
         * Converts this Assertion to JSON.
         * @function toJSON
         * @memberof dataform.Assertion
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Assertion.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Assertion
         * @function getTypeUrl
         * @memberof dataform.Assertion
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Assertion.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Assertion";
        };

        return Assertion;
    })();

    /**
     * ActionHermeticity enum.
     * @name dataform.ActionHermeticity
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HERMETIC=1 HERMETIC value
     * @property {number} NON_HERMETIC=2 NON_HERMETIC value
     */
    dataform.ActionHermeticity = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HERMETIC"] = 1;
        values[valuesById[2] = "NON_HERMETIC"] = 2;
        return values;
    })();

    dataform.Declaration = (function() {

        /**
         * Properties of a Declaration.
         * @memberof dataform
         * @interface IDeclaration
         * @property {dataform.ITarget|null} [target] Declaration target
         * @property {dataform.ITarget|null} [canonicalTarget] Declaration canonicalTarget
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] Declaration actionDescriptor
         * @property {string|null} [fileName] Declaration fileName
         */

        /**
         * Constructs a new Declaration.
         * @memberof dataform
         * @classdesc Represents a Declaration.
         * @implements IDeclaration
         * @constructor
         * @param {dataform.IDeclaration=} [properties] Properties to set
         */
        function Declaration(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Declaration target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.target = null;

        /**
         * Declaration canonicalTarget.
         * @member {dataform.ITarget|null|undefined} canonicalTarget
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.canonicalTarget = null;

        /**
         * Declaration actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.actionDescriptor = null;

        /**
         * Declaration fileName.
         * @member {string} fileName
         * @memberof dataform.Declaration
         * @instance
         */
        Declaration.prototype.fileName = "";

        /**
         * Creates a new Declaration instance using the specified properties.
         * @function create
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration=} [properties] Properties to set
         * @returns {dataform.Declaration} Declaration instance
         */
        Declaration.create = function create(properties) {
            return new Declaration(properties);
        };

        /**
         * Encodes the specified Declaration message. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encode
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            if (message.canonicalTarget != null && Object.hasOwnProperty.call(message, "canonicalTarget"))
                $root.dataform.Target.encode(message.canonicalTarget, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Declaration message, length delimited. Does not implicitly {@link dataform.Declaration.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.IDeclaration} message Declaration message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Declaration.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Declaration();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.canonicalTarget = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Declaration message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Declaration
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Declaration} Declaration
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Declaration.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Declaration message.
         * @function verify
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Declaration.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget")) {
                let error = $root.dataform.Target.verify(message.canonicalTarget);
                if (error)
                    return "canonicalTarget." + error;
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Declaration message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Declaration
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Declaration} Declaration
         */
        Declaration.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Declaration)
                return object;
            let message = new $root.dataform.Declaration();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.Declaration.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.canonicalTarget != null) {
                if (typeof object.canonicalTarget !== "object")
                    throw TypeError(".dataform.Declaration.canonicalTarget: object expected");
                message.canonicalTarget = $root.dataform.Target.fromObject(object.canonicalTarget);
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.Declaration.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Declaration message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Declaration
         * @static
         * @param {dataform.Declaration} message Declaration
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Declaration.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.target = null;
                object.actionDescriptor = null;
                object.fileName = "";
                object.canonicalTarget = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.canonicalTarget != null && message.hasOwnProperty("canonicalTarget"))
                object.canonicalTarget = $root.dataform.Target.toObject(message.canonicalTarget, options);
            return object;
        };

        /**
         * Converts this Declaration to JSON.
         * @function toJSON
         * @memberof dataform.Declaration
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Declaration.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Declaration
         * @function getTypeUrl
         * @memberof dataform.Declaration
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Declaration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Declaration";
        };

        return Declaration;
    })();

    dataform.Test = (function() {

        /**
         * Properties of a Test.
         * @memberof dataform
         * @interface ITest
         * @property {string|null} [name] Test name
         * @property {string|null} [testQuery] Test testQuery
         * @property {string|null} [expectedOutputQuery] Test expectedOutputQuery
         * @property {string|null} [fileName] Test fileName
         */

        /**
         * Constructs a new Test.
         * @memberof dataform
         * @classdesc Represents a Test.
         * @implements ITest
         * @constructor
         * @param {dataform.ITest=} [properties] Properties to set
         */
        function Test(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Test name.
         * @member {string} name
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.name = "";

        /**
         * Test testQuery.
         * @member {string} testQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.testQuery = "";

        /**
         * Test expectedOutputQuery.
         * @member {string} expectedOutputQuery
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.expectedOutputQuery = "";

        /**
         * Test fileName.
         * @member {string} fileName
         * @memberof dataform.Test
         * @instance
         */
        Test.prototype.fileName = "";

        /**
         * Creates a new Test instance using the specified properties.
         * @function create
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest=} [properties] Properties to set
         * @returns {dataform.Test} Test instance
         */
        Test.create = function create(properties) {
            return new Test(properties);
        };

        /**
         * Encodes the specified Test message. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encode
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.testQuery != null && Object.hasOwnProperty.call(message, "testQuery"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testQuery);
            if (message.expectedOutputQuery != null && Object.hasOwnProperty.call(message, "expectedOutputQuery"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.expectedOutputQuery);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
            return writer;
        };

        /**
         * Encodes the specified Test message, length delimited. Does not implicitly {@link dataform.Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {dataform.ITest} message Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Test message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Test();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.testQuery = reader.string();
                        break;
                    }
                case 3: {
                        message.expectedOutputQuery = reader.string();
                        break;
                    }
                case 4: {
                        message.fileName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Test} Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Test message.
         * @function verify
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                if (!$util.isString(message.testQuery))
                    return "testQuery: string expected";
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                if (!$util.isString(message.expectedOutputQuery))
                    return "expectedOutputQuery: string expected";
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            return null;
        };

        /**
         * Creates a Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Test} Test
         */
        Test.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Test)
                return object;
            let message = new $root.dataform.Test();
            if (object.name != null)
                message.name = String(object.name);
            if (object.testQuery != null)
                message.testQuery = String(object.testQuery);
            if (object.expectedOutputQuery != null)
                message.expectedOutputQuery = String(object.expectedOutputQuery);
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            return message;
        };

        /**
         * Creates a plain object from a Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Test
         * @static
         * @param {dataform.Test} message Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.testQuery = "";
                object.expectedOutputQuery = "";
                object.fileName = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.testQuery != null && message.hasOwnProperty("testQuery"))
                object.testQuery = message.testQuery;
            if (message.expectedOutputQuery != null && message.hasOwnProperty("expectedOutputQuery"))
                object.expectedOutputQuery = message.expectedOutputQuery;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            return object;
        };

        /**
         * Converts this Test to JSON.
         * @function toJSON
         * @memberof dataform.Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Test
         * @function getTypeUrl
         * @memberof dataform.Test
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Test.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Test";
        };

        return Test;
    })();

    dataform.CompiledGraph = (function() {

        /**
         * Properties of a CompiledGraph.
         * @memberof dataform
         * @interface ICompiledGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] CompiledGraph projectConfig
         * @property {Array.<dataform.ITable>|null} [tables] CompiledGraph tables
         * @property {Array.<dataform.IOperation>|null} [operations] CompiledGraph operations
         * @property {Array.<dataform.IAssertion>|null} [assertions] CompiledGraph assertions
         * @property {Array.<dataform.IDeclaration>|null} [declarations] CompiledGraph declarations
         * @property {Array.<dataform.ITest>|null} [tests] CompiledGraph tests
         * @property {dataform.IGraphErrors|null} [graphErrors] CompiledGraph graphErrors
         * @property {string|null} [dataformCoreVersion] CompiledGraph dataformCoreVersion
         * @property {Array.<dataform.ITarget>|null} [targets] CompiledGraph targets
         */

        /**
         * Constructs a new CompiledGraph.
         * @memberof dataform
         * @classdesc Represents a CompiledGraph.
         * @implements ICompiledGraph
         * @constructor
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         */
        function CompiledGraph(properties) {
            this.tables = [];
            this.operations = [];
            this.assertions = [];
            this.declarations = [];
            this.tests = [];
            this.targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompiledGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.projectConfig = null;

        /**
         * CompiledGraph tables.
         * @member {Array.<dataform.ITable>} tables
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tables = $util.emptyArray;

        /**
         * CompiledGraph operations.
         * @member {Array.<dataform.IOperation>} operations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.operations = $util.emptyArray;

        /**
         * CompiledGraph assertions.
         * @member {Array.<dataform.IAssertion>} assertions
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.assertions = $util.emptyArray;

        /**
         * CompiledGraph declarations.
         * @member {Array.<dataform.IDeclaration>} declarations
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.declarations = $util.emptyArray;

        /**
         * CompiledGraph tests.
         * @member {Array.<dataform.ITest>} tests
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.tests = $util.emptyArray;

        /**
         * CompiledGraph graphErrors.
         * @member {dataform.IGraphErrors|null|undefined} graphErrors
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.graphErrors = null;

        /**
         * CompiledGraph dataformCoreVersion.
         * @member {string} dataformCoreVersion
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.dataformCoreVersion = "";

        /**
         * CompiledGraph targets.
         * @member {Array.<dataform.ITarget>} targets
         * @memberof dataform.CompiledGraph
         * @instance
         */
        CompiledGraph.prototype.targets = $util.emptyArray;

        /**
         * Creates a new CompiledGraph instance using the specified properties.
         * @function create
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph=} [properties] Properties to set
         * @returns {dataform.CompiledGraph} CompiledGraph instance
         */
        CompiledGraph.create = function create(properties) {
            return new CompiledGraph(properties);
        };

        /**
         * Encodes the specified CompiledGraph message. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.Table.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.operations != null && message.operations.length)
                for (let i = 0; i < message.operations.length; ++i)
                    $root.dataform.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.assertions != null && message.assertions.length)
                for (let i = 0; i < message.assertions.length; ++i)
                    $root.dataform.Assertion.encode(message.assertions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.projectConfig != null && Object.hasOwnProperty.call(message, "projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.graphErrors != null && Object.hasOwnProperty.call(message, "graphErrors"))
                $root.dataform.GraphErrors.encode(message.graphErrors, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tests != null && message.tests.length)
                for (let i = 0; i < message.tests.length; ++i)
                    $root.dataform.Test.encode(message.tests[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.declarations != null && message.declarations.length)
                for (let i = 0; i < message.declarations.length; ++i)
                    $root.dataform.Declaration.encode(message.declarations[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.dataformCoreVersion != null && Object.hasOwnProperty.call(message, "dataformCoreVersion"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.dataformCoreVersion);
            if (message.targets != null && message.targets.length)
                for (let i = 0; i < message.targets.length; ++i)
                    $root.dataform.Target.encode(message.targets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompiledGraph message, length delimited. Does not implicitly {@link dataform.CompiledGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.ICompiledGraph} message CompiledGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompiledGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompiledGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 4: {
                        message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 1: {
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.dataform.Table.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.dataform.Operation.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.assertions && message.assertions.length))
                            message.assertions = [];
                        message.assertions.push($root.dataform.Assertion.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.declarations && message.declarations.length))
                            message.declarations = [];
                        message.declarations.push($root.dataform.Declaration.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.tests && message.tests.length))
                            message.tests = [];
                        message.tests.push($root.dataform.Test.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.graphErrors = $root.dataform.GraphErrors.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.dataformCoreVersion = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.targets && message.targets.length))
                            message.targets = [];
                        message.targets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompiledGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompiledGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompiledGraph} CompiledGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompiledGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompiledGraph message.
         * @function verify
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompiledGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.Table.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            if (message.operations != null && message.hasOwnProperty("operations")) {
                if (!Array.isArray(message.operations))
                    return "operations: array expected";
                for (let i = 0; i < message.operations.length; ++i) {
                    let error = $root.dataform.Operation.verify(message.operations[i]);
                    if (error)
                        return "operations." + error;
                }
            }
            if (message.assertions != null && message.hasOwnProperty("assertions")) {
                if (!Array.isArray(message.assertions))
                    return "assertions: array expected";
                for (let i = 0; i < message.assertions.length; ++i) {
                    let error = $root.dataform.Assertion.verify(message.assertions[i]);
                    if (error)
                        return "assertions." + error;
                }
            }
            if (message.declarations != null && message.hasOwnProperty("declarations")) {
                if (!Array.isArray(message.declarations))
                    return "declarations: array expected";
                for (let i = 0; i < message.declarations.length; ++i) {
                    let error = $root.dataform.Declaration.verify(message.declarations[i]);
                    if (error)
                        return "declarations." + error;
                }
            }
            if (message.tests != null && message.hasOwnProperty("tests")) {
                if (!Array.isArray(message.tests))
                    return "tests: array expected";
                for (let i = 0; i < message.tests.length; ++i) {
                    let error = $root.dataform.Test.verify(message.tests[i]);
                    if (error)
                        return "tests." + error;
                }
            }
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors")) {
                let error = $root.dataform.GraphErrors.verify(message.graphErrors);
                if (error)
                    return "graphErrors." + error;
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                if (!$util.isString(message.dataformCoreVersion))
                    return "dataformCoreVersion: string expected";
            if (message.targets != null && message.hasOwnProperty("targets")) {
                if (!Array.isArray(message.targets))
                    return "targets: array expected";
                for (let i = 0; i < message.targets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.targets[i]);
                    if (error)
                        return "targets." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CompiledGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompiledGraph} CompiledGraph
         */
        CompiledGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompiledGraph)
                return object;
            let message = new $root.dataform.CompiledGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.CompiledGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.CompiledGraph.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tables: object expected");
                    message.tables[i] = $root.dataform.Table.fromObject(object.tables[i]);
                }
            }
            if (object.operations) {
                if (!Array.isArray(object.operations))
                    throw TypeError(".dataform.CompiledGraph.operations: array expected");
                message.operations = [];
                for (let i = 0; i < object.operations.length; ++i) {
                    if (typeof object.operations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.operations: object expected");
                    message.operations[i] = $root.dataform.Operation.fromObject(object.operations[i]);
                }
            }
            if (object.assertions) {
                if (!Array.isArray(object.assertions))
                    throw TypeError(".dataform.CompiledGraph.assertions: array expected");
                message.assertions = [];
                for (let i = 0; i < object.assertions.length; ++i) {
                    if (typeof object.assertions[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.assertions: object expected");
                    message.assertions[i] = $root.dataform.Assertion.fromObject(object.assertions[i]);
                }
            }
            if (object.declarations) {
                if (!Array.isArray(object.declarations))
                    throw TypeError(".dataform.CompiledGraph.declarations: array expected");
                message.declarations = [];
                for (let i = 0; i < object.declarations.length; ++i) {
                    if (typeof object.declarations[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.declarations: object expected");
                    message.declarations[i] = $root.dataform.Declaration.fromObject(object.declarations[i]);
                }
            }
            if (object.tests) {
                if (!Array.isArray(object.tests))
                    throw TypeError(".dataform.CompiledGraph.tests: array expected");
                message.tests = [];
                for (let i = 0; i < object.tests.length; ++i) {
                    if (typeof object.tests[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.tests: object expected");
                    message.tests[i] = $root.dataform.Test.fromObject(object.tests[i]);
                }
            }
            if (object.graphErrors != null) {
                if (typeof object.graphErrors !== "object")
                    throw TypeError(".dataform.CompiledGraph.graphErrors: object expected");
                message.graphErrors = $root.dataform.GraphErrors.fromObject(object.graphErrors);
            }
            if (object.dataformCoreVersion != null)
                message.dataformCoreVersion = String(object.dataformCoreVersion);
            if (object.targets) {
                if (!Array.isArray(object.targets))
                    throw TypeError(".dataform.CompiledGraph.targets: array expected");
                message.targets = [];
                for (let i = 0; i < object.targets.length; ++i) {
                    if (typeof object.targets[i] !== "object")
                        throw TypeError(".dataform.CompiledGraph.targets: object expected");
                    message.targets[i] = $root.dataform.Target.fromObject(object.targets[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CompiledGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompiledGraph
         * @static
         * @param {dataform.CompiledGraph} message CompiledGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompiledGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tables = [];
                object.operations = [];
                object.assertions = [];
                object.tests = [];
                object.declarations = [];
                object.targets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.graphErrors = null;
                object.dataformCoreVersion = "";
            }
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.Table.toObject(message.tables[j], options);
            }
            if (message.operations && message.operations.length) {
                object.operations = [];
                for (let j = 0; j < message.operations.length; ++j)
                    object.operations[j] = $root.dataform.Operation.toObject(message.operations[j], options);
            }
            if (message.assertions && message.assertions.length) {
                object.assertions = [];
                for (let j = 0; j < message.assertions.length; ++j)
                    object.assertions[j] = $root.dataform.Assertion.toObject(message.assertions[j], options);
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.graphErrors != null && message.hasOwnProperty("graphErrors"))
                object.graphErrors = $root.dataform.GraphErrors.toObject(message.graphErrors, options);
            if (message.tests && message.tests.length) {
                object.tests = [];
                for (let j = 0; j < message.tests.length; ++j)
                    object.tests[j] = $root.dataform.Test.toObject(message.tests[j], options);
            }
            if (message.declarations && message.declarations.length) {
                object.declarations = [];
                for (let j = 0; j < message.declarations.length; ++j)
                    object.declarations[j] = $root.dataform.Declaration.toObject(message.declarations[j], options);
            }
            if (message.dataformCoreVersion != null && message.hasOwnProperty("dataformCoreVersion"))
                object.dataformCoreVersion = message.dataformCoreVersion;
            if (message.targets && message.targets.length) {
                object.targets = [];
                for (let j = 0; j < message.targets.length; ++j)
                    object.targets[j] = $root.dataform.Target.toObject(message.targets[j], options);
            }
            return object;
        };

        /**
         * Converts this CompiledGraph to JSON.
         * @function toJSON
         * @memberof dataform.CompiledGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompiledGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompiledGraph
         * @function getTypeUrl
         * @memberof dataform.CompiledGraph
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompiledGraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompiledGraph";
        };

        return CompiledGraph;
    })();

    dataform.CoreExecutionRequest = (function() {

        /**
         * Properties of a CoreExecutionRequest.
         * @memberof dataform
         * @interface ICoreExecutionRequest
         * @property {dataform.ICompileExecutionRequest|null} [compile] CoreExecutionRequest compile
         */

        /**
         * Constructs a new CoreExecutionRequest.
         * @memberof dataform
         * @classdesc Represents a CoreExecutionRequest.
         * @implements ICoreExecutionRequest
         * @constructor
         * @param {dataform.ICoreExecutionRequest=} [properties] Properties to set
         */
        function CoreExecutionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreExecutionRequest compile.
         * @member {dataform.ICompileExecutionRequest|null|undefined} compile
         * @memberof dataform.CoreExecutionRequest
         * @instance
         */
        CoreExecutionRequest.prototype.compile = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CoreExecutionRequest request.
         * @member {"compile"|undefined} request
         * @memberof dataform.CoreExecutionRequest
         * @instance
         */
        Object.defineProperty(CoreExecutionRequest.prototype, "request", {
            get: $util.oneOfGetter($oneOfFields = ["compile"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CoreExecutionRequest instance using the specified properties.
         * @function create
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest=} [properties] Properties to set
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest instance
         */
        CoreExecutionRequest.create = function create(properties) {
            return new CoreExecutionRequest(properties);
        };

        /**
         * Encodes the specified CoreExecutionRequest message. Does not implicitly {@link dataform.CoreExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest} message CoreExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compile != null && Object.hasOwnProperty.call(message, "compile"))
                $root.dataform.CompileExecutionRequest.encode(message.compile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CoreExecutionRequest message, length delimited. Does not implicitly {@link dataform.CoreExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.ICoreExecutionRequest} message CoreExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CoreExecutionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compile = $root.dataform.CompileExecutionRequest.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoreExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreExecutionRequest message.
         * @function verify
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compile != null && message.hasOwnProperty("compile")) {
                {
                    let error = $root.dataform.CompileExecutionRequest.verify(message.compile);
                    if (error)
                        return "compile." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CoreExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CoreExecutionRequest} CoreExecutionRequest
         */
        CoreExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CoreExecutionRequest)
                return object;
            let message = new $root.dataform.CoreExecutionRequest();
            if (object.compile != null) {
                if (typeof object.compile !== "object")
                    throw TypeError(".dataform.CoreExecutionRequest.compile: object expected");
                message.compile = $root.dataform.CompileExecutionRequest.fromObject(object.compile);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {dataform.CoreExecutionRequest} message CoreExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.compile != null && message.hasOwnProperty("compile")) {
                object.compile = $root.dataform.CompileExecutionRequest.toObject(message.compile, options);
                if (options.oneofs)
                    object.request = "compile";
            }
            return object;
        };

        /**
         * Converts this CoreExecutionRequest to JSON.
         * @function toJSON
         * @memberof dataform.CoreExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CoreExecutionRequest
         * @function getTypeUrl
         * @memberof dataform.CoreExecutionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CoreExecutionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CoreExecutionRequest";
        };

        return CoreExecutionRequest;
    })();

    dataform.CoreExecutionResponse = (function() {

        /**
         * Properties of a CoreExecutionResponse.
         * @memberof dataform
         * @interface ICoreExecutionResponse
         * @property {dataform.ICompileExecutionResponse|null} [compile] CoreExecutionResponse compile
         */

        /**
         * Constructs a new CoreExecutionResponse.
         * @memberof dataform
         * @classdesc Represents a CoreExecutionResponse.
         * @implements ICoreExecutionResponse
         * @constructor
         * @param {dataform.ICoreExecutionResponse=} [properties] Properties to set
         */
        function CoreExecutionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CoreExecutionResponse compile.
         * @member {dataform.ICompileExecutionResponse|null|undefined} compile
         * @memberof dataform.CoreExecutionResponse
         * @instance
         */
        CoreExecutionResponse.prototype.compile = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CoreExecutionResponse response.
         * @member {"compile"|undefined} response
         * @memberof dataform.CoreExecutionResponse
         * @instance
         */
        Object.defineProperty(CoreExecutionResponse.prototype, "response", {
            get: $util.oneOfGetter($oneOfFields = ["compile"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CoreExecutionResponse instance using the specified properties.
         * @function create
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse=} [properties] Properties to set
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse instance
         */
        CoreExecutionResponse.create = function create(properties) {
            return new CoreExecutionResponse(properties);
        };

        /**
         * Encodes the specified CoreExecutionResponse message. Does not implicitly {@link dataform.CoreExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse} message CoreExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compile != null && Object.hasOwnProperty.call(message, "compile"))
                $root.dataform.CompileExecutionResponse.encode(message.compile, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CoreExecutionResponse message, length delimited. Does not implicitly {@link dataform.CoreExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.ICoreExecutionResponse} message CoreExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CoreExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CoreExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CoreExecutionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compile = $root.dataform.CompileExecutionResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CoreExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CoreExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CoreExecutionResponse message.
         * @function verify
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CoreExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compile != null && message.hasOwnProperty("compile")) {
                {
                    let error = $root.dataform.CompileExecutionResponse.verify(message.compile);
                    if (error)
                        return "compile." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CoreExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CoreExecutionResponse} CoreExecutionResponse
         */
        CoreExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CoreExecutionResponse)
                return object;
            let message = new $root.dataform.CoreExecutionResponse();
            if (object.compile != null) {
                if (typeof object.compile !== "object")
                    throw TypeError(".dataform.CoreExecutionResponse.compile: object expected");
                message.compile = $root.dataform.CompileExecutionResponse.fromObject(object.compile);
            }
            return message;
        };

        /**
         * Creates a plain object from a CoreExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {dataform.CoreExecutionResponse} message CoreExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CoreExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.compile != null && message.hasOwnProperty("compile")) {
                object.compile = $root.dataform.CompileExecutionResponse.toObject(message.compile, options);
                if (options.oneofs)
                    object.response = "compile";
            }
            return object;
        };

        /**
         * Converts this CoreExecutionResponse to JSON.
         * @function toJSON
         * @memberof dataform.CoreExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CoreExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CoreExecutionResponse
         * @function getTypeUrl
         * @memberof dataform.CoreExecutionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CoreExecutionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CoreExecutionResponse";
        };

        return CoreExecutionResponse;
    })();

    dataform.CompileExecutionRequest = (function() {

        /**
         * Properties of a CompileExecutionRequest.
         * @memberof dataform
         * @interface ICompileExecutionRequest
         * @property {dataform.ICompileConfig|null} [compileConfig] CompileExecutionRequest compileConfig
         */

        /**
         * Constructs a new CompileExecutionRequest.
         * @memberof dataform
         * @classdesc Represents a CompileExecutionRequest.
         * @implements ICompileExecutionRequest
         * @constructor
         * @param {dataform.ICompileExecutionRequest=} [properties] Properties to set
         */
        function CompileExecutionRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileExecutionRequest compileConfig.
         * @member {dataform.ICompileConfig|null|undefined} compileConfig
         * @memberof dataform.CompileExecutionRequest
         * @instance
         */
        CompileExecutionRequest.prototype.compileConfig = null;

        /**
         * Creates a new CompileExecutionRequest instance using the specified properties.
         * @function create
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest=} [properties] Properties to set
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest instance
         */
        CompileExecutionRequest.create = function create(properties) {
            return new CompileExecutionRequest(properties);
        };

        /**
         * Encodes the specified CompileExecutionRequest message. Does not implicitly {@link dataform.CompileExecutionRequest.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest} message CompileExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compileConfig != null && Object.hasOwnProperty.call(message, "compileConfig"))
                $root.dataform.CompileConfig.encode(message.compileConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompileExecutionRequest message, length delimited. Does not implicitly {@link dataform.CompileExecutionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.ICompileExecutionRequest} message CompileExecutionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileExecutionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileExecutionRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compileConfig = $root.dataform.CompileConfig.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileExecutionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileExecutionRequest message.
         * @function verify
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileExecutionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig")) {
                let error = $root.dataform.CompileConfig.verify(message.compileConfig);
                if (error)
                    return "compileConfig." + error;
            }
            return null;
        };

        /**
         * Creates a CompileExecutionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileExecutionRequest} CompileExecutionRequest
         */
        CompileExecutionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileExecutionRequest)
                return object;
            let message = new $root.dataform.CompileExecutionRequest();
            if (object.compileConfig != null) {
                if (typeof object.compileConfig !== "object")
                    throw TypeError(".dataform.CompileExecutionRequest.compileConfig: object expected");
                message.compileConfig = $root.dataform.CompileConfig.fromObject(object.compileConfig);
            }
            return message;
        };

        /**
         * Creates a plain object from a CompileExecutionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {dataform.CompileExecutionRequest} message CompileExecutionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileExecutionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.compileConfig = null;
            if (message.compileConfig != null && message.hasOwnProperty("compileConfig"))
                object.compileConfig = $root.dataform.CompileConfig.toObject(message.compileConfig, options);
            return object;
        };

        /**
         * Converts this CompileExecutionRequest to JSON.
         * @function toJSON
         * @memberof dataform.CompileExecutionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileExecutionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileExecutionRequest
         * @function getTypeUrl
         * @memberof dataform.CompileExecutionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileExecutionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileExecutionRequest";
        };

        return CompileExecutionRequest;
    })();

    dataform.CompileExecutionResponse = (function() {

        /**
         * Properties of a CompileExecutionResponse.
         * @memberof dataform
         * @interface ICompileExecutionResponse
         * @property {dataform.ICompiledGraph|null} [compiledGraph] CompileExecutionResponse compiledGraph
         */

        /**
         * Constructs a new CompileExecutionResponse.
         * @memberof dataform
         * @classdesc Represents a CompileExecutionResponse.
         * @implements ICompileExecutionResponse
         * @constructor
         * @param {dataform.ICompileExecutionResponse=} [properties] Properties to set
         */
        function CompileExecutionResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompileExecutionResponse compiledGraph.
         * @member {dataform.ICompiledGraph|null|undefined} compiledGraph
         * @memberof dataform.CompileExecutionResponse
         * @instance
         */
        CompileExecutionResponse.prototype.compiledGraph = null;

        /**
         * Creates a new CompileExecutionResponse instance using the specified properties.
         * @function create
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse=} [properties] Properties to set
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse instance
         */
        CompileExecutionResponse.create = function create(properties) {
            return new CompileExecutionResponse(properties);
        };

        /**
         * Encodes the specified CompileExecutionResponse message. Does not implicitly {@link dataform.CompileExecutionResponse.verify|verify} messages.
         * @function encode
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse} message CompileExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.compiledGraph != null && Object.hasOwnProperty.call(message, "compiledGraph"))
                $root.dataform.CompiledGraph.encode(message.compiledGraph, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CompileExecutionResponse message, length delimited. Does not implicitly {@link dataform.CompileExecutionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.ICompileExecutionResponse} message CompileExecutionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompileExecutionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompileExecutionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.CompileExecutionResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.compiledGraph = $root.dataform.CompiledGraph.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompileExecutionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompileExecutionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompileExecutionResponse message.
         * @function verify
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompileExecutionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.compiledGraph != null && message.hasOwnProperty("compiledGraph")) {
                let error = $root.dataform.CompiledGraph.verify(message.compiledGraph);
                if (error)
                    return "compiledGraph." + error;
            }
            return null;
        };

        /**
         * Creates a CompileExecutionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.CompileExecutionResponse} CompileExecutionResponse
         */
        CompileExecutionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.CompileExecutionResponse)
                return object;
            let message = new $root.dataform.CompileExecutionResponse();
            if (object.compiledGraph != null) {
                if (typeof object.compiledGraph !== "object")
                    throw TypeError(".dataform.CompileExecutionResponse.compiledGraph: object expected");
                message.compiledGraph = $root.dataform.CompiledGraph.fromObject(object.compiledGraph);
            }
            return message;
        };

        /**
         * Creates a plain object from a CompileExecutionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {dataform.CompileExecutionResponse} message CompileExecutionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompileExecutionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.compiledGraph = null;
            if (message.compiledGraph != null && message.hasOwnProperty("compiledGraph"))
                object.compiledGraph = $root.dataform.CompiledGraph.toObject(message.compiledGraph, options);
            return object;
        };

        /**
         * Converts this CompileExecutionResponse to JSON.
         * @function toJSON
         * @memberof dataform.CompileExecutionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompileExecutionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompileExecutionResponse
         * @function getTypeUrl
         * @memberof dataform.CompileExecutionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompileExecutionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.CompileExecutionResponse";
        };

        return CompileExecutionResponse;
    })();

    dataform.QueryEvaluationError = (function() {

        /**
         * Properties of a QueryEvaluationError.
         * @memberof dataform
         * @interface IQueryEvaluationError
         * @property {string|null} [message] QueryEvaluationError message
         * @property {dataform.QueryEvaluationError.IErrorLocation|null} [errorLocation] QueryEvaluationError errorLocation
         */

        /**
         * Constructs a new QueryEvaluationError.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluationError.
         * @implements IQueryEvaluationError
         * @constructor
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         */
        function QueryEvaluationError(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluationError message.
         * @member {string} message
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.message = "";

        /**
         * QueryEvaluationError errorLocation.
         * @member {dataform.QueryEvaluationError.IErrorLocation|null|undefined} errorLocation
         * @memberof dataform.QueryEvaluationError
         * @instance
         */
        QueryEvaluationError.prototype.errorLocation = null;

        /**
         * Creates a new QueryEvaluationError instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError=} [properties] Properties to set
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError instance
         */
        QueryEvaluationError.create = function create(properties) {
            return new QueryEvaluationError(properties);
        };

        /**
         * Encodes the specified QueryEvaluationError message. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            if (message.errorLocation != null && Object.hasOwnProperty.call(message, "errorLocation"))
                $root.dataform.QueryEvaluationError.ErrorLocation.encode(message.errorLocation, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluationError message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.IQueryEvaluationError} message QueryEvaluationError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluationError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.message = reader.string();
                        break;
                    }
                case 2: {
                        message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluationError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluationError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluationError message.
         * @function verify
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluationError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation")) {
                let error = $root.dataform.QueryEvaluationError.ErrorLocation.verify(message.errorLocation);
                if (error)
                    return "errorLocation." + error;
            }
            return null;
        };

        /**
         * Creates a QueryEvaluationError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluationError} QueryEvaluationError
         */
        QueryEvaluationError.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluationError)
                return object;
            let message = new $root.dataform.QueryEvaluationError();
            if (object.message != null)
                message.message = String(object.message);
            if (object.errorLocation != null) {
                if (typeof object.errorLocation !== "object")
                    throw TypeError(".dataform.QueryEvaluationError.errorLocation: object expected");
                message.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.fromObject(object.errorLocation);
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluationError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {dataform.QueryEvaluationError} message QueryEvaluationError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluationError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.message = "";
                object.errorLocation = null;
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            if (message.errorLocation != null && message.hasOwnProperty("errorLocation"))
                object.errorLocation = $root.dataform.QueryEvaluationError.ErrorLocation.toObject(message.errorLocation, options);
            return object;
        };

        /**
         * Converts this QueryEvaluationError to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluationError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluationError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QueryEvaluationError
         * @function getTypeUrl
         * @memberof dataform.QueryEvaluationError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryEvaluationError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.QueryEvaluationError";
        };

        QueryEvaluationError.ErrorLocation = (function() {

            /**
             * Properties of an ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @interface IErrorLocation
             * @property {number|null} [line] ErrorLocation line
             * @property {number|null} [column] ErrorLocation column
             */

            /**
             * Constructs a new ErrorLocation.
             * @memberof dataform.QueryEvaluationError
             * @classdesc Represents an ErrorLocation.
             * @implements IErrorLocation
             * @constructor
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             */
            function ErrorLocation(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ErrorLocation line.
             * @member {number} line
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.line = 0;

            /**
             * ErrorLocation column.
             * @member {number} column
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             */
            ErrorLocation.prototype.column = 0;

            /**
             * Creates a new ErrorLocation instance using the specified properties.
             * @function create
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation=} [properties] Properties to set
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation instance
             */
            ErrorLocation.create = function create(properties) {
                return new ErrorLocation(properties);
            };

            /**
             * Encodes the specified ErrorLocation message. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.line != null && Object.hasOwnProperty.call(message, "line"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.line);
                if (message.column != null && Object.hasOwnProperty.call(message, "column"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.column);
                return writer;
            };

            /**
             * Encodes the specified ErrorLocation message, length delimited. Does not implicitly {@link dataform.QueryEvaluationError.ErrorLocation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.IErrorLocation} message ErrorLocation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ErrorLocation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.line = reader.int32();
                            break;
                        }
                    case 2: {
                            message.column = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ErrorLocation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ErrorLocation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ErrorLocation message.
             * @function verify
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ErrorLocation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.line != null && message.hasOwnProperty("line"))
                    if (!$util.isInteger(message.line))
                        return "line: integer expected";
                if (message.column != null && message.hasOwnProperty("column"))
                    if (!$util.isInteger(message.column))
                        return "column: integer expected";
                return null;
            };

            /**
             * Creates an ErrorLocation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.QueryEvaluationError.ErrorLocation} ErrorLocation
             */
            ErrorLocation.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.QueryEvaluationError.ErrorLocation)
                    return object;
                let message = new $root.dataform.QueryEvaluationError.ErrorLocation();
                if (object.line != null)
                    message.line = object.line | 0;
                if (object.column != null)
                    message.column = object.column | 0;
                return message;
            };

            /**
             * Creates a plain object from an ErrorLocation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {dataform.QueryEvaluationError.ErrorLocation} message ErrorLocation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ErrorLocation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.line = 0;
                    object.column = 0;
                }
                if (message.line != null && message.hasOwnProperty("line"))
                    object.line = message.line;
                if (message.column != null && message.hasOwnProperty("column"))
                    object.column = message.column;
                return object;
            };

            /**
             * Converts this ErrorLocation to JSON.
             * @function toJSON
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ErrorLocation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ErrorLocation
             * @function getTypeUrl
             * @memberof dataform.QueryEvaluationError.ErrorLocation
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ErrorLocation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.QueryEvaluationError.ErrorLocation";
            };

            return ErrorLocation;
        })();

        return QueryEvaluationError;
    })();

    dataform.QueryEvaluation = (function() {

        /**
         * Properties of a QueryEvaluation.
         * @memberof dataform
         * @interface IQueryEvaluation
         * @property {dataform.QueryEvaluation.QueryEvaluationStatus|null} [status] QueryEvaluation status
         * @property {dataform.IQueryEvaluationError|null} [error] QueryEvaluation error
         * @property {boolean|null} [incremental] QueryEvaluation incremental
         * @property {string|null} [query] QueryEvaluation query
         */

        /**
         * Constructs a new QueryEvaluation.
         * @memberof dataform
         * @classdesc Represents a QueryEvaluation.
         * @implements IQueryEvaluation
         * @constructor
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         */
        function QueryEvaluation(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryEvaluation status.
         * @member {dataform.QueryEvaluation.QueryEvaluationStatus} status
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.status = 0;

        /**
         * QueryEvaluation error.
         * @member {dataform.IQueryEvaluationError|null|undefined} error
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.error = null;

        /**
         * QueryEvaluation incremental.
         * @member {boolean} incremental
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.incremental = false;

        /**
         * QueryEvaluation query.
         * @member {string} query
         * @memberof dataform.QueryEvaluation
         * @instance
         */
        QueryEvaluation.prototype.query = "";

        /**
         * Creates a new QueryEvaluation instance using the specified properties.
         * @function create
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation=} [properties] Properties to set
         * @returns {dataform.QueryEvaluation} QueryEvaluation instance
         */
        QueryEvaluation.create = function create(properties) {
            return new QueryEvaluation(properties);
        };

        /**
         * Encodes the specified QueryEvaluation message. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.dataform.QueryEvaluationError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.incremental != null && Object.hasOwnProperty.call(message, "incremental"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.incremental);
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.query);
            return writer;
        };

        /**
         * Encodes the specified QueryEvaluation message, length delimited. Does not implicitly {@link dataform.QueryEvaluation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.IQueryEvaluation} message QueryEvaluation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryEvaluation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.QueryEvaluation();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.error = $root.dataform.QueryEvaluationError.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.incremental = reader.bool();
                        break;
                    }
                case 4: {
                        message.query = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryEvaluation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryEvaluation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryEvaluation message.
         * @function verify
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryEvaluation.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.error != null && message.hasOwnProperty("error")) {
                let error = $root.dataform.QueryEvaluationError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                if (typeof message.incremental !== "boolean")
                    return "incremental: boolean expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            return null;
        };

        /**
         * Creates a QueryEvaluation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.QueryEvaluation} QueryEvaluation
         */
        QueryEvaluation.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.QueryEvaluation)
                return object;
            let message = new $root.dataform.QueryEvaluation();
            switch (object.status) {
            case "SUCCESS":
            case 0:
                message.status = 0;
                break;
            case "FAILURE":
            case 1:
                message.status = 1;
                break;
            }
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".dataform.QueryEvaluation.error: object expected");
                message.error = $root.dataform.QueryEvaluationError.fromObject(object.error);
            }
            if (object.incremental != null)
                message.incremental = Boolean(object.incremental);
            if (object.query != null)
                message.query = String(object.query);
            return message;
        };

        /**
         * Creates a plain object from a QueryEvaluation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {dataform.QueryEvaluation} message QueryEvaluation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryEvaluation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "SUCCESS" : 0;
                object.error = null;
                object.incremental = false;
                object.query = "";
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.QueryEvaluation.QueryEvaluationStatus[message.status] : message.status;
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.dataform.QueryEvaluationError.toObject(message.error, options);
            if (message.incremental != null && message.hasOwnProperty("incremental"))
                object.incremental = message.incremental;
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            return object;
        };

        /**
         * Converts this QueryEvaluation to JSON.
         * @function toJSON
         * @memberof dataform.QueryEvaluation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryEvaluation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for QueryEvaluation
         * @function getTypeUrl
         * @memberof dataform.QueryEvaluation
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        QueryEvaluation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.QueryEvaluation";
        };

        /**
         * QueryEvaluationStatus enum.
         * @name dataform.QueryEvaluation.QueryEvaluationStatus
         * @enum {number}
         * @property {number} SUCCESS=0 SUCCESS value
         * @property {number} FAILURE=1 FAILURE value
         */
        QueryEvaluation.QueryEvaluationStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SUCCESS"] = 0;
            values[valuesById[1] = "FAILURE"] = 1;
            return values;
        })();

        return QueryEvaluation;
    })();

    dataform.RunConfig = (function() {

        /**
         * Properties of a RunConfig.
         * @memberof dataform
         * @interface IRunConfig
         * @property {Array.<string>|null} [actions] RunConfig actions
         * @property {Array.<string>|null} [tags] RunConfig tags
         * @property {boolean|null} [includeDependencies] RunConfig includeDependencies
         * @property {boolean|null} [includeDependents] RunConfig includeDependents
         * @property {boolean|null} [fullRefresh] RunConfig fullRefresh
         * @property {number|null} [timeoutMillis] RunConfig timeoutMillis
         * @property {boolean|null} [disableSetMetadata] RunConfig disableSetMetadata
         * @property {boolean|null} [useRunCache] RunConfig useRunCache
         */

        /**
         * Constructs a new RunConfig.
         * @memberof dataform
         * @classdesc Represents a RunConfig.
         * @implements IRunConfig
         * @constructor
         * @param {dataform.IRunConfig=} [properties] Properties to set
         */
        function RunConfig(properties) {
            this.actions = [];
            this.tags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunConfig actions.
         * @member {Array.<string>} actions
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.actions = $util.emptyArray;

        /**
         * RunConfig tags.
         * @member {Array.<string>} tags
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.tags = $util.emptyArray;

        /**
         * RunConfig includeDependencies.
         * @member {boolean} includeDependencies
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependencies = false;

        /**
         * RunConfig includeDependents.
         * @member {boolean} includeDependents
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.includeDependents = false;

        /**
         * RunConfig fullRefresh.
         * @member {boolean} fullRefresh
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.fullRefresh = false;

        /**
         * RunConfig timeoutMillis.
         * @member {number} timeoutMillis
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.timeoutMillis = 0;

        /**
         * RunConfig disableSetMetadata.
         * @member {boolean} disableSetMetadata
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.disableSetMetadata = false;

        /**
         * RunConfig useRunCache.
         * @member {boolean} useRunCache
         * @memberof dataform.RunConfig
         * @instance
         */
        RunConfig.prototype.useRunCache = false;

        /**
         * Creates a new RunConfig instance using the specified properties.
         * @function create
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig=} [properties] Properties to set
         * @returns {dataform.RunConfig} RunConfig instance
         */
        RunConfig.create = function create(properties) {
            return new RunConfig(properties);
        };

        /**
         * Encodes the specified RunConfig message. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.actions[i]);
            if (message.fullRefresh != null && Object.hasOwnProperty.call(message, "fullRefresh"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.fullRefresh);
            if (message.includeDependencies != null && Object.hasOwnProperty.call(message, "includeDependencies"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.includeDependencies);
            if (message.tags != null && message.tags.length)
                for (let i = 0; i < message.tags.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.tags[i]);
            if (message.timeoutMillis != null && Object.hasOwnProperty.call(message, "timeoutMillis"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.timeoutMillis);
            if (message.useRunCache != null && Object.hasOwnProperty.call(message, "useRunCache"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.useRunCache);
            if (message.disableSetMetadata != null && Object.hasOwnProperty.call(message, "disableSetMetadata"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.disableSetMetadata);
            if (message.includeDependents != null && Object.hasOwnProperty.call(message, "includeDependents"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.includeDependents);
            return writer;
        };

        /**
         * Encodes the specified RunConfig message, length delimited. Does not implicitly {@link dataform.RunConfig.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.IRunConfig} message RunConfig message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunConfig.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunConfig();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push(reader.string());
                        break;
                    }
                case 5: {
                        if (!(message.tags && message.tags.length))
                            message.tags = [];
                        message.tags.push(reader.string());
                        break;
                    }
                case 3: {
                        message.includeDependencies = reader.bool();
                        break;
                    }
                case 11: {
                        message.includeDependents = reader.bool();
                        break;
                    }
                case 2: {
                        message.fullRefresh = reader.bool();
                        break;
                    }
                case 7: {
                        message.timeoutMillis = reader.int32();
                        break;
                    }
                case 9: {
                        message.disableSetMetadata = reader.bool();
                        break;
                    }
                case 8: {
                        message.useRunCache = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunConfig message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunConfig
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunConfig} RunConfig
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunConfig.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunConfig message.
         * @function verify
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunConfig.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i)
                    if (!$util.isString(message.actions[i]))
                        return "actions: string[] expected";
            }
            if (message.tags != null && message.hasOwnProperty("tags")) {
                if (!Array.isArray(message.tags))
                    return "tags: array expected";
                for (let i = 0; i < message.tags.length; ++i)
                    if (!$util.isString(message.tags[i]))
                        return "tags: string[] expected";
            }
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                if (typeof message.includeDependencies !== "boolean")
                    return "includeDependencies: boolean expected";
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                if (typeof message.includeDependents !== "boolean")
                    return "includeDependents: boolean expected";
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                if (typeof message.fullRefresh !== "boolean")
                    return "fullRefresh: boolean expected";
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                if (!$util.isInteger(message.timeoutMillis))
                    return "timeoutMillis: integer expected";
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                if (typeof message.disableSetMetadata !== "boolean")
                    return "disableSetMetadata: boolean expected";
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                if (typeof message.useRunCache !== "boolean")
                    return "useRunCache: boolean expected";
            return null;
        };

        /**
         * Creates a RunConfig message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunConfig
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunConfig} RunConfig
         */
        RunConfig.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunConfig)
                return object;
            let message = new $root.dataform.RunConfig();
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunConfig.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i)
                    message.actions[i] = String(object.actions[i]);
            }
            if (object.tags) {
                if (!Array.isArray(object.tags))
                    throw TypeError(".dataform.RunConfig.tags: array expected");
                message.tags = [];
                for (let i = 0; i < object.tags.length; ++i)
                    message.tags[i] = String(object.tags[i]);
            }
            if (object.includeDependencies != null)
                message.includeDependencies = Boolean(object.includeDependencies);
            if (object.includeDependents != null)
                message.includeDependents = Boolean(object.includeDependents);
            if (object.fullRefresh != null)
                message.fullRefresh = Boolean(object.fullRefresh);
            if (object.timeoutMillis != null)
                message.timeoutMillis = object.timeoutMillis | 0;
            if (object.disableSetMetadata != null)
                message.disableSetMetadata = Boolean(object.disableSetMetadata);
            if (object.useRunCache != null)
                message.useRunCache = Boolean(object.useRunCache);
            return message;
        };

        /**
         * Creates a plain object from a RunConfig message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunConfig
         * @static
         * @param {dataform.RunConfig} message RunConfig
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunConfig.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.tags = [];
            }
            if (options.defaults) {
                object.fullRefresh = false;
                object.includeDependencies = false;
                object.timeoutMillis = 0;
                object.useRunCache = false;
                object.disableSetMetadata = false;
                object.includeDependents = false;
            }
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = message.actions[j];
            }
            if (message.fullRefresh != null && message.hasOwnProperty("fullRefresh"))
                object.fullRefresh = message.fullRefresh;
            if (message.includeDependencies != null && message.hasOwnProperty("includeDependencies"))
                object.includeDependencies = message.includeDependencies;
            if (message.tags && message.tags.length) {
                object.tags = [];
                for (let j = 0; j < message.tags.length; ++j)
                    object.tags[j] = message.tags[j];
            }
            if (message.timeoutMillis != null && message.hasOwnProperty("timeoutMillis"))
                object.timeoutMillis = message.timeoutMillis;
            if (message.useRunCache != null && message.hasOwnProperty("useRunCache"))
                object.useRunCache = message.useRunCache;
            if (message.disableSetMetadata != null && message.hasOwnProperty("disableSetMetadata"))
                object.disableSetMetadata = message.disableSetMetadata;
            if (message.includeDependents != null && message.hasOwnProperty("includeDependents"))
                object.includeDependents = message.includeDependents;
            return object;
        };

        /**
         * Converts this RunConfig to JSON.
         * @function toJSON
         * @memberof dataform.RunConfig
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunConfig.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RunConfig
         * @function getTypeUrl
         * @memberof dataform.RunConfig
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RunConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.RunConfig";
        };

        return RunConfig;
    })();

    dataform.ExecutionTask = (function() {

        /**
         * Properties of an ExecutionTask.
         * @memberof dataform
         * @interface IExecutionTask
         * @property {string|null} [type] ExecutionTask type
         * @property {string|null} [statement] ExecutionTask statement
         */

        /**
         * Constructs a new ExecutionTask.
         * @memberof dataform
         * @classdesc Represents an ExecutionTask.
         * @implements IExecutionTask
         * @constructor
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         */
        function ExecutionTask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionTask type.
         * @member {string} type
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.type = "";

        /**
         * ExecutionTask statement.
         * @member {string} statement
         * @memberof dataform.ExecutionTask
         * @instance
         */
        ExecutionTask.prototype.statement = "";

        /**
         * Creates a new ExecutionTask instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask=} [properties] Properties to set
         * @returns {dataform.ExecutionTask} ExecutionTask instance
         */
        ExecutionTask.create = function create(properties) {
            return new ExecutionTask(properties);
        };

        /**
         * Encodes the specified ExecutionTask message. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
            if (message.statement != null && Object.hasOwnProperty.call(message, "statement"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.statement);
            return writer;
        };

        /**
         * Encodes the specified ExecutionTask message, length delimited. Does not implicitly {@link dataform.ExecutionTask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.IExecutionTask} message ExecutionTask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionTask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionTask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.string();
                        break;
                    }
                case 2: {
                        message.statement = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionTask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionTask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionTask} ExecutionTask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionTask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionTask message.
         * @function verify
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionTask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.statement != null && message.hasOwnProperty("statement"))
                if (!$util.isString(message.statement))
                    return "statement: string expected";
            return null;
        };

        /**
         * Creates an ExecutionTask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionTask} ExecutionTask
         */
        ExecutionTask.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionTask)
                return object;
            let message = new $root.dataform.ExecutionTask();
            if (object.type != null)
                message.type = String(object.type);
            if (object.statement != null)
                message.statement = String(object.statement);
            return message;
        };

        /**
         * Creates a plain object from an ExecutionTask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionTask
         * @static
         * @param {dataform.ExecutionTask} message ExecutionTask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionTask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = "";
                object.statement = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.statement != null && message.hasOwnProperty("statement"))
                object.statement = message.statement;
            return object;
        };

        /**
         * Converts this ExecutionTask to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionTask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionTask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionTask
         * @function getTypeUrl
         * @memberof dataform.ExecutionTask
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionTask";
        };

        return ExecutionTask;
    })();

    dataform.ExecutionAction = (function() {

        /**
         * Properties of an ExecutionAction.
         * @memberof dataform
         * @interface IExecutionAction
         * @property {dataform.ITarget|null} [target] ExecutionAction target
         * @property {string|null} [fileName] ExecutionAction fileName
         * @property {string|null} [type] ExecutionAction type
         * @property {string|null} [tableType] ExecutionAction tableType
         * @property {Array.<dataform.ITarget>|null} [dependencyTargets] ExecutionAction dependencyTargets
         * @property {dataform.ActionHermeticity|null} [hermeticity] ExecutionAction hermeticity
         * @property {Array.<dataform.IExecutionTask>|null} [tasks] ExecutionAction tasks
         * @property {dataform.IActionDescriptor|null} [actionDescriptor] ExecutionAction actionDescriptor
         */

        /**
         * Constructs a new ExecutionAction.
         * @memberof dataform
         * @classdesc Represents an ExecutionAction.
         * @implements IExecutionAction
         * @constructor
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         */
        function ExecutionAction(properties) {
            this.dependencyTargets = [];
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionAction target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.target = null;

        /**
         * ExecutionAction fileName.
         * @member {string} fileName
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.fileName = "";

        /**
         * ExecutionAction type.
         * @member {string} type
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.type = "";

        /**
         * ExecutionAction tableType.
         * @member {string} tableType
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tableType = "";

        /**
         * ExecutionAction dependencyTargets.
         * @member {Array.<dataform.ITarget>} dependencyTargets
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.dependencyTargets = $util.emptyArray;

        /**
         * ExecutionAction hermeticity.
         * @member {dataform.ActionHermeticity} hermeticity
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.hermeticity = 0;

        /**
         * ExecutionAction tasks.
         * @member {Array.<dataform.IExecutionTask>} tasks
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.tasks = $util.emptyArray;

        /**
         * ExecutionAction actionDescriptor.
         * @member {dataform.IActionDescriptor|null|undefined} actionDescriptor
         * @memberof dataform.ExecutionAction
         * @instance
         */
        ExecutionAction.prototype.actionDescriptor = null;

        /**
         * Creates a new ExecutionAction instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction=} [properties] Properties to set
         * @returns {dataform.ExecutionAction} ExecutionAction instance
         */
        ExecutionAction.create = function create(properties) {
            return new ExecutionAction(properties);
        };

        /**
         * Encodes the specified ExecutionAction message. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.ExecutionTask.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.type);
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.tableType != null && Object.hasOwnProperty.call(message, "tableType"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.tableType);
            if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileName);
            if (message.actionDescriptor != null && Object.hasOwnProperty.call(message, "actionDescriptor"))
                $root.dataform.ActionDescriptor.encode(message.actionDescriptor, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.hermeticity != null && Object.hasOwnProperty.call(message, "hermeticity"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.hermeticity);
            if (message.dependencyTargets != null && message.dependencyTargets.length)
                for (let i = 0; i < message.dependencyTargets.length; ++i)
                    $root.dataform.Target.encode(message.dependencyTargets[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionAction message, length delimited. Does not implicitly {@link dataform.ExecutionAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.IExecutionAction} message ExecutionAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.fileName = reader.string();
                        break;
                    }
                case 4: {
                        message.type = reader.string();
                        break;
                    }
                case 6: {
                        message.tableType = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.dependencyTargets && message.dependencyTargets.length))
                            message.dependencyTargets = [];
                        message.dependencyTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.hermeticity = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.dataform.ExecutionTask.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.actionDescriptor = $root.dataform.ActionDescriptor.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionAction} ExecutionAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionAction message.
         * @function verify
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                if (!$util.isString(message.fileName))
                    return "fileName: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isString(message.type))
                    return "type: string expected";
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                if (!$util.isString(message.tableType))
                    return "tableType: string expected";
            if (message.dependencyTargets != null && message.hasOwnProperty("dependencyTargets")) {
                if (!Array.isArray(message.dependencyTargets))
                    return "dependencyTargets: array expected";
                for (let i = 0; i < message.dependencyTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.dependencyTargets[i]);
                    if (error)
                        return "dependencyTargets." + error;
                }
            }
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                switch (message.hermeticity) {
                default:
                    return "hermeticity: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.ExecutionTask.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor")) {
                let error = $root.dataform.ActionDescriptor.verify(message.actionDescriptor);
                if (error)
                    return "actionDescriptor." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionAction} ExecutionAction
         */
        ExecutionAction.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionAction)
                return object;
            let message = new $root.dataform.ExecutionAction();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ExecutionAction.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            if (object.fileName != null)
                message.fileName = String(object.fileName);
            if (object.type != null)
                message.type = String(object.type);
            if (object.tableType != null)
                message.tableType = String(object.tableType);
            if (object.dependencyTargets) {
                if (!Array.isArray(object.dependencyTargets))
                    throw TypeError(".dataform.ExecutionAction.dependencyTargets: array expected");
                message.dependencyTargets = [];
                for (let i = 0; i < object.dependencyTargets.length; ++i) {
                    if (typeof object.dependencyTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.dependencyTargets: object expected");
                    message.dependencyTargets[i] = $root.dataform.Target.fromObject(object.dependencyTargets[i]);
                }
            }
            switch (object.hermeticity) {
            case "UNKNOWN":
            case 0:
                message.hermeticity = 0;
                break;
            case "HERMETIC":
            case 1:
                message.hermeticity = 1;
                break;
            case "NON_HERMETIC":
            case 2:
                message.hermeticity = 2;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ExecutionAction.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ExecutionAction.tasks: object expected");
                    message.tasks[i] = $root.dataform.ExecutionTask.fromObject(object.tasks[i]);
                }
            }
            if (object.actionDescriptor != null) {
                if (typeof object.actionDescriptor !== "object")
                    throw TypeError(".dataform.ExecutionAction.actionDescriptor: object expected");
                message.actionDescriptor = $root.dataform.ActionDescriptor.fromObject(object.actionDescriptor);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionAction
         * @static
         * @param {dataform.ExecutionAction} message ExecutionAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.tasks = [];
                object.dependencyTargets = [];
            }
            if (options.defaults) {
                object.type = "";
                object.target = null;
                object.tableType = "";
                object.fileName = "";
                object.actionDescriptor = null;
                object.hermeticity = options.enums === String ? "UNKNOWN" : 0;
            }
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.ExecutionTask.toObject(message.tasks[j], options);
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.tableType != null && message.hasOwnProperty("tableType"))
                object.tableType = message.tableType;
            if (message.fileName != null && message.hasOwnProperty("fileName"))
                object.fileName = message.fileName;
            if (message.actionDescriptor != null && message.hasOwnProperty("actionDescriptor"))
                object.actionDescriptor = $root.dataform.ActionDescriptor.toObject(message.actionDescriptor, options);
            if (message.hermeticity != null && message.hasOwnProperty("hermeticity"))
                object.hermeticity = options.enums === String ? $root.dataform.ActionHermeticity[message.hermeticity] : message.hermeticity;
            if (message.dependencyTargets && message.dependencyTargets.length) {
                object.dependencyTargets = [];
                for (let j = 0; j < message.dependencyTargets.length; ++j)
                    object.dependencyTargets[j] = $root.dataform.Target.toObject(message.dependencyTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionAction to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionAction
         * @function getTypeUrl
         * @memberof dataform.ExecutionAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionAction";
        };

        return ExecutionAction;
    })();

    dataform.WarehouseState = (function() {

        /**
         * Properties of a WarehouseState.
         * @memberof dataform
         * @interface IWarehouseState
         * @property {Array.<dataform.ITableMetadata>|null} [tables] WarehouseState tables
         */

        /**
         * Constructs a new WarehouseState.
         * @memberof dataform
         * @classdesc Represents a WarehouseState.
         * @implements IWarehouseState
         * @constructor
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         */
        function WarehouseState(properties) {
            this.tables = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarehouseState tables.
         * @member {Array.<dataform.ITableMetadata>} tables
         * @memberof dataform.WarehouseState
         * @instance
         */
        WarehouseState.prototype.tables = $util.emptyArray;

        /**
         * Creates a new WarehouseState instance using the specified properties.
         * @function create
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState=} [properties] Properties to set
         * @returns {dataform.WarehouseState} WarehouseState instance
         */
        WarehouseState.create = function create(properties) {
            return new WarehouseState(properties);
        };

        /**
         * Encodes the specified WarehouseState message. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encode
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tables != null && message.tables.length)
                for (let i = 0; i < message.tables.length; ++i)
                    $root.dataform.TableMetadata.encode(message.tables[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WarehouseState message, length delimited. Does not implicitly {@link dataform.WarehouseState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.IWarehouseState} message WarehouseState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarehouseState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.WarehouseState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tables && message.tables.length))
                            message.tables = [];
                        message.tables.push($root.dataform.TableMetadata.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarehouseState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.WarehouseState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.WarehouseState} WarehouseState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarehouseState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarehouseState message.
         * @function verify
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarehouseState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tables != null && message.hasOwnProperty("tables")) {
                if (!Array.isArray(message.tables))
                    return "tables: array expected";
                for (let i = 0; i < message.tables.length; ++i) {
                    let error = $root.dataform.TableMetadata.verify(message.tables[i]);
                    if (error)
                        return "tables." + error;
                }
            }
            return null;
        };

        /**
         * Creates a WarehouseState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.WarehouseState} WarehouseState
         */
        WarehouseState.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.WarehouseState)
                return object;
            let message = new $root.dataform.WarehouseState();
            if (object.tables) {
                if (!Array.isArray(object.tables))
                    throw TypeError(".dataform.WarehouseState.tables: array expected");
                message.tables = [];
                for (let i = 0; i < object.tables.length; ++i) {
                    if (typeof object.tables[i] !== "object")
                        throw TypeError(".dataform.WarehouseState.tables: object expected");
                    message.tables[i] = $root.dataform.TableMetadata.fromObject(object.tables[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a WarehouseState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.WarehouseState
         * @static
         * @param {dataform.WarehouseState} message WarehouseState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WarehouseState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tables = [];
            if (message.tables && message.tables.length) {
                object.tables = [];
                for (let j = 0; j < message.tables.length; ++j)
                    object.tables[j] = $root.dataform.TableMetadata.toObject(message.tables[j], options);
            }
            return object;
        };

        /**
         * Converts this WarehouseState to JSON.
         * @function toJSON
         * @memberof dataform.WarehouseState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WarehouseState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for WarehouseState
         * @function getTypeUrl
         * @memberof dataform.WarehouseState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        WarehouseState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.WarehouseState";
        };

        return WarehouseState;
    })();

    dataform.ExecutionGraph = (function() {

        /**
         * Properties of an ExecutionGraph.
         * @memberof dataform
         * @interface IExecutionGraph
         * @property {dataform.IProjectConfig|null} [projectConfig] ExecutionGraph projectConfig
         * @property {dataform.IRunConfig|null} [runConfig] ExecutionGraph runConfig
         * @property {dataform.IWarehouseState|null} [warehouseState] ExecutionGraph warehouseState
         * @property {Array.<dataform.ITarget>|null} [declarationTargets] ExecutionGraph declarationTargets
         * @property {Array.<dataform.IExecutionAction>|null} [actions] ExecutionGraph actions
         */

        /**
         * Constructs a new ExecutionGraph.
         * @memberof dataform
         * @classdesc Represents an ExecutionGraph.
         * @implements IExecutionGraph
         * @constructor
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         */
        function ExecutionGraph(properties) {
            this.declarationTargets = [];
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionGraph projectConfig.
         * @member {dataform.IProjectConfig|null|undefined} projectConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.projectConfig = null;

        /**
         * ExecutionGraph runConfig.
         * @member {dataform.IRunConfig|null|undefined} runConfig
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.runConfig = null;

        /**
         * ExecutionGraph warehouseState.
         * @member {dataform.IWarehouseState|null|undefined} warehouseState
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.warehouseState = null;

        /**
         * ExecutionGraph declarationTargets.
         * @member {Array.<dataform.ITarget>} declarationTargets
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.declarationTargets = $util.emptyArray;

        /**
         * ExecutionGraph actions.
         * @member {Array.<dataform.IExecutionAction>} actions
         * @memberof dataform.ExecutionGraph
         * @instance
         */
        ExecutionGraph.prototype.actions = $util.emptyArray;

        /**
         * Creates a new ExecutionGraph instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph=} [properties] Properties to set
         * @returns {dataform.ExecutionGraph} ExecutionGraph instance
         */
        ExecutionGraph.create = function create(properties) {
            return new ExecutionGraph(properties);
        };

        /**
         * Encodes the specified ExecutionGraph message. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectConfig != null && Object.hasOwnProperty.call(message, "projectConfig"))
                $root.dataform.ProjectConfig.encode(message.projectConfig, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.runConfig != null && Object.hasOwnProperty.call(message, "runConfig"))
                $root.dataform.RunConfig.encode(message.runConfig, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ExecutionAction.encode(message.actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.warehouseState != null && Object.hasOwnProperty.call(message, "warehouseState"))
                $root.dataform.WarehouseState.encode(message.warehouseState, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.declarationTargets != null && message.declarationTargets.length)
                for (let i = 0; i < message.declarationTargets.length; ++i)
                    $root.dataform.Target.encode(message.declarationTargets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionGraph message, length delimited. Does not implicitly {@link dataform.ExecutionGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.IExecutionGraph} message ExecutionGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectConfig = $root.dataform.ProjectConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.runConfig = $root.dataform.RunConfig.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.warehouseState = $root.dataform.WarehouseState.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.declarationTargets && message.declarationTargets.length))
                            message.declarationTargets = [];
                        message.declarationTargets.push($root.dataform.Target.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.dataform.ExecutionAction.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionGraph message.
         * @function verify
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig")) {
                let error = $root.dataform.ProjectConfig.verify(message.projectConfig);
                if (error)
                    return "projectConfig." + error;
            }
            if (message.runConfig != null && message.hasOwnProperty("runConfig")) {
                let error = $root.dataform.RunConfig.verify(message.runConfig);
                if (error)
                    return "runConfig." + error;
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState")) {
                let error = $root.dataform.WarehouseState.verify(message.warehouseState);
                if (error)
                    return "warehouseState." + error;
            }
            if (message.declarationTargets != null && message.hasOwnProperty("declarationTargets")) {
                if (!Array.isArray(message.declarationTargets))
                    return "declarationTargets: array expected";
                for (let i = 0; i < message.declarationTargets.length; ++i) {
                    let error = $root.dataform.Target.verify(message.declarationTargets[i]);
                    if (error)
                        return "declarationTargets." + error;
                }
            }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ExecutionAction.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ExecutionGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionGraph} ExecutionGraph
         */
        ExecutionGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionGraph)
                return object;
            let message = new $root.dataform.ExecutionGraph();
            if (object.projectConfig != null) {
                if (typeof object.projectConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.projectConfig: object expected");
                message.projectConfig = $root.dataform.ProjectConfig.fromObject(object.projectConfig);
            }
            if (object.runConfig != null) {
                if (typeof object.runConfig !== "object")
                    throw TypeError(".dataform.ExecutionGraph.runConfig: object expected");
                message.runConfig = $root.dataform.RunConfig.fromObject(object.runConfig);
            }
            if (object.warehouseState != null) {
                if (typeof object.warehouseState !== "object")
                    throw TypeError(".dataform.ExecutionGraph.warehouseState: object expected");
                message.warehouseState = $root.dataform.WarehouseState.fromObject(object.warehouseState);
            }
            if (object.declarationTargets) {
                if (!Array.isArray(object.declarationTargets))
                    throw TypeError(".dataform.ExecutionGraph.declarationTargets: array expected");
                message.declarationTargets = [];
                for (let i = 0; i < object.declarationTargets.length; ++i) {
                    if (typeof object.declarationTargets[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.declarationTargets: object expected");
                    message.declarationTargets[i] = $root.dataform.Target.fromObject(object.declarationTargets[i]);
                }
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.ExecutionGraph.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.ExecutionGraph.actions: object expected");
                    message.actions[i] = $root.dataform.ExecutionAction.fromObject(object.actions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {dataform.ExecutionGraph} message ExecutionGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.actions = [];
                object.declarationTargets = [];
            }
            if (options.defaults) {
                object.projectConfig = null;
                object.runConfig = null;
                object.warehouseState = null;
            }
            if (message.projectConfig != null && message.hasOwnProperty("projectConfig"))
                object.projectConfig = $root.dataform.ProjectConfig.toObject(message.projectConfig, options);
            if (message.runConfig != null && message.hasOwnProperty("runConfig"))
                object.runConfig = $root.dataform.RunConfig.toObject(message.runConfig, options);
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ExecutionAction.toObject(message.actions[j], options);
            }
            if (message.warehouseState != null && message.hasOwnProperty("warehouseState"))
                object.warehouseState = $root.dataform.WarehouseState.toObject(message.warehouseState, options);
            if (message.declarationTargets && message.declarationTargets.length) {
                object.declarationTargets = [];
                for (let j = 0; j < message.declarationTargets.length; ++j)
                    object.declarationTargets[j] = $root.dataform.Target.toObject(message.declarationTargets[j], options);
            }
            return object;
        };

        /**
         * Converts this ExecutionGraph to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionGraph
         * @function getTypeUrl
         * @memberof dataform.ExecutionGraph
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionGraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionGraph";
        };

        return ExecutionGraph;
    })();

    dataform.Timing = (function() {

        /**
         * Properties of a Timing.
         * @memberof dataform
         * @interface ITiming
         * @property {Long|null} [startTimeMillis] Timing startTimeMillis
         * @property {Long|null} [endTimeMillis] Timing endTimeMillis
         */

        /**
         * Constructs a new Timing.
         * @memberof dataform
         * @classdesc Represents a Timing.
         * @implements ITiming
         * @constructor
         * @param {dataform.ITiming=} [properties] Properties to set
         */
        function Timing(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timing startTimeMillis.
         * @member {Long} startTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.startTimeMillis = 0;

        /**
         * Timing endTimeMillis.
         * @member {Long} endTimeMillis
         * @memberof dataform.Timing
         * @instance
         */
        Timing.prototype.endTimeMillis = 0;

        /**
         * Creates a new Timing instance using the specified properties.
         * @function create
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming=} [properties] Properties to set
         * @returns {dataform.Timing} Timing instance
         */
        Timing.create = function create(properties) {
            return new Timing(properties);
        };

        /**
         * Encodes the specified Timing message. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encode
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTimeMillis != null && Object.hasOwnProperty.call(message, "startTimeMillis"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.startTimeMillis);
            if (message.endTimeMillis != null && Object.hasOwnProperty.call(message, "endTimeMillis"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endTimeMillis);
            return writer;
        };

        /**
         * Encodes the specified Timing message, length delimited. Does not implicitly {@link dataform.Timing.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {dataform.ITiming} message Timing message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Timing.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Timing message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Timing();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.startTimeMillis = reader.int64();
                        break;
                    }
                case 2: {
                        message.endTimeMillis = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Timing message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Timing
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Timing} Timing
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Timing.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Timing message.
         * @function verify
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Timing.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                    return "startTimeMillis: integer|Long expected";
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (!$util.isInteger(message.endTimeMillis) && !(message.endTimeMillis && $util.isInteger(message.endTimeMillis.low) && $util.isInteger(message.endTimeMillis.high)))
                    return "endTimeMillis: integer|Long expected";
            return null;
        };

        /**
         * Creates a Timing message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Timing
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Timing} Timing
         */
        Timing.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Timing)
                return object;
            let message = new $root.dataform.Timing();
            if (object.startTimeMillis != null)
                if ($util.Long)
                    (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                else if (typeof object.startTimeMillis === "string")
                    message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                else if (typeof object.startTimeMillis === "number")
                    message.startTimeMillis = object.startTimeMillis;
                else if (typeof object.startTimeMillis === "object")
                    message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
            if (object.endTimeMillis != null)
                if ($util.Long)
                    (message.endTimeMillis = $util.Long.fromValue(object.endTimeMillis)).unsigned = false;
                else if (typeof object.endTimeMillis === "string")
                    message.endTimeMillis = parseInt(object.endTimeMillis, 10);
                else if (typeof object.endTimeMillis === "number")
                    message.endTimeMillis = object.endTimeMillis;
                else if (typeof object.endTimeMillis === "object")
                    message.endTimeMillis = new $util.LongBits(object.endTimeMillis.low >>> 0, object.endTimeMillis.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Timing message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Timing
         * @static
         * @param {dataform.Timing} message Timing
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Timing.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.startTimeMillis = 0;
                object.endTimeMillis = 0;
            }
            if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                if (typeof message.startTimeMillis === "number")
                    object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                else
                    object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
            if (message.endTimeMillis != null && message.hasOwnProperty("endTimeMillis"))
                if (typeof message.endTimeMillis === "number")
                    object.endTimeMillis = options.longs === String ? String(message.endTimeMillis) : message.endTimeMillis;
                else
                    object.endTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeMillis) : options.longs === Number ? new $util.LongBits(message.endTimeMillis.low >>> 0, message.endTimeMillis.high >>> 0).toNumber() : message.endTimeMillis;
            return object;
        };

        /**
         * Converts this Timing to JSON.
         * @function toJSON
         * @memberof dataform.Timing
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Timing.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Timing
         * @function getTypeUrl
         * @memberof dataform.Timing
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Timing.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Timing";
        };

        return Timing;
    })();

    dataform.RunResult = (function() {

        /**
         * Properties of a RunResult.
         * @memberof dataform
         * @interface IRunResult
         * @property {dataform.RunResult.ExecutionStatus|null} [status] RunResult status
         * @property {Array.<dataform.IActionResult>|null} [actions] RunResult actions
         * @property {dataform.ITiming|null} [timing] RunResult timing
         */

        /**
         * Constructs a new RunResult.
         * @memberof dataform
         * @classdesc Represents a RunResult.
         * @implements IRunResult
         * @constructor
         * @param {dataform.IRunResult=} [properties] Properties to set
         */
        function RunResult(properties) {
            this.actions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RunResult status.
         * @member {dataform.RunResult.ExecutionStatus} status
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.status = 0;

        /**
         * RunResult actions.
         * @member {Array.<dataform.IActionResult>} actions
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.actions = $util.emptyArray;

        /**
         * RunResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.RunResult
         * @instance
         */
        RunResult.prototype.timing = null;

        /**
         * Creates a new RunResult instance using the specified properties.
         * @function create
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult=} [properties] Properties to set
         * @returns {dataform.RunResult} RunResult instance
         */
        RunResult.create = function create(properties) {
            return new RunResult(properties);
        };

        /**
         * Encodes the specified RunResult message. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.actions != null && message.actions.length)
                for (let i = 0; i < message.actions.length; ++i)
                    $root.dataform.ActionResult.encode(message.actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RunResult message, length delimited. Does not implicitly {@link dataform.RunResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.IRunResult} message RunResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RunResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.RunResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.actions && message.actions.length))
                            message.actions = [];
                        message.actions.push($root.dataform.ActionResult.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RunResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.RunResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.RunResult} RunResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RunResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RunResult message.
         * @function verify
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RunResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (let i = 0; i < message.actions.length; ++i) {
                    let error = $root.dataform.ActionResult.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates a RunResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.RunResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.RunResult} RunResult
         */
        RunResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.RunResult)
                return object;
            let message = new $root.dataform.RunResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "CANCELLED":
            case 4:
                message.status = 4;
                break;
            case "TIMED_OUT":
            case 5:
                message.status = 5;
                break;
            }
            if (object.actions) {
                if (!Array.isArray(object.actions))
                    throw TypeError(".dataform.RunResult.actions: array expected");
                message.actions = [];
                for (let i = 0; i < object.actions.length; ++i) {
                    if (typeof object.actions[i] !== "object")
                        throw TypeError(".dataform.RunResult.actions: object expected");
                    message.actions[i] = $root.dataform.ActionResult.fromObject(object.actions[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.RunResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from a RunResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.RunResult
         * @static
         * @param {dataform.RunResult} message RunResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RunResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.actions = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.RunResult.ExecutionStatus[message.status] : message.status;
            if (message.actions && message.actions.length) {
                object.actions = [];
                for (let j = 0; j < message.actions.length; ++j)
                    object.actions[j] = $root.dataform.ActionResult.toObject(message.actions[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            return object;
        };

        /**
         * Converts this RunResult to JSON.
         * @function toJSON
         * @memberof dataform.RunResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RunResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RunResult
         * @function getTypeUrl
         * @memberof dataform.RunResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RunResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.RunResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.RunResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} CANCELLED=4 CANCELLED value
         * @property {number} TIMED_OUT=5 TIMED_OUT value
         */
        RunResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "CANCELLED"] = 4;
            values[valuesById[5] = "TIMED_OUT"] = 5;
            return values;
        })();

        return RunResult;
    })();

    dataform.ActionResult = (function() {

        /**
         * Properties of an ActionResult.
         * @memberof dataform
         * @interface IActionResult
         * @property {dataform.ITarget|null} [target] ActionResult target
         * @property {dataform.ActionResult.ExecutionStatus|null} [status] ActionResult status
         * @property {Array.<dataform.ITaskResult>|null} [tasks] ActionResult tasks
         * @property {dataform.ITiming|null} [timing] ActionResult timing
         */

        /**
         * Constructs a new ActionResult.
         * @memberof dataform
         * @classdesc Represents an ActionResult.
         * @implements IActionResult
         * @constructor
         * @param {dataform.IActionResult=} [properties] Properties to set
         */
        function ActionResult(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActionResult target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.target = null;

        /**
         * ActionResult status.
         * @member {dataform.ActionResult.ExecutionStatus} status
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.status = 0;

        /**
         * ActionResult tasks.
         * @member {Array.<dataform.ITaskResult>} tasks
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.tasks = $util.emptyArray;

        /**
         * ActionResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.ActionResult
         * @instance
         */
        ActionResult.prototype.timing = null;

        /**
         * Creates a new ActionResult instance using the specified properties.
         * @function create
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult=} [properties] Properties to set
         * @returns {dataform.ActionResult} ActionResult instance
         */
        ActionResult.create = function create(properties) {
            return new ActionResult(properties);
        };

        /**
         * Encodes the specified ActionResult message. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.dataform.TaskResult.encode(message.tasks[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ActionResult message, length delimited. Does not implicitly {@link dataform.ActionResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.IActionResult} message ActionResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActionResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ActionResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 5: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.dataform.TaskResult.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActionResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ActionResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ActionResult} ActionResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActionResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActionResult message.
         * @function verify
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActionResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.dataform.TaskResult.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            return null;
        };

        /**
         * Creates an ActionResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ActionResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ActionResult} ActionResult
         */
        ActionResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ActionResult)
                return object;
            let message = new $root.dataform.ActionResult();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.ActionResult.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "DISABLED":
            case 5:
                message.status = 5;
                break;
            case "CANCELLED":
            case 6:
                message.status = 6;
                break;
            }
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".dataform.ActionResult.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".dataform.ActionResult.tasks: object expected");
                    message.tasks[i] = $root.dataform.TaskResult.fromObject(object.tasks[i]);
                }
            }
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.ActionResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            return message;
        };

        /**
         * Creates a plain object from an ActionResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ActionResult
         * @static
         * @param {dataform.ActionResult} message ActionResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ActionResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.timing = null;
                object.target = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.ActionResult.ExecutionStatus[message.status] : message.status;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.dataform.TaskResult.toObject(message.tasks[j], options);
            }
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            return object;
        };

        /**
         * Converts this ActionResult to JSON.
         * @function toJSON
         * @memberof dataform.ActionResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ActionResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ActionResult
         * @function getTypeUrl
         * @memberof dataform.ActionResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ActionResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ActionResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.ActionResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} DISABLED=5 DISABLED value
         * @property {number} CANCELLED=6 CANCELLED value
         */
        ActionResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "DISABLED"] = 5;
            values[valuesById[6] = "CANCELLED"] = 6;
            return values;
        })();

        return ActionResult;
    })();

    dataform.ExecutionMetadata = (function() {

        /**
         * Properties of an ExecutionMetadata.
         * @memberof dataform
         * @interface IExecutionMetadata
         * @property {dataform.ExecutionMetadata.IBigqueryMetadata|null} [bigquery] ExecutionMetadata bigquery
         */

        /**
         * Constructs a new ExecutionMetadata.
         * @memberof dataform
         * @classdesc Represents an ExecutionMetadata.
         * @implements IExecutionMetadata
         * @constructor
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         */
        function ExecutionMetadata(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutionMetadata bigquery.
         * @member {dataform.ExecutionMetadata.IBigqueryMetadata|null|undefined} bigquery
         * @memberof dataform.ExecutionMetadata
         * @instance
         */
        ExecutionMetadata.prototype.bigquery = null;

        /**
         * Creates a new ExecutionMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata=} [properties] Properties to set
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata instance
         */
        ExecutionMetadata.create = function create(properties) {
            return new ExecutionMetadata(properties);
        };

        /**
         * Encodes the specified ExecutionMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.ExecutionMetadata.BigqueryMetadata.encode(message.bigquery, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExecutionMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.IExecutionMetadata} message ExecutionMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutionMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutionMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutionMetadata message.
         * @function verify
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutionMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.ExecutionMetadata.BigqueryMetadata.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates an ExecutionMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.ExecutionMetadata} ExecutionMetadata
         */
        ExecutionMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.ExecutionMetadata)
                return object;
            let message = new $root.dataform.ExecutionMetadata();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.ExecutionMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExecutionMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {dataform.ExecutionMetadata} message ExecutionMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExecutionMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.bigquery = null;
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.ExecutionMetadata.BigqueryMetadata.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this ExecutionMetadata to JSON.
         * @function toJSON
         * @memberof dataform.ExecutionMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExecutionMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ExecutionMetadata
         * @function getTypeUrl
         * @memberof dataform.ExecutionMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ExecutionMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.ExecutionMetadata";
        };

        ExecutionMetadata.BigqueryMetadata = (function() {

            /**
             * Properties of a BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @interface IBigqueryMetadata
             * @property {string|null} [jobId] BigqueryMetadata jobId
             * @property {Long|null} [totalBytesProcessed] BigqueryMetadata totalBytesProcessed
             * @property {Long|null} [totalBytesBilled] BigqueryMetadata totalBytesBilled
             */

            /**
             * Constructs a new BigqueryMetadata.
             * @memberof dataform.ExecutionMetadata
             * @classdesc Represents a BigqueryMetadata.
             * @implements IBigqueryMetadata
             * @constructor
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             */
            function BigqueryMetadata(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigqueryMetadata jobId.
             * @member {string} jobId
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.jobId = "";

            /**
             * BigqueryMetadata totalBytesProcessed.
             * @member {Long} totalBytesProcessed
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesProcessed = 0;

            /**
             * BigqueryMetadata totalBytesBilled.
             * @member {Long} totalBytesBilled
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             */
            BigqueryMetadata.prototype.totalBytesBilled = 0;

            /**
             * Creates a new BigqueryMetadata instance using the specified properties.
             * @function create
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata=} [properties] Properties to set
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata instance
             */
            BigqueryMetadata.create = function create(properties) {
                return new BigqueryMetadata(properties);
            };

            /**
             * Encodes the specified BigqueryMetadata message. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.jobId != null && Object.hasOwnProperty.call(message, "jobId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.jobId);
                if (message.totalBytesProcessed != null && Object.hasOwnProperty.call(message, "totalBytesProcessed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalBytesProcessed);
                if (message.totalBytesBilled != null && Object.hasOwnProperty.call(message, "totalBytesBilled"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalBytesBilled);
                return writer;
            };

            /**
             * Encodes the specified BigqueryMetadata message, length delimited. Does not implicitly {@link dataform.ExecutionMetadata.BigqueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.IBigqueryMetadata} message BigqueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigqueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.jobId = reader.string();
                            break;
                        }
                    case 2: {
                            message.totalBytesProcessed = reader.int64();
                            break;
                        }
                    case 3: {
                            message.totalBytesBilled = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigqueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigqueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigqueryMetadata message.
             * @function verify
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigqueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    if (!$util.isString(message.jobId))
                        return "jobId: string expected";
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (!$util.isInteger(message.totalBytesProcessed) && !(message.totalBytesProcessed && $util.isInteger(message.totalBytesProcessed.low) && $util.isInteger(message.totalBytesProcessed.high)))
                        return "totalBytesProcessed: integer|Long expected";
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (!$util.isInteger(message.totalBytesBilled) && !(message.totalBytesBilled && $util.isInteger(message.totalBytesBilled.low) && $util.isInteger(message.totalBytesBilled.high)))
                        return "totalBytesBilled: integer|Long expected";
                return null;
            };

            /**
             * Creates a BigqueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.ExecutionMetadata.BigqueryMetadata} BigqueryMetadata
             */
            BigqueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.ExecutionMetadata.BigqueryMetadata)
                    return object;
                let message = new $root.dataform.ExecutionMetadata.BigqueryMetadata();
                if (object.jobId != null)
                    message.jobId = String(object.jobId);
                if (object.totalBytesProcessed != null)
                    if ($util.Long)
                        (message.totalBytesProcessed = $util.Long.fromValue(object.totalBytesProcessed)).unsigned = false;
                    else if (typeof object.totalBytesProcessed === "string")
                        message.totalBytesProcessed = parseInt(object.totalBytesProcessed, 10);
                    else if (typeof object.totalBytesProcessed === "number")
                        message.totalBytesProcessed = object.totalBytesProcessed;
                    else if (typeof object.totalBytesProcessed === "object")
                        message.totalBytesProcessed = new $util.LongBits(object.totalBytesProcessed.low >>> 0, object.totalBytesProcessed.high >>> 0).toNumber();
                if (object.totalBytesBilled != null)
                    if ($util.Long)
                        (message.totalBytesBilled = $util.Long.fromValue(object.totalBytesBilled)).unsigned = false;
                    else if (typeof object.totalBytesBilled === "string")
                        message.totalBytesBilled = parseInt(object.totalBytesBilled, 10);
                    else if (typeof object.totalBytesBilled === "number")
                        message.totalBytesBilled = object.totalBytesBilled;
                    else if (typeof object.totalBytesBilled === "object")
                        message.totalBytesBilled = new $util.LongBits(object.totalBytesBilled.low >>> 0, object.totalBytesBilled.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a BigqueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {dataform.ExecutionMetadata.BigqueryMetadata} message BigqueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigqueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.jobId = "";
                    object.totalBytesProcessed = 0;
                    object.totalBytesBilled = 0;
                }
                if (message.jobId != null && message.hasOwnProperty("jobId"))
                    object.jobId = message.jobId;
                if (message.totalBytesProcessed != null && message.hasOwnProperty("totalBytesProcessed"))
                    if (typeof message.totalBytesProcessed === "number")
                        object.totalBytesProcessed = options.longs === String ? String(message.totalBytesProcessed) : message.totalBytesProcessed;
                    else
                        object.totalBytesProcessed = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesProcessed) : options.longs === Number ? new $util.LongBits(message.totalBytesProcessed.low >>> 0, message.totalBytesProcessed.high >>> 0).toNumber() : message.totalBytesProcessed;
                if (message.totalBytesBilled != null && message.hasOwnProperty("totalBytesBilled"))
                    if (typeof message.totalBytesBilled === "number")
                        object.totalBytesBilled = options.longs === String ? String(message.totalBytesBilled) : message.totalBytesBilled;
                    else
                        object.totalBytesBilled = options.longs === String ? $util.Long.prototype.toString.call(message.totalBytesBilled) : options.longs === Number ? new $util.LongBits(message.totalBytesBilled.low >>> 0, message.totalBytesBilled.high >>> 0).toNumber() : message.totalBytesBilled;
                return object;
            };

            /**
             * Converts this BigqueryMetadata to JSON.
             * @function toJSON
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigqueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BigqueryMetadata
             * @function getTypeUrl
             * @memberof dataform.ExecutionMetadata.BigqueryMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BigqueryMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.ExecutionMetadata.BigqueryMetadata";
            };

            return BigqueryMetadata;
        })();

        return ExecutionMetadata;
    })();

    dataform.TaskResult = (function() {

        /**
         * Properties of a TaskResult.
         * @memberof dataform
         * @interface ITaskResult
         * @property {dataform.TaskResult.ExecutionStatus|null} [status] TaskResult status
         * @property {string|null} [errorMessage] TaskResult errorMessage
         * @property {dataform.ITiming|null} [timing] TaskResult timing
         * @property {dataform.IExecutionMetadata|null} [metadata] TaskResult metadata
         */

        /**
         * Constructs a new TaskResult.
         * @memberof dataform
         * @classdesc Represents a TaskResult.
         * @implements ITaskResult
         * @constructor
         * @param {dataform.ITaskResult=} [properties] Properties to set
         */
        function TaskResult(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskResult status.
         * @member {dataform.TaskResult.ExecutionStatus} status
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.status = 0;

        /**
         * TaskResult errorMessage.
         * @member {string} errorMessage
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.errorMessage = "";

        /**
         * TaskResult timing.
         * @member {dataform.ITiming|null|undefined} timing
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.timing = null;

        /**
         * TaskResult metadata.
         * @member {dataform.IExecutionMetadata|null|undefined} metadata
         * @memberof dataform.TaskResult
         * @instance
         */
        TaskResult.prototype.metadata = null;

        /**
         * Creates a new TaskResult instance using the specified properties.
         * @function create
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult=} [properties] Properties to set
         * @returns {dataform.TaskResult} TaskResult instance
         */
        TaskResult.create = function create(properties) {
            return new TaskResult(properties);
        };

        /**
         * Encodes the specified TaskResult message. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
            if (message.timing != null && Object.hasOwnProperty.call(message, "timing"))
                $root.dataform.Timing.encode(message.timing, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.metadata != null && Object.hasOwnProperty.call(message, "metadata"))
                $root.dataform.ExecutionMetadata.encode(message.metadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskResult message, length delimited. Does not implicitly {@link dataform.TaskResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.ITaskResult} message TaskResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TaskResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.errorMessage = reader.string();
                        break;
                    }
                case 3: {
                        message.timing = $root.dataform.Timing.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.metadata = $root.dataform.ExecutionMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TaskResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TaskResult} TaskResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskResult message.
         * @function verify
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                if (!$util.isString(message.errorMessage))
                    return "errorMessage: string expected";
            if (message.timing != null && message.hasOwnProperty("timing")) {
                let error = $root.dataform.Timing.verify(message.timing);
                if (error)
                    return "timing." + error;
            }
            if (message.metadata != null && message.hasOwnProperty("metadata")) {
                let error = $root.dataform.ExecutionMetadata.verify(message.metadata);
                if (error)
                    return "metadata." + error;
            }
            return null;
        };

        /**
         * Creates a TaskResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TaskResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TaskResult} TaskResult
         */
        TaskResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TaskResult)
                return object;
            let message = new $root.dataform.TaskResult();
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "RUNNING":
            case 1:
                message.status = 1;
                break;
            case "SUCCESSFUL":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            case "SKIPPED":
            case 4:
                message.status = 4;
                break;
            case "CANCELLED":
            case 5:
                message.status = 5;
                break;
            }
            if (object.errorMessage != null)
                message.errorMessage = String(object.errorMessage);
            if (object.timing != null) {
                if (typeof object.timing !== "object")
                    throw TypeError(".dataform.TaskResult.timing: object expected");
                message.timing = $root.dataform.Timing.fromObject(object.timing);
            }
            if (object.metadata != null) {
                if (typeof object.metadata !== "object")
                    throw TypeError(".dataform.TaskResult.metadata: object expected");
                message.metadata = $root.dataform.ExecutionMetadata.fromObject(object.metadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a TaskResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TaskResult
         * @static
         * @param {dataform.TaskResult} message TaskResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TaskResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.status = options.enums === String ? "UNKNOWN" : 0;
                object.errorMessage = "";
                object.timing = null;
                object.metadata = null;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.dataform.TaskResult.ExecutionStatus[message.status] : message.status;
            if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                object.errorMessage = message.errorMessage;
            if (message.timing != null && message.hasOwnProperty("timing"))
                object.timing = $root.dataform.Timing.toObject(message.timing, options);
            if (message.metadata != null && message.hasOwnProperty("metadata"))
                object.metadata = $root.dataform.ExecutionMetadata.toObject(message.metadata, options);
            return object;
        };

        /**
         * Converts this TaskResult to JSON.
         * @function toJSON
         * @memberof dataform.TaskResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TaskResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TaskResult
         * @function getTypeUrl
         * @memberof dataform.TaskResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TaskResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TaskResult";
        };

        /**
         * ExecutionStatus enum.
         * @name dataform.TaskResult.ExecutionStatus
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} RUNNING=1 RUNNING value
         * @property {number} SUCCESSFUL=2 SUCCESSFUL value
         * @property {number} FAILED=3 FAILED value
         * @property {number} SKIPPED=4 SKIPPED value
         * @property {number} CANCELLED=5 CANCELLED value
         */
        TaskResult.ExecutionStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "RUNNING"] = 1;
            values[valuesById[2] = "SUCCESSFUL"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            values[valuesById[4] = "SKIPPED"] = 4;
            values[valuesById[5] = "CANCELLED"] = 5;
            return values;
        })();

        return TaskResult;
    })();

    dataform.TestResult = (function() {

        /**
         * Properties of a TestResult.
         * @memberof dataform
         * @interface ITestResult
         * @property {string|null} [name] TestResult name
         * @property {boolean|null} [successful] TestResult successful
         * @property {Array.<string>|null} [messages] TestResult messages
         */

        /**
         * Constructs a new TestResult.
         * @memberof dataform
         * @classdesc Represents a TestResult.
         * @implements ITestResult
         * @constructor
         * @param {dataform.ITestResult=} [properties] Properties to set
         */
        function TestResult(properties) {
            this.messages = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TestResult name.
         * @member {string} name
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.name = "";

        /**
         * TestResult successful.
         * @member {boolean} successful
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.successful = false;

        /**
         * TestResult messages.
         * @member {Array.<string>} messages
         * @memberof dataform.TestResult
         * @instance
         */
        TestResult.prototype.messages = $util.emptyArray;

        /**
         * Creates a new TestResult instance using the specified properties.
         * @function create
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult=} [properties] Properties to set
         * @returns {dataform.TestResult} TestResult instance
         */
        TestResult.create = function create(properties) {
            return new TestResult(properties);
        };

        /**
         * Encodes the specified TestResult message. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encode
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.successful != null && Object.hasOwnProperty.call(message, "successful"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.successful);
            if (message.messages != null && message.messages.length)
                for (let i = 0; i < message.messages.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.messages[i]);
            return writer;
        };

        /**
         * Encodes the specified TestResult message, length delimited. Does not implicitly {@link dataform.TestResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.ITestResult} message TestResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TestResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TestResult();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.successful = reader.bool();
                        break;
                    }
                case 3: {
                        if (!(message.messages && message.messages.length))
                            message.messages = [];
                        message.messages.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TestResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TestResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TestResult} TestResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TestResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TestResult message.
         * @function verify
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TestResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.successful != null && message.hasOwnProperty("successful"))
                if (typeof message.successful !== "boolean")
                    return "successful: boolean expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (let i = 0; i < message.messages.length; ++i)
                    if (!$util.isString(message.messages[i]))
                        return "messages: string[] expected";
            }
            return null;
        };

        /**
         * Creates a TestResult message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TestResult
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TestResult} TestResult
         */
        TestResult.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TestResult)
                return object;
            let message = new $root.dataform.TestResult();
            if (object.name != null)
                message.name = String(object.name);
            if (object.successful != null)
                message.successful = Boolean(object.successful);
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".dataform.TestResult.messages: array expected");
                message.messages = [];
                for (let i = 0; i < object.messages.length; ++i)
                    message.messages[i] = String(object.messages[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a TestResult message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TestResult
         * @static
         * @param {dataform.TestResult} message TestResult
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TestResult.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.name = "";
                object.successful = false;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.successful != null && message.hasOwnProperty("successful"))
                object.successful = message.successful;
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (let j = 0; j < message.messages.length; ++j)
                    object.messages[j] = message.messages[j];
            }
            return object;
        };

        /**
         * Converts this TestResult to JSON.
         * @function toJSON
         * @memberof dataform.TestResult
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TestResult.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TestResult
         * @function getTypeUrl
         * @memberof dataform.TestResult
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TestResult.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TestResult";
        };

        return TestResult;
    })();

    dataform.Field = (function() {

        /**
         * Properties of a Field.
         * @memberof dataform
         * @interface IField
         * @property {string|null} [name] Field name
         * @property {Array.<dataform.Field.Flag>|null} [flags] Field flags
         * @property {dataform.Field.Primitive|null} [primitive] Field primitive
         * @property {dataform.IFields|null} [struct] Field struct
         * @property {string|null} [description] Field description
         */

        /**
         * Constructs a new Field.
         * @memberof dataform
         * @classdesc Represents a Field.
         * @implements IField
         * @constructor
         * @param {dataform.IField=} [properties] Properties to set
         */
        function Field(properties) {
            this.flags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Field name.
         * @member {string} name
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.name = "";

        /**
         * Field flags.
         * @member {Array.<dataform.Field.Flag>} flags
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.flags = $util.emptyArray;

        /**
         * Field primitive.
         * @member {dataform.Field.Primitive|null|undefined} primitive
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.primitive = null;

        /**
         * Field struct.
         * @member {dataform.IFields|null|undefined} struct
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.struct = null;

        /**
         * Field description.
         * @member {string} description
         * @memberof dataform.Field
         * @instance
         */
        Field.prototype.description = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Field type.
         * @member {"primitive"|"struct"|undefined} type
         * @memberof dataform.Field
         * @instance
         */
        Object.defineProperty(Field.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["primitive", "struct"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Field instance using the specified properties.
         * @function create
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField=} [properties] Properties to set
         * @returns {dataform.Field} Field instance
         */
        Field.create = function create(properties) {
            return new Field(properties);
        };

        /**
         * Encodes the specified Field message. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encode
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.struct != null && Object.hasOwnProperty.call(message, "struct"))
                $root.dataform.Fields.encode(message.struct, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.flags != null && message.flags.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (let i = 0; i < message.flags.length; ++i)
                    writer.int32(message.flags[i]);
                writer.ldelim();
            }
            if (message.primitive != null && Object.hasOwnProperty.call(message, "primitive"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.primitive);
            return writer;
        };

        /**
         * Encodes the specified Field message, length delimited. Does not implicitly {@link dataform.Field.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {dataform.IField} message Field message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Field.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Field message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Field();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 6: {
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.flags.push(reader.int32());
                        } else
                            message.flags.push(reader.int32());
                        break;
                    }
                case 7: {
                        message.primitive = reader.int32();
                        break;
                    }
                case 3: {
                        message.struct = $root.dataform.Fields.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.description = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Field message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Field
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Field} Field
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Field.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Field message.
         * @function verify
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Field.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i)
                    switch (message.flags[i]) {
                    default:
                        return "flags: enum value[] expected";
                    case 0:
                    case 1:
                        break;
                    }
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                properties.type = 1;
                switch (message.primitive) {
                default:
                    return "primitive: enum value expected";
                case 0:
                case 1:
                case 2:
                case 5:
                case 3:
                case 4:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                    break;
                }
            }
            if (message.struct != null && message.hasOwnProperty("struct")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.dataform.Fields.verify(message.struct);
                    if (error)
                        return "struct." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            return null;
        };

        /**
         * Creates a Field message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Field
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Field} Field
         */
        Field.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Field)
                return object;
            let message = new $root.dataform.Field();
            if (object.name != null)
                message.name = String(object.name);
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".dataform.Field.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i)
                    switch (object.flags[i]) {
                    default:
                    case "UNKNOWN_FLAG":
                    case 0:
                        message.flags[i] = 0;
                        break;
                    case "REPEATED":
                    case 1:
                        message.flags[i] = 1;
                        break;
                    }
            }
            switch (object.primitive) {
            case "UNKNOWN":
            case 0:
                message.primitive = 0;
                break;
            case "INTEGER":
            case 1:
                message.primitive = 1;
                break;
            case "FLOAT":
            case 2:
                message.primitive = 2;
                break;
            case "NUMERIC":
            case 5:
                message.primitive = 5;
                break;
            case "BOOLEAN":
            case 3:
                message.primitive = 3;
                break;
            case "STRING":
            case 4:
                message.primitive = 4;
                break;
            case "DATE":
            case 6:
                message.primitive = 6;
                break;
            case "DATETIME":
            case 7:
                message.primitive = 7;
                break;
            case "TIMESTAMP":
            case 8:
                message.primitive = 8;
                break;
            case "TIME":
            case 9:
                message.primitive = 9;
                break;
            case "BYTES":
            case 10:
                message.primitive = 10;
                break;
            case "ANY":
            case 11:
                message.primitive = 11;
                break;
            case "GEOGRAPHY":
            case 12:
                message.primitive = 12;
                break;
            }
            if (object.struct != null) {
                if (typeof object.struct !== "object")
                    throw TypeError(".dataform.Field.struct: object expected");
                message.struct = $root.dataform.Fields.fromObject(object.struct);
            }
            if (object.description != null)
                message.description = String(object.description);
            return message;
        };

        /**
         * Creates a plain object from a Field message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Field
         * @static
         * @param {dataform.Field} message Field
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Field.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.flags = [];
            if (options.defaults) {
                object.name = "";
                object.description = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.struct != null && message.hasOwnProperty("struct")) {
                object.struct = $root.dataform.Fields.toObject(message.struct, options);
                if (options.oneofs)
                    object.type = "struct";
            }
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = options.enums === String ? $root.dataform.Field.Flag[message.flags[j]] : message.flags[j];
            }
            if (message.primitive != null && message.hasOwnProperty("primitive")) {
                object.primitive = options.enums === String ? $root.dataform.Field.Primitive[message.primitive] : message.primitive;
                if (options.oneofs)
                    object.type = "primitive";
            }
            return object;
        };

        /**
         * Converts this Field to JSON.
         * @function toJSON
         * @memberof dataform.Field
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Field.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Field
         * @function getTypeUrl
         * @memberof dataform.Field
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Field.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Field";
        };

        /**
         * Primitive enum.
         * @name dataform.Field.Primitive
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} INTEGER=1 INTEGER value
         * @property {number} FLOAT=2 FLOAT value
         * @property {number} NUMERIC=5 NUMERIC value
         * @property {number} BOOLEAN=3 BOOLEAN value
         * @property {number} STRING=4 STRING value
         * @property {number} DATE=6 DATE value
         * @property {number} DATETIME=7 DATETIME value
         * @property {number} TIMESTAMP=8 TIMESTAMP value
         * @property {number} TIME=9 TIME value
         * @property {number} BYTES=10 BYTES value
         * @property {number} ANY=11 ANY value
         * @property {number} GEOGRAPHY=12 GEOGRAPHY value
         */
        Field.Primitive = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "INTEGER"] = 1;
            values[valuesById[2] = "FLOAT"] = 2;
            values[valuesById[5] = "NUMERIC"] = 5;
            values[valuesById[3] = "BOOLEAN"] = 3;
            values[valuesById[4] = "STRING"] = 4;
            values[valuesById[6] = "DATE"] = 6;
            values[valuesById[7] = "DATETIME"] = 7;
            values[valuesById[8] = "TIMESTAMP"] = 8;
            values[valuesById[9] = "TIME"] = 9;
            values[valuesById[10] = "BYTES"] = 10;
            values[valuesById[11] = "ANY"] = 11;
            values[valuesById[12] = "GEOGRAPHY"] = 12;
            return values;
        })();

        /**
         * Flag enum.
         * @name dataform.Field.Flag
         * @enum {number}
         * @property {number} UNKNOWN_FLAG=0 UNKNOWN_FLAG value
         * @property {number} REPEATED=1 REPEATED value
         */
        Field.Flag = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_FLAG"] = 0;
            values[valuesById[1] = "REPEATED"] = 1;
            return values;
        })();

        return Field;
    })();

    dataform.Fields = (function() {

        /**
         * Properties of a Fields.
         * @memberof dataform
         * @interface IFields
         * @property {Array.<dataform.IField>|null} [fields] Fields fields
         */

        /**
         * Constructs a new Fields.
         * @memberof dataform
         * @classdesc Represents a Fields.
         * @implements IFields
         * @constructor
         * @param {dataform.IFields=} [properties] Properties to set
         */
        function Fields(properties) {
            this.fields = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fields fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.Fields
         * @instance
         */
        Fields.prototype.fields = $util.emptyArray;

        /**
         * Creates a new Fields instance using the specified properties.
         * @function create
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields=} [properties] Properties to set
         * @returns {dataform.Fields} Fields instance
         */
        Fields.create = function create(properties) {
            return new Fields(properties);
        };

        /**
         * Encodes the specified Fields message. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encode
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Fields message, length delimited. Does not implicitly {@link dataform.Fields.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {dataform.IFields} message Fields message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fields.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fields message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Fields();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fields message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Fields
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Fields} Fields
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fields.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fields message.
         * @function verify
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fields.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Fields message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Fields
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Fields} Fields
         */
        Fields.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Fields)
                return object;
            let message = new $root.dataform.Fields();
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.Fields.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.Fields.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Fields message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Fields
         * @static
         * @param {dataform.Fields} message Fields
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fields.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            return object;
        };

        /**
         * Converts this Fields to JSON.
         * @function toJSON
         * @memberof dataform.Fields
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fields.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Fields
         * @function getTypeUrl
         * @memberof dataform.Fields
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Fields.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Fields";
        };

        return Fields;
    })();

    dataform.TableMetadata = (function() {

        /**
         * Properties of a TableMetadata.
         * @memberof dataform
         * @interface ITableMetadata
         * @property {dataform.ITarget|null} [target] TableMetadata target
         * @property {dataform.TableMetadata.Type|null} [type] TableMetadata type
         * @property {Array.<dataform.IField>|null} [fields] TableMetadata fields
         * @property {string|null} [description] TableMetadata description
         * @property {Object.<string,string>|null} [labels] TableMetadata labels
         * @property {Long|null} [lastUpdatedMillis] TableMetadata lastUpdatedMillis
         * @property {dataform.TableMetadata.IBigQuery|null} [bigquery] TableMetadata bigquery
         */

        /**
         * Constructs a new TableMetadata.
         * @memberof dataform
         * @classdesc Represents a TableMetadata.
         * @implements ITableMetadata
         * @constructor
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         */
        function TableMetadata(properties) {
            this.fields = [];
            this.labels = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TableMetadata target.
         * @member {dataform.ITarget|null|undefined} target
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.target = null;

        /**
         * TableMetadata type.
         * @member {dataform.TableMetadata.Type} type
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.type = 0;

        /**
         * TableMetadata fields.
         * @member {Array.<dataform.IField>} fields
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.fields = $util.emptyArray;

        /**
         * TableMetadata description.
         * @member {string} description
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.description = "";

        /**
         * TableMetadata labels.
         * @member {Object.<string,string>} labels
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.labels = $util.emptyObject;

        /**
         * TableMetadata lastUpdatedMillis.
         * @member {Long} lastUpdatedMillis
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.lastUpdatedMillis = 0;

        /**
         * TableMetadata bigquery.
         * @member {dataform.TableMetadata.IBigQuery|null|undefined} bigquery
         * @memberof dataform.TableMetadata
         * @instance
         */
        TableMetadata.prototype.bigquery = null;

        /**
         * Creates a new TableMetadata instance using the specified properties.
         * @function create
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata=} [properties] Properties to set
         * @returns {dataform.TableMetadata} TableMetadata instance
         */
        TableMetadata.create = function create(properties) {
            return new TableMetadata(properties);
        };

        /**
         * Encodes the specified TableMetadata message. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encode
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                $root.dataform.Target.encode(message.target, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fields != null && message.fields.length)
                for (let i = 0; i < message.fields.length; ++i)
                    $root.dataform.Field.encode(message.fields[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.lastUpdatedMillis != null && Object.hasOwnProperty.call(message, "lastUpdatedMillis"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.lastUpdatedMillis);
            if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.labels != null && Object.hasOwnProperty.call(message, "labels"))
                for (let keys = Object.keys(message.labels), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.labels[keys[i]]).ldelim();
            if (message.bigquery != null && Object.hasOwnProperty.call(message, "bigquery"))
                $root.dataform.TableMetadata.BigQuery.encode(message.bigquery, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TableMetadata message, length delimited. Does not implicitly {@link dataform.TableMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.ITableMetadata} message TableMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TableMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata(), key, value;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.target = $root.dataform.Target.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.fields && message.fields.length))
                            message.fields = [];
                        message.fields.push($root.dataform.Field.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.description = reader.string();
                        break;
                    }
                case 7: {
                        if (message.labels === $util.emptyObject)
                            message.labels = {};
                        let end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = "";
                        while (reader.pos < end2) {
                            let tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = reader.string();
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.labels[key] = value;
                        break;
                    }
                case 4: {
                        message.lastUpdatedMillis = reader.int64();
                        break;
                    }
                case 8: {
                        message.bigquery = $root.dataform.TableMetadata.BigQuery.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TableMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.TableMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.TableMetadata} TableMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TableMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TableMetadata message.
         * @function verify
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TableMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.target != null && message.hasOwnProperty("target")) {
                let error = $root.dataform.Target.verify(message.target);
                if (error)
                    return "target." + error;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.fields != null && message.hasOwnProperty("fields")) {
                if (!Array.isArray(message.fields))
                    return "fields: array expected";
                for (let i = 0; i < message.fields.length; ++i) {
                    let error = $root.dataform.Field.verify(message.fields[i]);
                    if (error)
                        return "fields." + error;
                }
            }
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.labels != null && message.hasOwnProperty("labels")) {
                if (!$util.isObject(message.labels))
                    return "labels: object expected";
                let key = Object.keys(message.labels);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isString(message.labels[key[i]]))
                        return "labels: string{k:string} expected";
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (!$util.isInteger(message.lastUpdatedMillis) && !(message.lastUpdatedMillis && $util.isInteger(message.lastUpdatedMillis.low) && $util.isInteger(message.lastUpdatedMillis.high)))
                    return "lastUpdatedMillis: integer|Long expected";
            if (message.bigquery != null && message.hasOwnProperty("bigquery")) {
                let error = $root.dataform.TableMetadata.BigQuery.verify(message.bigquery);
                if (error)
                    return "bigquery." + error;
            }
            return null;
        };

        /**
         * Creates a TableMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.TableMetadata} TableMetadata
         */
        TableMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.TableMetadata)
                return object;
            let message = new $root.dataform.TableMetadata();
            if (object.target != null) {
                if (typeof object.target !== "object")
                    throw TypeError(".dataform.TableMetadata.target: object expected");
                message.target = $root.dataform.Target.fromObject(object.target);
            }
            switch (object.type) {
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TABLE":
            case 1:
                message.type = 1;
                break;
            case "VIEW":
            case 2:
                message.type = 2;
                break;
            }
            if (object.fields) {
                if (!Array.isArray(object.fields))
                    throw TypeError(".dataform.TableMetadata.fields: array expected");
                message.fields = [];
                for (let i = 0; i < object.fields.length; ++i) {
                    if (typeof object.fields[i] !== "object")
                        throw TypeError(".dataform.TableMetadata.fields: object expected");
                    message.fields[i] = $root.dataform.Field.fromObject(object.fields[i]);
                }
            }
            if (object.description != null)
                message.description = String(object.description);
            if (object.labels) {
                if (typeof object.labels !== "object")
                    throw TypeError(".dataform.TableMetadata.labels: object expected");
                message.labels = {};
                for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                    message.labels[keys[i]] = String(object.labels[keys[i]]);
            }
            if (object.lastUpdatedMillis != null)
                if ($util.Long)
                    (message.lastUpdatedMillis = $util.Long.fromValue(object.lastUpdatedMillis)).unsigned = false;
                else if (typeof object.lastUpdatedMillis === "string")
                    message.lastUpdatedMillis = parseInt(object.lastUpdatedMillis, 10);
                else if (typeof object.lastUpdatedMillis === "number")
                    message.lastUpdatedMillis = object.lastUpdatedMillis;
                else if (typeof object.lastUpdatedMillis === "object")
                    message.lastUpdatedMillis = new $util.LongBits(object.lastUpdatedMillis.low >>> 0, object.lastUpdatedMillis.high >>> 0).toNumber();
            if (object.bigquery != null) {
                if (typeof object.bigquery !== "object")
                    throw TypeError(".dataform.TableMetadata.bigquery: object expected");
                message.bigquery = $root.dataform.TableMetadata.BigQuery.fromObject(object.bigquery);
            }
            return message;
        };

        /**
         * Creates a plain object from a TableMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.TableMetadata
         * @static
         * @param {dataform.TableMetadata} message TableMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TableMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.fields = [];
            if (options.objects || options.defaults)
                object.labels = {};
            if (options.defaults) {
                object.target = null;
                object.lastUpdatedMillis = 0;
                object.description = "";
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.bigquery = null;
            }
            if (message.target != null && message.hasOwnProperty("target"))
                object.target = $root.dataform.Target.toObject(message.target, options);
            if (message.fields && message.fields.length) {
                object.fields = [];
                for (let j = 0; j < message.fields.length; ++j)
                    object.fields[j] = $root.dataform.Field.toObject(message.fields[j], options);
            }
            if (message.lastUpdatedMillis != null && message.hasOwnProperty("lastUpdatedMillis"))
                if (typeof message.lastUpdatedMillis === "number")
                    object.lastUpdatedMillis = options.longs === String ? String(message.lastUpdatedMillis) : message.lastUpdatedMillis;
                else
                    object.lastUpdatedMillis = options.longs === String ? $util.Long.prototype.toString.call(message.lastUpdatedMillis) : options.longs === Number ? new $util.LongBits(message.lastUpdatedMillis.low >>> 0, message.lastUpdatedMillis.high >>> 0).toNumber() : message.lastUpdatedMillis;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.dataform.TableMetadata.Type[message.type] : message.type;
            let keys2;
            if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                object.labels = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.labels[keys2[j]] = message.labels[keys2[j]];
            }
            if (message.bigquery != null && message.hasOwnProperty("bigquery"))
                object.bigquery = $root.dataform.TableMetadata.BigQuery.toObject(message.bigquery, options);
            return object;
        };

        /**
         * Converts this TableMetadata to JSON.
         * @function toJSON
         * @memberof dataform.TableMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TableMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TableMetadata
         * @function getTypeUrl
         * @memberof dataform.TableMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TableMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.TableMetadata";
        };

        /**
         * Type enum.
         * @name dataform.TableMetadata.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TABLE=1 TABLE value
         * @property {number} VIEW=2 VIEW value
         */
        TableMetadata.Type = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TABLE"] = 1;
            values[valuesById[2] = "VIEW"] = 2;
            return values;
        })();

        TableMetadata.BigQuery = (function() {

            /**
             * Properties of a BigQuery.
             * @memberof dataform.TableMetadata
             * @interface IBigQuery
             * @property {boolean|null} [hasStreamingBuffer] BigQuery hasStreamingBuffer
             */

            /**
             * Constructs a new BigQuery.
             * @memberof dataform.TableMetadata
             * @classdesc Represents a BigQuery.
             * @implements IBigQuery
             * @constructor
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             */
            function BigQuery(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BigQuery hasStreamingBuffer.
             * @member {boolean} hasStreamingBuffer
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             */
            BigQuery.prototype.hasStreamingBuffer = false;

            /**
             * Creates a new BigQuery instance using the specified properties.
             * @function create
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery=} [properties] Properties to set
             * @returns {dataform.TableMetadata.BigQuery} BigQuery instance
             */
            BigQuery.create = function create(properties) {
                return new BigQuery(properties);
            };

            /**
             * Encodes the specified BigQuery message. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hasStreamingBuffer != null && Object.hasOwnProperty.call(message, "hasStreamingBuffer"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasStreamingBuffer);
                return writer;
            };

            /**
             * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.TableMetadata.BigQuery.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.IBigQuery} message BigQuery message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.TableMetadata.BigQuery();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.hasStreamingBuffer = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BigQuery message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BigQuery.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BigQuery message.
             * @function verify
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BigQuery.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    if (typeof message.hasStreamingBuffer !== "boolean")
                        return "hasStreamingBuffer: boolean expected";
                return null;
            };

            /**
             * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.TableMetadata.BigQuery} BigQuery
             */
            BigQuery.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.TableMetadata.BigQuery)
                    return object;
                let message = new $root.dataform.TableMetadata.BigQuery();
                if (object.hasStreamingBuffer != null)
                    message.hasStreamingBuffer = Boolean(object.hasStreamingBuffer);
                return message;
            };

            /**
             * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {dataform.TableMetadata.BigQuery} message BigQuery
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BigQuery.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hasStreamingBuffer = false;
                if (message.hasStreamingBuffer != null && message.hasOwnProperty("hasStreamingBuffer"))
                    object.hasStreamingBuffer = message.hasStreamingBuffer;
                return object;
            };

            /**
             * Converts this BigQuery to JSON.
             * @function toJSON
             * @memberof dataform.TableMetadata.BigQuery
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BigQuery.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BigQuery
             * @function getTypeUrl
             * @memberof dataform.TableMetadata.BigQuery
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BigQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.TableMetadata.BigQuery";
            };

            return BigQuery;
        })();

        return TableMetadata;
    })();

    dataform.JDBC = (function() {

        /**
         * Properties of a JDBC.
         * @memberof dataform
         * @interface IJDBC
         * @property {string|null} [host] JDBC host
         * @property {number|null} [port] JDBC port
         * @property {string|null} [username] JDBC username
         * @property {string|null} [password] JDBC password
         * @property {string|null} [databaseName] JDBC databaseName
         * @property {dataform.JDBC.ISslConfiguration|null} [ssl] JDBC ssl
         * @property {dataform.JDBC.ISshTunnel|null} [sshTunnel] JDBC sshTunnel
         */

        /**
         * Constructs a new JDBC.
         * @memberof dataform
         * @classdesc Represents a JDBC.
         * @implements IJDBC
         * @constructor
         * @param {dataform.IJDBC=} [properties] Properties to set
         */
        function JDBC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JDBC host.
         * @member {string} host
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.host = "";

        /**
         * JDBC port.
         * @member {number} port
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.port = 0;

        /**
         * JDBC username.
         * @member {string} username
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.username = "";

        /**
         * JDBC password.
         * @member {string} password
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.password = "";

        /**
         * JDBC databaseName.
         * @member {string} databaseName
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.databaseName = "";

        /**
         * JDBC ssl.
         * @member {dataform.JDBC.ISslConfiguration|null|undefined} ssl
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.ssl = null;

        /**
         * JDBC sshTunnel.
         * @member {dataform.JDBC.ISshTunnel|null|undefined} sshTunnel
         * @memberof dataform.JDBC
         * @instance
         */
        JDBC.prototype.sshTunnel = null;

        /**
         * Creates a new JDBC instance using the specified properties.
         * @function create
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC=} [properties] Properties to set
         * @returns {dataform.JDBC} JDBC instance
         */
        JDBC.create = function create(properties) {
            return new JDBC(properties);
        };

        /**
         * Encodes the specified JDBC message. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encode
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.username);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.databaseName != null && Object.hasOwnProperty.call(message, "databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.sshTunnel != null && Object.hasOwnProperty.call(message, "sshTunnel"))
                $root.dataform.JDBC.SshTunnel.encode(message.sshTunnel, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.ssl != null && Object.hasOwnProperty.call(message, "ssl"))
                $root.dataform.JDBC.SslConfiguration.encode(message.ssl, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JDBC message, length delimited. Does not implicitly {@link dataform.JDBC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.IJDBC} message JDBC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JDBC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.host = reader.string();
                        break;
                    }
                case 3: {
                        message.port = reader.int32();
                        break;
                    }
                case 4: {
                        message.username = reader.string();
                        break;
                    }
                case 5: {
                        message.password = reader.string();
                        break;
                    }
                case 6: {
                        message.databaseName = reader.string();
                        break;
                    }
                case 8: {
                        message.ssl = $root.dataform.JDBC.SslConfiguration.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.sshTunnel = $root.dataform.JDBC.SshTunnel.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JDBC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.JDBC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.JDBC} JDBC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JDBC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JDBC message.
         * @function verify
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JDBC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.ssl != null && message.hasOwnProperty("ssl")) {
                let error = $root.dataform.JDBC.SslConfiguration.verify(message.ssl);
                if (error)
                    return "ssl." + error;
            }
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel")) {
                let error = $root.dataform.JDBC.SshTunnel.verify(message.sshTunnel);
                if (error)
                    return "sshTunnel." + error;
            }
            return null;
        };

        /**
         * Creates a JDBC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.JDBC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.JDBC} JDBC
         */
        JDBC.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.JDBC)
                return object;
            let message = new $root.dataform.JDBC();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.ssl != null) {
                if (typeof object.ssl !== "object")
                    throw TypeError(".dataform.JDBC.ssl: object expected");
                message.ssl = $root.dataform.JDBC.SslConfiguration.fromObject(object.ssl);
            }
            if (object.sshTunnel != null) {
                if (typeof object.sshTunnel !== "object")
                    throw TypeError(".dataform.JDBC.sshTunnel: object expected");
                message.sshTunnel = $root.dataform.JDBC.SshTunnel.fromObject(object.sshTunnel);
            }
            return message;
        };

        /**
         * Creates a plain object from a JDBC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.JDBC
         * @static
         * @param {dataform.JDBC} message JDBC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        JDBC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.databaseName = "";
                object.sshTunnel = null;
                object.ssl = null;
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.sshTunnel != null && message.hasOwnProperty("sshTunnel"))
                object.sshTunnel = $root.dataform.JDBC.SshTunnel.toObject(message.sshTunnel, options);
            if (message.ssl != null && message.hasOwnProperty("ssl"))
                object.ssl = $root.dataform.JDBC.SslConfiguration.toObject(message.ssl, options);
            return object;
        };

        /**
         * Converts this JDBC to JSON.
         * @function toJSON
         * @memberof dataform.JDBC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        JDBC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for JDBC
         * @function getTypeUrl
         * @memberof dataform.JDBC
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        JDBC.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.JDBC";
        };

        JDBC.SslConfiguration = (function() {

            /**
             * Properties of a SslConfiguration.
             * @memberof dataform.JDBC
             * @interface ISslConfiguration
             * @property {string|null} [serverCertificate] SslConfiguration serverCertificate
             * @property {string|null} [clientCertificate] SslConfiguration clientCertificate
             * @property {string|null} [clientPrivateKey] SslConfiguration clientPrivateKey
             */

            /**
             * Constructs a new SslConfiguration.
             * @memberof dataform.JDBC
             * @classdesc Represents a SslConfiguration.
             * @implements ISslConfiguration
             * @constructor
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             */
            function SslConfiguration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SslConfiguration serverCertificate.
             * @member {string} serverCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.serverCertificate = "";

            /**
             * SslConfiguration clientCertificate.
             * @member {string} clientCertificate
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientCertificate = "";

            /**
             * SslConfiguration clientPrivateKey.
             * @member {string} clientPrivateKey
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             */
            SslConfiguration.prototype.clientPrivateKey = "";

            /**
             * Creates a new SslConfiguration instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration=} [properties] Properties to set
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration instance
             */
            SslConfiguration.create = function create(properties) {
                return new SslConfiguration(properties);
            };

            /**
             * Encodes the specified SslConfiguration message. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serverCertificate != null && Object.hasOwnProperty.call(message, "serverCertificate"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverCertificate);
                if (message.clientCertificate != null && Object.hasOwnProperty.call(message, "clientCertificate"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.clientCertificate);
                if (message.clientPrivateKey != null && Object.hasOwnProperty.call(message, "clientPrivateKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.clientPrivateKey);
                return writer;
            };

            /**
             * Encodes the specified SslConfiguration message, length delimited. Does not implicitly {@link dataform.JDBC.SslConfiguration.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.ISslConfiguration} message SslConfiguration message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SslConfiguration.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SslConfiguration();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.serverCertificate = reader.string();
                            break;
                        }
                    case 2: {
                            message.clientCertificate = reader.string();
                            break;
                        }
                    case 3: {
                            message.clientPrivateKey = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SslConfiguration message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SslConfiguration.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SslConfiguration message.
             * @function verify
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SslConfiguration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    if (!$util.isString(message.serverCertificate))
                        return "serverCertificate: string expected";
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    if (!$util.isString(message.clientCertificate))
                        return "clientCertificate: string expected";
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    if (!$util.isString(message.clientPrivateKey))
                        return "clientPrivateKey: string expected";
                return null;
            };

            /**
             * Creates a SslConfiguration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SslConfiguration} SslConfiguration
             */
            SslConfiguration.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SslConfiguration)
                    return object;
                let message = new $root.dataform.JDBC.SslConfiguration();
                if (object.serverCertificate != null)
                    message.serverCertificate = String(object.serverCertificate);
                if (object.clientCertificate != null)
                    message.clientCertificate = String(object.clientCertificate);
                if (object.clientPrivateKey != null)
                    message.clientPrivateKey = String(object.clientPrivateKey);
                return message;
            };

            /**
             * Creates a plain object from a SslConfiguration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {dataform.JDBC.SslConfiguration} message SslConfiguration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SslConfiguration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.serverCertificate = "";
                    object.clientCertificate = "";
                    object.clientPrivateKey = "";
                }
                if (message.serverCertificate != null && message.hasOwnProperty("serverCertificate"))
                    object.serverCertificate = message.serverCertificate;
                if (message.clientCertificate != null && message.hasOwnProperty("clientCertificate"))
                    object.clientCertificate = message.clientCertificate;
                if (message.clientPrivateKey != null && message.hasOwnProperty("clientPrivateKey"))
                    object.clientPrivateKey = message.clientPrivateKey;
                return object;
            };

            /**
             * Converts this SslConfiguration to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SslConfiguration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SslConfiguration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SslConfiguration
             * @function getTypeUrl
             * @memberof dataform.JDBC.SslConfiguration
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SslConfiguration.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.JDBC.SslConfiguration";
            };

            return SslConfiguration;
        })();

        JDBC.SshTunnel = (function() {

            /**
             * Properties of a SshTunnel.
             * @memberof dataform.JDBC
             * @interface ISshTunnel
             * @property {string|null} [privateKey] SshTunnel privateKey
             * @property {string|null} [username] SshTunnel username
             * @property {string|null} [password] SshTunnel password
             * @property {string|null} [host] SshTunnel host
             * @property {number|null} [port] SshTunnel port
             */

            /**
             * Constructs a new SshTunnel.
             * @memberof dataform.JDBC
             * @classdesc Represents a SshTunnel.
             * @implements ISshTunnel
             * @constructor
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             */
            function SshTunnel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SshTunnel privateKey.
             * @member {string} privateKey
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.privateKey = "";

            /**
             * SshTunnel username.
             * @member {string} username
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.username = "";

            /**
             * SshTunnel password.
             * @member {string} password
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.password = "";

            /**
             * SshTunnel host.
             * @member {string} host
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.host = "";

            /**
             * SshTunnel port.
             * @member {number} port
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             */
            SshTunnel.prototype.port = 0;

            /**
             * Creates a new SshTunnel instance using the specified properties.
             * @function create
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel=} [properties] Properties to set
             * @returns {dataform.JDBC.SshTunnel} SshTunnel instance
             */
            SshTunnel.create = function create(properties) {
                return new SshTunnel(properties);
            };

            /**
             * Encodes the specified SshTunnel message. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.privateKey);
                if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
                if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);
                if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.host);
                if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.port);
                return writer;
            };

            /**
             * Encodes the specified SshTunnel message, length delimited. Does not implicitly {@link dataform.JDBC.SshTunnel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.ISshTunnel} message SshTunnel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SshTunnel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.JDBC.SshTunnel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.privateKey = reader.string();
                            break;
                        }
                    case 2: {
                            message.username = reader.string();
                            break;
                        }
                    case 3: {
                            message.password = reader.string();
                            break;
                        }
                    case 4: {
                            message.host = reader.string();
                            break;
                        }
                    case 5: {
                            message.port = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SshTunnel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SshTunnel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SshTunnel message.
             * @function verify
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SshTunnel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    if (!$util.isString(message.privateKey))
                        return "privateKey: string expected";
                if (message.username != null && message.hasOwnProperty("username"))
                    if (!$util.isString(message.username))
                        return "username: string expected";
                if (message.password != null && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.host != null && message.hasOwnProperty("host"))
                    if (!$util.isString(message.host))
                        return "host: string expected";
                if (message.port != null && message.hasOwnProperty("port"))
                    if (!$util.isInteger(message.port))
                        return "port: integer expected";
                return null;
            };

            /**
             * Creates a SshTunnel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.JDBC.SshTunnel} SshTunnel
             */
            SshTunnel.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.JDBC.SshTunnel)
                    return object;
                let message = new $root.dataform.JDBC.SshTunnel();
                if (object.privateKey != null)
                    message.privateKey = String(object.privateKey);
                if (object.username != null)
                    message.username = String(object.username);
                if (object.password != null)
                    message.password = String(object.password);
                if (object.host != null)
                    message.host = String(object.host);
                if (object.port != null)
                    message.port = object.port | 0;
                return message;
            };

            /**
             * Creates a plain object from a SshTunnel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {dataform.JDBC.SshTunnel} message SshTunnel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SshTunnel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.privateKey = "";
                    object.username = "";
                    object.password = "";
                    object.host = "";
                    object.port = 0;
                }
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = message.privateKey;
                if (message.username != null && message.hasOwnProperty("username"))
                    object.username = message.username;
                if (message.password != null && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.host != null && message.hasOwnProperty("host"))
                    object.host = message.host;
                if (message.port != null && message.hasOwnProperty("port"))
                    object.port = message.port;
                return object;
            };

            /**
             * Converts this SshTunnel to JSON.
             * @function toJSON
             * @memberof dataform.JDBC.SshTunnel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SshTunnel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SshTunnel
             * @function getTypeUrl
             * @memberof dataform.JDBC.SshTunnel
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SshTunnel.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.JDBC.SshTunnel";
            };

            return SshTunnel;
        })();

        return JDBC;
    })();

    dataform.Snowflake = (function() {

        /**
         * Properties of a Snowflake.
         * @memberof dataform
         * @interface ISnowflake
         * @property {string|null} [accountId] Snowflake accountId
         * @property {string|null} [username] Snowflake username
         * @property {string|null} [password] Snowflake password
         * @property {string|null} [role] Snowflake role
         * @property {string|null} [databaseName] Snowflake databaseName
         * @property {string|null} [warehouse] Snowflake warehouse
         */

        /**
         * Constructs a new Snowflake.
         * @memberof dataform
         * @classdesc Represents a Snowflake.
         * @implements ISnowflake
         * @constructor
         * @param {dataform.ISnowflake=} [properties] Properties to set
         */
        function Snowflake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Snowflake accountId.
         * @member {string} accountId
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.accountId = "";

        /**
         * Snowflake username.
         * @member {string} username
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.username = "";

        /**
         * Snowflake password.
         * @member {string} password
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.password = "";

        /**
         * Snowflake role.
         * @member {string} role
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.role = "";

        /**
         * Snowflake databaseName.
         * @member {string} databaseName
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.databaseName = "";

        /**
         * Snowflake warehouse.
         * @member {string} warehouse
         * @memberof dataform.Snowflake
         * @instance
         */
        Snowflake.prototype.warehouse = "";

        /**
         * Creates a new Snowflake instance using the specified properties.
         * @function create
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake=} [properties] Properties to set
         * @returns {dataform.Snowflake} Snowflake instance
         */
        Snowflake.create = function create(properties) {
            return new Snowflake(properties);
        };

        /**
         * Encodes the specified Snowflake message. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encode
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountId);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.role);
            if (message.databaseName != null && Object.hasOwnProperty.call(message, "databaseName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.databaseName);
            if (message.warehouse != null && Object.hasOwnProperty.call(message, "warehouse"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.warehouse);
            return writer;
        };

        /**
         * Encodes the specified Snowflake message, length delimited. Does not implicitly {@link dataform.Snowflake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.ISnowflake} message Snowflake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Snowflake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Snowflake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.accountId = reader.string();
                        break;
                    }
                case 3: {
                        message.username = reader.string();
                        break;
                    }
                case 4: {
                        message.password = reader.string();
                        break;
                    }
                case 5: {
                        message.role = reader.string();
                        break;
                    }
                case 6: {
                        message.databaseName = reader.string();
                        break;
                    }
                case 7: {
                        message.warehouse = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Snowflake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Snowflake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Snowflake} Snowflake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Snowflake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Snowflake message.
         * @function verify
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Snowflake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                if (!$util.isString(message.accountId))
                    return "accountId: string expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isString(message.role))
                    return "role: string expected";
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                if (!$util.isString(message.databaseName))
                    return "databaseName: string expected";
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                if (!$util.isString(message.warehouse))
                    return "warehouse: string expected";
            return null;
        };

        /**
         * Creates a Snowflake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Snowflake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Snowflake} Snowflake
         */
        Snowflake.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Snowflake)
                return object;
            let message = new $root.dataform.Snowflake();
            if (object.accountId != null)
                message.accountId = String(object.accountId);
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.role != null)
                message.role = String(object.role);
            if (object.databaseName != null)
                message.databaseName = String(object.databaseName);
            if (object.warehouse != null)
                message.warehouse = String(object.warehouse);
            return message;
        };

        /**
         * Creates a plain object from a Snowflake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Snowflake
         * @static
         * @param {dataform.Snowflake} message Snowflake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Snowflake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.accountId = "";
                object.username = "";
                object.password = "";
                object.role = "";
                object.databaseName = "";
                object.warehouse = "";
            }
            if (message.accountId != null && message.hasOwnProperty("accountId"))
                object.accountId = message.accountId;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.databaseName != null && message.hasOwnProperty("databaseName"))
                object.databaseName = message.databaseName;
            if (message.warehouse != null && message.hasOwnProperty("warehouse"))
                object.warehouse = message.warehouse;
            return object;
        };

        /**
         * Converts this Snowflake to JSON.
         * @function toJSON
         * @memberof dataform.Snowflake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Snowflake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Snowflake
         * @function getTypeUrl
         * @memberof dataform.Snowflake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Snowflake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Snowflake";
        };

        return Snowflake;
    })();

    dataform.BigQuery = (function() {

        /**
         * Properties of a BigQuery.
         * @memberof dataform
         * @interface IBigQuery
         * @property {string|null} [projectId] BigQuery projectId
         * @property {string|null} [credentials] BigQuery credentials
         * @property {string|null} [location] BigQuery location
         */

        /**
         * Constructs a new BigQuery.
         * @memberof dataform
         * @classdesc Represents a BigQuery.
         * @implements IBigQuery
         * @constructor
         * @param {dataform.IBigQuery=} [properties] Properties to set
         */
        function BigQuery(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BigQuery projectId.
         * @member {string} projectId
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.projectId = "";

        /**
         * BigQuery credentials.
         * @member {string} credentials
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.credentials = "";

        /**
         * BigQuery location.
         * @member {string} location
         * @memberof dataform.BigQuery
         * @instance
         */
        BigQuery.prototype.location = "";

        /**
         * Creates a new BigQuery instance using the specified properties.
         * @function create
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery=} [properties] Properties to set
         * @returns {dataform.BigQuery} BigQuery instance
         */
        BigQuery.create = function create(properties) {
            return new BigQuery(properties);
        };

        /**
         * Encodes the specified BigQuery message. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encode
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.projectId != null && Object.hasOwnProperty.call(message, "projectId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectId);
            if (message.credentials != null && Object.hasOwnProperty.call(message, "credentials"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.credentials);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            return writer;
        };

        /**
         * Encodes the specified BigQuery message, length delimited. Does not implicitly {@link dataform.BigQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.IBigQuery} message BigQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BigQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.BigQuery();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.projectId = reader.string();
                        break;
                    }
                case 3: {
                        message.credentials = reader.string();
                        break;
                    }
                case 4: {
                        message.location = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BigQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.BigQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.BigQuery} BigQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BigQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BigQuery message.
         * @function verify
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BigQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                if (!$util.isString(message.projectId))
                    return "projectId: string expected";
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                if (!$util.isString(message.credentials))
                    return "credentials: string expected";
            if (message.location != null && message.hasOwnProperty("location"))
                if (!$util.isString(message.location))
                    return "location: string expected";
            return null;
        };

        /**
         * Creates a BigQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.BigQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.BigQuery} BigQuery
         */
        BigQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.BigQuery)
                return object;
            let message = new $root.dataform.BigQuery();
            if (object.projectId != null)
                message.projectId = String(object.projectId);
            if (object.credentials != null)
                message.credentials = String(object.credentials);
            if (object.location != null)
                message.location = String(object.location);
            return message;
        };

        /**
         * Creates a plain object from a BigQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.BigQuery
         * @static
         * @param {dataform.BigQuery} message BigQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BigQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.projectId = "";
                object.credentials = "";
                object.location = "";
            }
            if (message.projectId != null && message.hasOwnProperty("projectId"))
                object.projectId = message.projectId;
            if (message.credentials != null && message.hasOwnProperty("credentials"))
                object.credentials = message.credentials;
            if (message.location != null && message.hasOwnProperty("location"))
                object.location = message.location;
            return object;
        };

        /**
         * Converts this BigQuery to JSON.
         * @function toJSON
         * @memberof dataform.BigQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BigQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BigQuery
         * @function getTypeUrl
         * @memberof dataform.BigQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BigQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.BigQuery";
        };

        return BigQuery;
    })();

    dataform.SQLDataWarehouse = (function() {

        /**
         * Properties of a SQLDataWarehouse.
         * @memberof dataform
         * @interface ISQLDataWarehouse
         * @property {string|null} [server] SQLDataWarehouse server
         * @property {number|null} [port] SQLDataWarehouse port
         * @property {string|null} [username] SQLDataWarehouse username
         * @property {string|null} [password] SQLDataWarehouse password
         * @property {string|null} [database] SQLDataWarehouse database
         */

        /**
         * Constructs a new SQLDataWarehouse.
         * @memberof dataform
         * @classdesc Represents a SQLDataWarehouse.
         * @implements ISQLDataWarehouse
         * @constructor
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         */
        function SQLDataWarehouse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SQLDataWarehouse server.
         * @member {string} server
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.server = "";

        /**
         * SQLDataWarehouse port.
         * @member {number} port
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.port = 0;

        /**
         * SQLDataWarehouse username.
         * @member {string} username
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.username = "";

        /**
         * SQLDataWarehouse password.
         * @member {string} password
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.password = "";

        /**
         * SQLDataWarehouse database.
         * @member {string} database
         * @memberof dataform.SQLDataWarehouse
         * @instance
         */
        SQLDataWarehouse.prototype.database = "";

        /**
         * Creates a new SQLDataWarehouse instance using the specified properties.
         * @function create
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse=} [properties] Properties to set
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse instance
         */
        SQLDataWarehouse.create = function create(properties) {
            return new SQLDataWarehouse(properties);
        };

        /**
         * Encodes the specified SQLDataWarehouse message. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.server != null && Object.hasOwnProperty.call(message, "server"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.server);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.username != null && Object.hasOwnProperty.call(message, "username"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.username);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.database != null && Object.hasOwnProperty.call(message, "database"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.database);
            return writer;
        };

        /**
         * Encodes the specified SQLDataWarehouse message, length delimited. Does not implicitly {@link dataform.SQLDataWarehouse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.ISQLDataWarehouse} message SQLDataWarehouse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SQLDataWarehouse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.SQLDataWarehouse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.server = reader.string();
                        break;
                    }
                case 2: {
                        message.port = reader.int32();
                        break;
                    }
                case 3: {
                        message.username = reader.string();
                        break;
                    }
                case 4: {
                        message.password = reader.string();
                        break;
                    }
                case 5: {
                        message.database = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SQLDataWarehouse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SQLDataWarehouse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SQLDataWarehouse message.
         * @function verify
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SQLDataWarehouse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.server != null && message.hasOwnProperty("server"))
                if (!$util.isString(message.server))
                    return "server: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.username != null && message.hasOwnProperty("username"))
                if (!$util.isString(message.username))
                    return "username: string expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.database != null && message.hasOwnProperty("database"))
                if (!$util.isString(message.database))
                    return "database: string expected";
            return null;
        };

        /**
         * Creates a SQLDataWarehouse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.SQLDataWarehouse} SQLDataWarehouse
         */
        SQLDataWarehouse.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.SQLDataWarehouse)
                return object;
            let message = new $root.dataform.SQLDataWarehouse();
            if (object.server != null)
                message.server = String(object.server);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.username != null)
                message.username = String(object.username);
            if (object.password != null)
                message.password = String(object.password);
            if (object.database != null)
                message.database = String(object.database);
            return message;
        };

        /**
         * Creates a plain object from a SQLDataWarehouse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {dataform.SQLDataWarehouse} message SQLDataWarehouse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SQLDataWarehouse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.server = "";
                object.port = 0;
                object.username = "";
                object.password = "";
                object.database = "";
            }
            if (message.server != null && message.hasOwnProperty("server"))
                object.server = message.server;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.username != null && message.hasOwnProperty("username"))
                object.username = message.username;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.database != null && message.hasOwnProperty("database"))
                object.database = message.database;
            return object;
        };

        /**
         * Converts this SQLDataWarehouse to JSON.
         * @function toJSON
         * @memberof dataform.SQLDataWarehouse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SQLDataWarehouse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SQLDataWarehouse
         * @function getTypeUrl
         * @memberof dataform.SQLDataWarehouse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SQLDataWarehouse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.SQLDataWarehouse";
        };

        return SQLDataWarehouse;
    })();

    dataform.Presto = (function() {

        /**
         * Properties of a Presto.
         * @memberof dataform
         * @interface IPresto
         * @property {string|null} [host] Presto host
         * @property {number|null} [port] Presto port
         * @property {string|null} [user] Presto user
         * @property {string|null} [catalog] Presto catalog
         * @property {string|null} [schema] Presto schema
         */

        /**
         * Constructs a new Presto.
         * @memberof dataform
         * @classdesc Represents a Presto.
         * @implements IPresto
         * @constructor
         * @param {dataform.IPresto=} [properties] Properties to set
         */
        function Presto(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Presto host.
         * @member {string} host
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.host = "";

        /**
         * Presto port.
         * @member {number} port
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.port = 0;

        /**
         * Presto user.
         * @member {string} user
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.user = "";

        /**
         * Presto catalog.
         * @member {string} catalog
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.catalog = "";

        /**
         * Presto schema.
         * @member {string} schema
         * @memberof dataform.Presto
         * @instance
         */
        Presto.prototype.schema = "";

        /**
         * Creates a new Presto instance using the specified properties.
         * @function create
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto=} [properties] Properties to set
         * @returns {dataform.Presto} Presto instance
         */
        Presto.create = function create(properties) {
            return new Presto(properties);
        };

        /**
         * Encodes the specified Presto message. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encode
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.host != null && Object.hasOwnProperty.call(message, "host"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.host);
            if (message.port != null && Object.hasOwnProperty.call(message, "port"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.user);
            if (message.catalog != null && Object.hasOwnProperty.call(message, "catalog"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.catalog);
            if (message.schema != null && Object.hasOwnProperty.call(message, "schema"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.schema);
            return writer;
        };

        /**
         * Encodes the specified Presto message, length delimited. Does not implicitly {@link dataform.Presto.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {dataform.IPresto} message Presto message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Presto.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Presto message from the specified reader or buffer.
         * @function decode
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.Presto();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.host = reader.string();
                        break;
                    }
                case 2: {
                        message.port = reader.int32();
                        break;
                    }
                case 3: {
                        message.user = reader.string();
                        break;
                    }
                case 4: {
                        message.catalog = reader.string();
                        break;
                    }
                case 5: {
                        message.schema = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Presto message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dataform.Presto
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dataform.Presto} Presto
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Presto.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Presto message.
         * @function verify
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Presto.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            if (message.port != null && message.hasOwnProperty("port"))
                if (!$util.isInteger(message.port))
                    return "port: integer expected";
            if (message.user != null && message.hasOwnProperty("user"))
                if (!$util.isString(message.user))
                    return "user: string expected";
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                if (!$util.isString(message.catalog))
                    return "catalog: string expected";
            if (message.schema != null && message.hasOwnProperty("schema"))
                if (!$util.isString(message.schema))
                    return "schema: string expected";
            return null;
        };

        /**
         * Creates a Presto message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dataform.Presto
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dataform.Presto} Presto
         */
        Presto.fromObject = function fromObject(object) {
            if (object instanceof $root.dataform.Presto)
                return object;
            let message = new $root.dataform.Presto();
            if (object.host != null)
                message.host = String(object.host);
            if (object.port != null)
                message.port = object.port | 0;
            if (object.user != null)
                message.user = String(object.user);
            if (object.catalog != null)
                message.catalog = String(object.catalog);
            if (object.schema != null)
                message.schema = String(object.schema);
            return message;
        };

        /**
         * Creates a plain object from a Presto message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dataform.Presto
         * @static
         * @param {dataform.Presto} message Presto
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Presto.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.host = "";
                object.port = 0;
                object.user = "";
                object.catalog = "";
                object.schema = "";
            }
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            if (message.port != null && message.hasOwnProperty("port"))
                object.port = message.port;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = message.user;
            if (message.catalog != null && message.hasOwnProperty("catalog"))
                object.catalog = message.catalog;
            if (message.schema != null && message.hasOwnProperty("schema"))
                object.schema = message.schema;
            return object;
        };

        /**
         * Converts this Presto to JSON.
         * @function toJSON
         * @memberof dataform.Presto
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Presto.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Presto
         * @function getTypeUrl
         * @memberof dataform.Presto
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Presto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dataform.Presto";
        };

        return Presto;
    })();

    dataform.server = (function() {

        /**
         * Namespace server.
         * @memberof dataform
         * @namespace
         */
        const server = {};

        server.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof dataform.server
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof dataform.server
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty=} [properties] Properties to set
             * @returns {dataform.server.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link dataform.server.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.Empty();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.Empty)
                    return object;
                return new $root.dataform.server.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.Empty
             * @static
             * @param {dataform.server.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof dataform.server.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Empty
             * @function getTypeUrl
             * @memberof dataform.server.Empty
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Empty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.server.Empty";
            };

            return Empty;
        })();

        server.MetadataResponse = (function() {

            /**
             * Properties of a MetadataResponse.
             * @memberof dataform.server
             * @interface IMetadataResponse
             * @property {string|null} [projectDir] MetadataResponse projectDir
             */

            /**
             * Constructs a new MetadataResponse.
             * @memberof dataform.server
             * @classdesc Represents a MetadataResponse.
             * @implements IMetadataResponse
             * @constructor
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             */
            function MetadataResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MetadataResponse projectDir.
             * @member {string} projectDir
             * @memberof dataform.server.MetadataResponse
             * @instance
             */
            MetadataResponse.prototype.projectDir = "";

            /**
             * Creates a new MetadataResponse instance using the specified properties.
             * @function create
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse=} [properties] Properties to set
             * @returns {dataform.server.MetadataResponse} MetadataResponse instance
             */
            MetadataResponse.create = function create(properties) {
                return new MetadataResponse(properties);
            };

            /**
             * Encodes the specified MetadataResponse message. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.projectDir != null && Object.hasOwnProperty.call(message, "projectDir"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.projectDir);
                return writer;
            };

            /**
             * Encodes the specified MetadataResponse message, length delimited. Does not implicitly {@link dataform.server.MetadataResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.IMetadataResponse} message MetadataResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MetadataResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer.
             * @function decode
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.dataform.server.MetadataResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.projectDir = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MetadataResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MetadataResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MetadataResponse message.
             * @function verify
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MetadataResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    if (!$util.isString(message.projectDir))
                        return "projectDir: string expected";
                return null;
            };

            /**
             * Creates a MetadataResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {dataform.server.MetadataResponse} MetadataResponse
             */
            MetadataResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.dataform.server.MetadataResponse)
                    return object;
                let message = new $root.dataform.server.MetadataResponse();
                if (object.projectDir != null)
                    message.projectDir = String(object.projectDir);
                return message;
            };

            /**
             * Creates a plain object from a MetadataResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {dataform.server.MetadataResponse} message MetadataResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MetadataResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.projectDir = "";
                if (message.projectDir != null && message.hasOwnProperty("projectDir"))
                    object.projectDir = message.projectDir;
                return object;
            };

            /**
             * Converts this MetadataResponse to JSON.
             * @function toJSON
             * @memberof dataform.server.MetadataResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MetadataResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MetadataResponse
             * @function getTypeUrl
             * @memberof dataform.server.MetadataResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MetadataResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/dataform.server.MetadataResponse";
            };

            return MetadataResponse;
        })();

        server.Service = (function() {

            /**
             * Constructs a new Service service.
             * @memberof dataform.server
             * @classdesc Represents a Service
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Service(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (Service.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Service;

            /**
             * Creates new Service service using the specified rpc implementation.
             * @function create
             * @memberof dataform.server.Service
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {Service} RPC service. Useful where requests and/or responses are streamed.
             */
            Service.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link dataform.server.Service#metadata}.
             * @memberof dataform.server.Service
             * @typedef MetadataCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {dataform.server.MetadataResponse} [response] MetadataResponse
             */

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @param {dataform.server.Service.MetadataCallback} callback Node-style callback called with the error, if any, and MetadataResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(Service.prototype.metadata = function metadata(request, callback) {
                return this.rpcCall(metadata, $root.dataform.server.Empty, $root.dataform.server.MetadataResponse, request, callback);
            }, "name", { value: "Metadata" });

            /**
             * Calls Metadata.
             * @function metadata
             * @memberof dataform.server.Service
             * @instance
             * @param {dataform.server.IEmpty} request Empty message or plain object
             * @returns {Promise<dataform.server.MetadataResponse>} Promise
             * @variation 2
             */

            return Service;
        })();

        return server;
    })();

    return dataform;
})();

function concatenateQueries(statements, modifier) {
    return statements
        .filter(statement => !!statement)
        .map(statement => statement.trim())
        .map(statement => statement.length > 0 && statement.charAt(statement.length - 1) === ";"
        ? statement.substring(0, statement.length - 1)
        : statement)
        .map(statement => (!!modifier ? modifier(statement) : statement))
        .join("\n;\n");
}
class Tasks {
    constructor() {
        this.tasks = [];
    }
    static create() {
        return new Tasks();
    }
    add(task) {
        this.tasks.push(task);
        return this;
    }
    addAll(tasks) {
        this.tasks = this.tasks.concat(tasks.tasks);
        return this;
    }
    build() {
        return this.tasks.map(task => task.build());
    }
    concatenate() {
        return Tasks.create().add(Task.statement(concatenateQueries(this.tasks.map(task => task.getStatement()))));
    }
}
class Task {
    constructor() {
        this.proto = dataform.ExecutionTask.create();
    }
    static create() {
        return new Task();
    }
    static statement(statement) {
        return Task.create()
            .type("statement")
            .statement(statement);
    }
    static assertion(statement) {
        return Task.create()
            .type("assertion")
            .statement(statement);
    }
    type(v) {
        this.proto.type = v;
        return this;
    }
    statement(v) {
        this.proto.statement = v;
        return this;
    }
    getStatement() {
        return this.proto.statement;
    }
    build() {
        return dataform.ExecutionTask.create(this.proto);
    }
}

class Adapter {
    constructor(dataformCoreVersion) {
        this.dataformCoreVersion = dataformCoreVersion;
    }
    normalizeIdentifier(identifier) {
        return identifier;
    }
    sqlString(stringContents) {
        return `'${stringContents.replace(/\\/g, "\\\\").replace(/'/g, "\\'")}'`;
    }
    dropIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)} ${type === dataform.TableMetadata.Type.TABLE ? "cascade" : ""}`;
    }
    baseTableType(type) {
        switch (type) {
            case "table":
            case "incremental":
                return dataform.TableMetadata.Type.TABLE;
            case "view":
                return dataform.TableMetadata.Type.VIEW;
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    tableTypeAsSql(type) {
        switch (type) {
            case dataform.TableMetadata.Type.TABLE:
                return "table";
            case dataform.TableMetadata.Type.VIEW:
                return "view";
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    indexAssertion(dataset, indexCols) {
        const commaSeparatedColumns = indexCols.join(", ");
        return `
SELECT
  *
FROM (
  SELECT
    ${commaSeparatedColumns},
    COUNT(1) AS index_row_count
  FROM ${dataset}
  GROUP BY ${commaSeparatedColumns}
  ) AS data
WHERE index_row_count > 1
`;
    }
    rowConditionsAssertion(dataset, rowConditions) {
        return rowConditions
            .map((rowCondition) => `
SELECT
  ${this.sqlString(rowCondition)} AS failing_row_condition,
  *
FROM ${dataset}
WHERE NOT (${rowCondition})
`)
            .join(`UNION ALL`);
    }
    insertInto(target, columns, query) {
        return `	
insert into ${this.resolveTarget(target)}	
(${columns.join(",")})	
select ${columns.join(",")}	
from (${query}) as insertions`;
    }
    oppositeTableType(type) {
        switch (type) {
            case dataform.TableMetadata.Type.TABLE:
                return dataform.TableMetadata.Type.VIEW;
            case dataform.TableMetadata.Type.VIEW:
                return dataform.TableMetadata.Type.TABLE;
            default:
                throw new Error(`Unexpected table type: ${type}`);
        }
    }
    where(query, where) {
        return where
            ? `
  select * from (${query}) as subquery
    where ${where}`
            : query;
    }
    shouldWriteIncrementally(runConfig, tableMetadata) {
        return (!runConfig.fullRefresh &&
            tableMetadata &&
            tableMetadata.type !== dataform.TableMetadata.Type.VIEW);
    }
    preOps(table, runConfig, tableMetadata) {
        let preOps = table.preOps;
        if (semver.gt(this.dataformCoreVersion, "1.4.8") &&
            table.type === "incremental" &&
            this.shouldWriteIncrementally(runConfig, tableMetadata)) {
            preOps = table.incrementalPreOps;
        }
        return (preOps || []).map(pre => Task.statement(pre));
    }
    postOps(table, runConfig, tableMetadata) {
        let postOps = table.postOps;
        if (semver.gt(this.dataformCoreVersion, "1.4.8") &&
            table.type === "incremental" &&
            this.shouldWriteIncrementally(runConfig, tableMetadata)) {
            postOps = table.incrementalPostOps;
        }
        return (postOps || []).map(post => Task.statement(post));
    }
}

class BigQueryAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `\`${target.database || this.project.defaultDatabase}.${target.schema ||
            this.project.defaultSchema}.${target.name}\``;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.add(Task.statement(this.createOrReplace(table)));
            }
            else {
                tasks.add(Task.statement(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, tableMetadata === null || tableMetadata === void 0 ? void 0 : tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey, table.bigquery && table.bigquery.updatePartitionFilter)
                    : this.insertInto(table.target, tableMetadata === null || tableMetadata === void 0 ? void 0 : tableMetadata.fields.map(f => f.name).map(column => `\`${column}\``), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target;
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    dropIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
    }
    createOrReplace(table) {
        const options = [];
        if (table.bigquery && table.bigquery.partitionBy && table.bigquery.partitionExpirationDays) {
            options.push(`partition_expiration_days=${table.bigquery.partitionExpirationDays}`);
        }
        if (table.bigquery && table.bigquery.partitionBy && table.bigquery.requirePartitionFilter) {
            options.push(`require_partition_filter=${table.bigquery.requirePartitionFilter}`);
        }
        if (table.bigquery && table.bigquery.additionalOptions) {
            for (const [optionName, optionValue] of Object.entries(table.bigquery.additionalOptions)) {
                options.push(`${optionName}=${optionValue}`);
            }
        }
        return `create or replace ${table.materialized
            ? "materialized "
            : ""}${this.tableTypeAsSql(this.baseTableType(table.type))} ${this.resolveTarget(table.target)} ${table.bigquery && table.bigquery.partitionBy
            ? `partition by ${table.bigquery.partitionBy} `
            : ""}${table.bigquery && table.bigquery.clusterBy && table.bigquery.clusterBy.length > 0
            ? `cluster by ${table.bigquery.clusterBy.join(", ")} `
            : ""}${options.length > 0 ?
            `OPTIONS(${options.join(',')})` : ""}as ${table.query}`;
    }
    createOrReplaceView(target, query) {
        return `
      create or replace view ${this.resolveTarget(target)} as ${query}`;
    }
    mergeInto(target, columns, query, uniqueKey, updatePartitionFilter) {
        const backtickedColumns = columns.map(column => `\`${column}\``);
        return `
merge ${this.resolveTarget(target)} T
using (${query}
) S
on ${uniqueKey.map(uniqueKeyCol => `T.${uniqueKeyCol} = S.${uniqueKeyCol}`).join(` and `)}
  ${updatePartitionFilter ? `and T.${updatePartitionFilter}` : ""}
when matched then
  update set ${columns.map(column => `\`${column}\` = S.${column}`).join(",")}
when not matched then
  insert (${backtickedColumns.join(",")}) values (${backtickedColumns.join(",")})`;
    }
}

class PrestoAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `"${target.database || this.project.defaultDatabase}"."${target.schema ||
            this.project.defaultSchema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            throw new Error("Incremental table types are not currently supported for Presto.");
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target;
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    createOrReplaceView(target, query) {
        return `create or replace view ${this.resolveTarget(target)} as ${query}`;
    }
    createTable(table) {
        var _a, _b;
        return `create table if not exists ${this.resolveTarget(table.target)} as ${table.query} ${((_a = table.presto) === null || _a === void 0 ? void 0 : _a.partitionBy) ? `with (partitioned_by = array[${(_b = table.presto) === null || _b === void 0 ? void 0 : _b.partitionBy.join(", ")}]`
            : ""}`;
    }
    dropTableIfExists(target, type) {
        return `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
    }
    createOrReplace(table) {
        return this.createTable(table);
    }
    mergeInto() {
        throw new Error("mergeInto unimplemented for Presto.");
    }
}

class RedshiftAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `"${target.schema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.addAll(this.createOrReplace(table));
            }
            else {
                tasks.addAll(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey)
                    : Tasks.create().add(Task.statement(this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where)))));
            }
        }
        else {
            tasks.addAll(this.createOrReplace(table));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks;
    }
    assertTasks(assertion, projectConfig) {
        const target = assertion.target;
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(target, dataform.TableMetadata.Type.VIEW)))
            .add(Task.statement(this.createOrReplaceView(target, assertion.query, false)))
            .add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
    }
    dropIfExists(target, type) {
        const query = `drop ${this.tableTypeAsSql(type)} if exists ${this.resolveTarget(target)}`;
        if (this.project.warehouse === "postgres" || this.isBindSupported()) {
            return `${query} cascade`;
        }
        return query;
    }
    createOrReplaceView(target, query, bind) {
        const createQuery = `create or replace view ${this.resolveTarget(target)} as ${query}`;
        if (bind || this.project.warehouse === "postgres") {
            return createQuery;
        }
        return `${createQuery} with no schema binding`;
    }
    createOrReplace(table) {
        if (table.type === "view") {
            const isBindDefined = table.redshift && table.redshift.hasOwnProperty("bind");
            const bindDefaultValue = semver.gte(this.dataformCoreVersion, "1.4.1") ? false : true;
            const bind = (isBindDefined ? table.redshift.bind : bindDefaultValue) && this.isBindSupported();
            return (Tasks.create()
                .add(Task.statement(this.dropIfExists(table.target, this.baseTableType(table.type))))
                .add(Task.statement(this.createOrReplaceView(table.target, table.query, bind))));
        }
        const tempTableTarget = dataform.Target.create({
            schema: table.target.schema,
            name: table.target.name + "_temp"
        });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(tempTableTarget, this.baseTableType(table.type))))
            .add(Task.statement(this.createTable(table, tempTableTarget)))
            .add(Task.statement(this.dropIfExists(table.target, dataform.TableMetadata.Type.TABLE)))
            .add(Task.statement(`alter table ${this.resolveTarget(tempTableTarget)} rename to "${table.target.name}"`));
    }
    createTable(table, target) {
        if (table.redshift) {
            let query = `create table ${this.resolveTarget(target)}`;
            if (table.redshift.distStyle && table.redshift.distKey) {
                query = `${query} diststyle ${table.redshift.distStyle} distkey (${table.redshift.distKey})`;
            }
            if (table.redshift.sortStyle && table.redshift.sortKeys) {
                query = `${query} ${table.redshift.sortStyle} sortkey (${table.redshift.sortKeys.join(", ")})`;
            }
            return `${query} as ${table.query}`;
        }
        return `create table ${this.resolveTarget(target)} as ${table.query}`;
    }
    mergeInto(target, query, uniqueKey) {
        const finalTarget = this.resolveTarget(target);
        const tempTarget = `"${target.schema}__${target.name}_incremental_temp"`;
        return Tasks.create()
            .add(Task.statement(`drop table if exists ${tempTarget};`))
            .add(Task.statement(`create temp table ${tempTarget} as select * from (${query}
) as data;`))
            .add(Task.statement(`begin transaction;`))
            .add(Task.statement(`delete from ${finalTarget} using ${tempTarget} where ${uniqueKey
            .map(uniqueKeyCol => `${finalTarget}."${uniqueKeyCol}" = ${tempTarget}."${uniqueKeyCol}"`)
            .join(` and `)};`))
            .add(Task.statement(`insert into ${finalTarget} select * from ${tempTarget};`))
            .add(Task.statement(`end transaction;`))
            .add(Task.statement(`drop table ${tempTarget};`));
    }
    isBindSupported() {
        return semver.lte(this.dataformCoreVersion, "1.10.0");
    }
}

class SnowflakeAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    resolveTarget(target) {
        return `${!!target.database ? `"${target.database}".` : ""}"${target.schema}"."${target.name}"`;
    }
    normalizeIdentifier(identifier) {
        return identifier.toUpperCase();
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.add(Task.statement(this.createOrReplace(table)));
            }
            else {
                tasks.add(Task.statement(table.uniqueKey && table.uniqueKey.length > 0
                    ? this.mergeInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where), table.uniqueKey)
                    : this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.add(Task.statement(this.createOrReplace(table)));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks;
    }
    assertTasks(assertion, projectConfig) {
        const tasks = Tasks.create();
        const target = assertion.target;
        tasks.add(Task.statement(this.createOrReplaceView(target, assertion.query, false, false)));
        tasks.add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
        return tasks;
    }
    createOrReplaceView(target, query, secure, materialized) {
        return `create or replace ${secure ? "secure " : ""}${materialized ? "materialized " : ""}view ${this.resolveTarget(target)} as ${query}`;
    }
    createOrReplace(table) {
        var _a, _b, _c, _d, _e;
        if (table.type === "view") {
            return this.createOrReplaceView(table.target, table.query, (_a = table.snowflake) === null || _a === void 0 ? void 0 : _a.secure, table.materialized);
        }
        return `create or replace ${((_b = table.snowflake) === null || _b === void 0 ? void 0 : _b.transient) ? "transient " : ""}table ${this.resolveTarget(table.target)} ${((_d = (_c = table.snowflake) === null || _c === void 0 ? void 0 : _c.clusterBy) === null || _d === void 0 ? void 0 : _d.length) > 0
            ? `cluster by (${(_e = table.snowflake) === null || _e === void 0 ? void 0 : _e.clusterBy.join(", ")}) `
            : ""}as ${table.query}`;
    }
    mergeInto(target, columns, query, uniqueKey) {
        return `
merge into ${this.resolveTarget(target)} T
using (${query}
) S
on ${uniqueKey.map(uniqueKeyCol => `T.${uniqueKeyCol} = S.${uniqueKeyCol}`).join(` and `)}
when matched then
  update set ${columns.map(column => `${column} = S.${column}`).join(",")}
when not matched then
  insert (${columns.join(",")}) values (${columns.join(",")})`;
    }
}

class SQLDataWarehouseAdapter extends Adapter {
    constructor(project, dataformCoreVersion) {
        super(dataformCoreVersion);
        this.project = project;
    }
    sqlString(stringContents) {
        return `'${stringContents.replace(/'/g, "''")}'`;
    }
    resolveTarget(target) {
        return `"${target.schema}"."${target.name}"`;
    }
    publishTasks(table, runConfig, tableMetadata) {
        const tasks = Tasks.create();
        this.preOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        const baseTableType = this.baseTableType(table.type);
        if (tableMetadata && tableMetadata.type !== baseTableType) {
            tasks.add(Task.statement(this.dropIfExists(table.target, this.oppositeTableType(baseTableType))));
        }
        if (table.type === "incremental") {
            if (!this.shouldWriteIncrementally(runConfig, tableMetadata)) {
                tasks.addAll(this.createOrReplace(table, !!tableMetadata));
            }
            else {
                tasks.add(Task.statement(this.insertInto(table.target, tableMetadata.fields.map(f => f.name), this.where(table.incrementalQuery || table.query, table.where))));
            }
        }
        else {
            tasks.addAll(this.createOrReplace(table, !!tableMetadata));
        }
        this.postOps(table, runConfig, tableMetadata).forEach(statement => tasks.add(statement));
        return tasks.concatenate();
    }
    assertTasks(assertion, projectConfig) {
        const target = assertion.target;
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(target, dataform.TableMetadata.Type.VIEW)))
            .add(Task.statement(`
        create view ${this.resolveTarget(target)}
        as ${assertion.query}`))
            .add(Task.assertion(`select sum(1) as row_count from ${this.resolveTarget(target)}`));
    }
    dropIfExists(target, type) {
        if (type === dataform.TableMetadata.Type.VIEW) {
            return `drop view if exists ${this.resolveTarget(target)} `;
        }
        return `if object_id ('${this.resolveTarget(target)}','U') is not null drop table ${this.resolveTarget(target)}`;
    }
    insertInto(target, columns, query) {
        return `
insert into ${this.resolveTarget(target)}
(${columns.join(",")})
select ${columns.join(",")}
from (${query}
) as insertions`;
    }
    createOrReplace(table, alreadyExists) {
        if (table.type === "view") {
            return Tasks.create().add(Task.statement(`${alreadyExists ? "alter" : "create"} view ${this.resolveTarget(table.target)} as ${table.query}`));
        }
        const tempTableTarget = dataform.Target.create({
            schema: table.target.schema,
            name: table.target.name + "_temp"
        });
        return Tasks.create()
            .add(Task.statement(this.dropIfExists(tempTableTarget, this.baseTableType(table.type))))
            .add(Task.statement(this.createTable(table, tempTableTarget)))
            .add(Task.statement(this.dropIfExists(table.target, dataform.TableMetadata.Type.TABLE)))
            .add(Task.statement(`rename object ${this.resolveTarget(tempTableTarget)} to ${table.target.name} `));
    }
    createTable(table, target) {
        const distribution = table.sqlDataWarehouse && table.sqlDataWarehouse.distribution
            ? table.sqlDataWarehouse.distribution
            : "ROUND_ROBIN";
        return `create table ${this.resolveTarget(target)}
     with(
       distribution = ${distribution}
     ) 
     as ${table.query}`;
    }
}

var WarehouseType;
(function (WarehouseType) {
    WarehouseType["BIGQUERY"] = "bigquery";
    WarehouseType["PRESTO"] = "presto";
    WarehouseType["POSTGRES"] = "postgres";
    WarehouseType["REDSHIFT"] = "redshift";
    WarehouseType["SNOWFLAKE"] = "snowflake";
    WarehouseType["SQLDATAWAREHOUSE"] = "sqldatawarehouse";
})(WarehouseType || (WarehouseType = {}));
const CANCELLATION_SUPPORTED = [WarehouseType.BIGQUERY, WarehouseType.SQLDATAWAREHOUSE];
function supportsCancel(warehouseType) {
    return CANCELLATION_SUPPORTED.some(w => {
        return w === warehouseType;
    });
}
const requiredBigQueryWarehouseProps = ["projectId"];
const requiredJdbcWarehouseProps = [
    "host",
    "port",
    "username",
    "password",
    "databaseName"
];
const requiredSnowflakeWarehouseProps = [
    "accountId",
    "username",
    "password",
    "role",
    "databaseName",
    "warehouse"
];
const requiredSQLDataWarehouseProps = [
    "server",
    "port",
    "username",
    "password",
    "database"
];
const requiredPrestoWarehouseProps = ["host", "port", "user"];
const requiredWarehouseProps = {
    [WarehouseType.BIGQUERY]: requiredBigQueryWarehouseProps,
    [WarehouseType.POSTGRES]: requiredJdbcWarehouseProps,
    [WarehouseType.REDSHIFT]: requiredJdbcWarehouseProps,
    [WarehouseType.SNOWFLAKE]: requiredSnowflakeWarehouseProps,
    [WarehouseType.SQLDATAWAREHOUSE]: requiredSQLDataWarehouseProps,
    [WarehouseType.PRESTO]: requiredPrestoWarehouseProps
};
const registry = {};
function register(warehouseType, c) {
    registry[warehouseType] = c;
}
function create(projectConfig, dataformCoreVersion) {
    if (!registry[projectConfig.warehouse]) {
        throw new Error(`Unsupported warehouse: ${projectConfig.warehouse}`);
    }
    return new registry[projectConfig.warehouse](projectConfig, dataformCoreVersion);
}
register("bigquery", BigQueryAdapter);
register("presto", PrestoAdapter);
register("postgres", RedshiftAdapter);
register("redshift", RedshiftAdapter);
register("snowflake", SnowflakeAdapter);
register("sqldatawarehouse", SQLDataWarehouseAdapter);
function collectEvaluationQueries(queryOrAction, concatenate, queryModifier = (q) => q) {
    const validationQueries = new Array();
    if (typeof queryOrAction === "string") {
        validationQueries.push({ query: queryModifier(queryOrAction) });
    }
    else {
        try {
            if (queryOrAction instanceof dataform.Table) {
                if (queryOrAction.type === "incremental") {
                    const incrementalTableQueries = queryOrAction.incrementalPreOps.concat(queryOrAction.incrementalQuery, queryOrAction.incrementalPostOps);
                    if (concatenate) {
                        validationQueries.push({
                            query: concatenateQueries(incrementalTableQueries, queryModifier),
                            incremental: true
                        });
                    }
                    else {
                        incrementalTableQueries.forEach(q => validationQueries.push({ query: queryModifier(q), incremental: true }));
                    }
                }
                const tableQueries = queryOrAction.preOps.concat(queryOrAction.query, queryOrAction.postOps);
                if (concatenate) {
                    validationQueries.push({
                        query: concatenateQueries(tableQueries, queryModifier)
                    });
                }
                else {
                    tableQueries.forEach(q => validationQueries.push({ query: queryModifier(q) }));
                }
            }
            else if (queryOrAction instanceof dataform.Operation) {
                if (concatenate) {
                    validationQueries.push({
                        query: concatenateQueries(queryOrAction.queries, queryModifier)
                    });
                }
                else {
                    queryOrAction.queries.forEach(q => validationQueries.push({ query: queryModifier(q) }));
                }
            }
            else if (queryOrAction instanceof dataform.Assertion) {
                validationQueries.push({ query: queryModifier(queryOrAction.query) });
            }
            else {
                throw new Error("Unrecognized evaluate type.");
            }
        }
        catch (e) {
            throw new ErrorWithCause(`Error building tasks for evaluation. ${e.message}`, e);
        }
    }
    return validationQueries
        .map(validationQuery => (Object.assign({ query: validationQuery.query.trim() }, validationQuery)))
        .filter(validationQuery => !!validationQuery.query);
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get WarehouseType () { return WarehouseType; },
    supportsCancel: supportsCancel,
    requiredWarehouseProps: requiredWarehouseProps,
    register: register,
    create: create,
    collectEvaluationQueries: collectEvaluationQueries
});

const pathSeperator = (() => {
    if (typeof process !== "undefined") {
        return process.platform === "win32" ? "\\" : "/";
    }
    return "/";
})();
function relativePath(fullPath, base) {
    if (base.length === 0) {
        return fullPath;
    }
    const stripped = fullPath.substr(base.length);
    if (stripped.startsWith(pathSeperator)) {
        return stripped.substr(1);
    }
    else {
        return stripped;
    }
}
function baseFilename(fullPath) {
    return fullPath
        .split(pathSeperator)
        .slice(-1)[0]
        .split(".")[0];
}
function getCallerFile(rootDir) {
    let lastfile;
    const stack = getCurrentStack();
    while (stack.length) {
        const nextLastfile = stack.shift().getFileName();
        if (!nextLastfile) {
            continue;
        }
        if (!nextLastfile.includes(rootDir)) {
            continue;
        }
        if (nextLastfile.includes("node_modules")) {
            continue;
        }
        lastfile = nextLastfile;
        if (!(nextLastfile.includes(`definitions${pathSeperator}`) ||
            nextLastfile.includes(`models${pathSeperator}`))) {
            continue;
        }
        break;
    }
    if (!lastfile) {
        throw new Error("Unable to find valid caller file; please report this issue.");
    }
    return relativePath(lastfile, rootDir);
}
function getCurrentStack() {
    const originalStackTraceLimit = Error.stackTraceLimit;
    const originalPrepareStackTrace = Error.prepareStackTrace;
    try {
        Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        Error.prepareStackTrace = (err, stack) => {
            return stack;
        };
        return new Error().stack;
    }
    finally {
        Error.stackTraceLimit = originalStackTraceLimit;
        Error.prepareStackTrace = originalPrepareStackTrace;
    }
}
const invalidRefInputMessage = "Invalid input. Accepted inputs include: a single object containing " +
    "an (optional) 'database', (optional) 'schema', and 'name', " +
    "or 1-3 inputs consisting of an (optional) database, (optional) schema, and 'name'.";
function toResolvable(ref, rest = []) {
    if (Array.isArray(ref) && rest.length > 0) {
        throw new Error(invalidRefInputMessage);
    }
    if (rest.length === 0 && !Array.isArray(ref)) {
        return ref;
    }
    const resolvableArray = Array.isArray(ref) ? ref.reverse() : [ref, ...rest].reverse();
    if (!isResolvableArray(resolvableArray)) {
        throw new Error(invalidRefInputMessage);
    }
    const [name, schema, database] = resolvableArray;
    return { database, schema, name };
}
function isResolvableArray(parts) {
    if (parts.some(part => typeof part !== "string")) {
        return false;
    }
    return parts.length > 0 && parts.length <= 3;
}
function resolvableAsTarget(resolvable) {
    if (typeof resolvable === "string") {
        return {
            name: resolvable
        };
    }
    return resolvable;
}
function stringifyResolvable(res) {
    return typeof res === "string" ? res : JSON.stringify(res);
}
function ambiguousActionNameMsg(act, allActs) {
    const allActNames = typeof allActs[0] === "string"
        ? allActs
        : allActs.map(r => `${r.proto.target.schema}.${r.proto.target.name}`);
    return `Ambiguous Action name: ${stringifyResolvable(act)}. Did you mean one of: ${allActNames.join(", ")}.`;
}
function target(adapter, config, name, schema, database) {
    schema = schema || config.defaultSchema;
    database = database || config.defaultDatabase;
    return dataform.Target.create({
        name: adapter.normalizeIdentifier(name),
        schema: !!schema ? adapter.normalizeIdentifier(schema || config.defaultSchema) : undefined,
        database: !!database ? adapter.normalizeIdentifier(database) : undefined
    });
}
function setNameAndTarget(session, action, name, overrideSchema, overrideDatabase) {
    action.target = target(session.adapter(), session.config, name, overrideSchema, overrideDatabase);
    action.canonicalTarget = target(session.adapter(), session.canonicalConfig, name, overrideSchema, overrideDatabase);
}
function strictKeysOf() {
    return (array) => array;
}
function checkExcessProperties(reportError, object, supportedProperties, name) {
    const extraProperties = Object.keys(object).filter(key => !supportedProperties.includes(key));
    if (extraProperties.length > 0) {
        reportError(new Error(`Unexpected property "${extraProperties[0]}"${!!name ? ` in ${name}` : ""}. Supported properties are: ${JSON.stringify(supportedProperties)}`));
    }
}
function validateQueryString(session, query, filename) {
    if ((query === null || query === void 0 ? void 0 : query.trim().slice(-1)) === ";") {
        session.compileError(new Error("Semi-colons are not allowed at the end of SQL statements."), filename);
    }
}
function throwIfInvalid(proto, verify) {
    const verifyError = verify(proto);
    if (verifyError) {
        throw new Error(verifyError);
    }
}

const IAssertionConfigProperties = strictKeysOf()([
    "database",
    "dependencies",
    "description",
    "disabled",
    "hermetic",
    "name",
    "schema",
    "tags",
    "type"
]);
class Assertion {
    constructor() {
        this.proto = dataform.Assertion.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IAssertionConfigProperties, "assertion config");
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        return this;
    }
    query(query) {
        this.contextableQuery = query;
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    disabled() {
        this.proto.disabled = true;
        return this;
    }
    tags(value) {
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            if (this.proto.tags.indexOf(t) < 0) {
                this.proto.tags.push(t);
            }
        });
        return this;
    }
    description(description) {
        this.proto.actionDescriptor = { description };
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    compile() {
        const context = new AssertionContext(this);
        this.proto.query = context.apply(this.contextableQuery);
        validateQueryString(this.session, this.proto.query, this.proto.fileName);
        return this.proto;
    }
}
class AssertionContext {
    constructor(assertion) {
        this.assertion = assertion;
    }
    self() {
        return this.resolve(this.assertion.proto.target);
    }
    name() {
        return this.assertion.session.finalizeName(this.assertion.proto.target.name);
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            this.assertion.session.compileError(new Error(`Action name is not specified`));
            return "";
        }
        this.assertion.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.assertion.session.resolve(ref, ...rest);
    }
    schema() {
        return this.assertion.session.finalizeSchema(this.assertion.proto.target.schema);
    }
    database() {
        if (!this.assertion.proto.target.database) {
            this.assertion.session.compileError(new Error(`Warehouse does not support multiple databases`));
            return "";
        }
        return this.assertion.session.finalizeDatabase(this.assertion.proto.target.database);
    }
    dependencies(name) {
        this.assertion.dependencies(name);
        return "";
    }
    tags(name) {
        this.assertion.tags(name);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}

const IRecordDescriptorProperties = () => strictKeysOf()([
    "description",
    "columns",
    "displayName",
    "dimension",
    "aggregator",
    "expression",
    "tags",
    "bigqueryPolicyTags"
]);

class ColumnDescriptors {
    static mapToColumnProtoArray(columns, reportError) {
        return Object.keys(columns)
            .map(column => ColumnDescriptors.mapColumnDescriptionToProto([column], columns[column], reportError))
            .flat();
    }
    static mapColumnDescriptionToProto(currentPath, description, reportError) {
        if (typeof description === "string") {
            return [
                dataform.ColumnDescriptor.create({
                    description,
                    path: currentPath
                })
            ];
        }
        checkExcessProperties(reportError, description, IRecordDescriptorProperties(), `${currentPath.join(".")} column descriptor`);
        const columnDescriptor = !!description
            ? [
                dataform.ColumnDescriptor.create({
                    path: currentPath,
                    description: description.description,
                    displayName: description.displayName,
                    dimensionType: ColumnDescriptors.mapDimensionType(description.dimension),
                    aggregation: ColumnDescriptors.mapAggregation(description.aggregator),
                    expression: description.expression,
                    tags: typeof description.tags === "string" ? [description.tags] : description.tags,
                    bigqueryPolicyTags: typeof description.bigqueryPolicyTags === "string"
                        ? [description.bigqueryPolicyTags]
                        : description.bigqueryPolicyTags
                })
            ]
            : [];
        const nestedColumns = description.columns ? Object.keys(description.columns) : [];
        return columnDescriptor.concat(nestedColumns
            .map(nestedColumn => ColumnDescriptors.mapColumnDescriptionToProto(currentPath.concat([nestedColumn]), description.columns[nestedColumn], reportError))
            .flat());
    }
    static mapAggregation(aggregation) {
        switch (aggregation) {
            case "sum":
                return dataform.ColumnDescriptor.Aggregation.SUM;
            case "distinct":
                return dataform.ColumnDescriptor.Aggregation.DISTINCT;
            case "derived":
                return dataform.ColumnDescriptor.Aggregation.DERIVED;
            case undefined:
                return undefined;
            default:
                throw new Error(`'${aggregation}' is not a valid aggregation option.`);
        }
    }
    static mapFromAggregation(aggregation) {
        switch (aggregation) {
            case dataform.ColumnDescriptor.Aggregation.SUM:
                return "sum";
            case dataform.ColumnDescriptor.Aggregation.DISTINCT:
                return "distinct";
            case dataform.ColumnDescriptor.Aggregation.DERIVED:
                return "derived";
            case dataform.ColumnDescriptor.Aggregation.UNKNOWN_AGGREGATION:
                return undefined;
            case undefined:
                return undefined;
            default:
                throw new Error(`Aggregation type not recognized: ${aggregation}`);
        }
    }
    static mapDimensionType(dimensionType) {
        switch (dimensionType) {
            case "category":
                return dataform.ColumnDescriptor.DimensionType.CATEGORY;
            case "timestamp":
                return dataform.ColumnDescriptor.DimensionType.TIMESTAMP;
            case "number":
                return dataform.ColumnDescriptor.DimensionType.NUMBER;
            case undefined:
                return undefined;
            default:
                throw new Error(`'${dimensionType}' is not a valid dimension type.`);
        }
    }
    static mapFromDimensionType(dimensionType) {
        switch (dimensionType) {
            case dataform.ColumnDescriptor.DimensionType.CATEGORY:
                return "category";
            case dataform.ColumnDescriptor.DimensionType.TIMESTAMP:
                return "timestamp";
            case dataform.ColumnDescriptor.DimensionType.NUMBER:
                return "number";
            case dataform.ColumnDescriptor.DimensionType.UNKNOWN_DIMENSION:
                return undefined;
            case undefined:
                return undefined;
            default:
                throw new Error(`Dimension type not recognized: ${dimensionType}`);
        }
    }
}

const IIOperationConfigProperties = strictKeysOf()([
    "columns",
    "database",
    "dependencies",
    "description",
    "disabled",
    "hasOutput",
    "hermetic",
    "name",
    "schema",
    "tags",
    "type"
]);
class Operation {
    constructor() {
        this.proto = dataform.Operation.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IIOperationConfigProperties, "operation config");
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.hasOutput) {
            this.hasOutput(config.hasOutput);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        return this;
    }
    queries(queries) {
        this.contextableQueries = queries;
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    disabled() {
        this.proto.disabled = true;
        return this;
    }
    tags(value) {
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            if (this.proto.tags.indexOf(t) < 0) {
                this.proto.tags.push(t);
            }
        });
        return this;
    }
    hasOutput(hasOutput) {
        this.proto.hasOutput = hasOutput;
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    compile() {
        var _a, _b;
        if (((_b = (_a = this.proto.actionDescriptor) === null || _a === void 0 ? void 0 : _a.columns) === null || _b === void 0 ? void 0 : _b.length) > 0 && !this.proto.hasOutput) {
            this.session.compileError(new Error("Actions of type 'operations' may only describe columns if they specify 'hasOutput: true'."), this.proto.fileName);
        }
        const context = new OperationContext(this);
        const appliedQueries = context.apply(this.contextableQueries);
        this.proto.queries = typeof appliedQueries === "string" ? [appliedQueries] : appliedQueries;
        return this.proto;
    }
}
class OperationContext {
    constructor(operation) {
        this.operation = operation;
    }
    self() {
        return this.resolve(this.operation.proto.target);
    }
    name() {
        return this.operation.session.finalizeName(this.operation.proto.target.name);
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            this.operation.session.compileError(new Error(`Action name is not specified`));
            return "";
        }
        this.operation.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.operation.session.resolve(ref, ...rest);
    }
    schema() {
        return this.operation.session.finalizeSchema(this.operation.proto.target.schema);
    }
    database() {
        if (!this.operation.proto.target.database) {
            this.operation.session.compileError(new Error(`Warehouse does not support multiple databases`));
            return "";
        }
        return this.operation.session.finalizeDatabase(this.operation.proto.target.database);
    }
    dependencies(name) {
        this.operation.dependencies(name);
        return "";
    }
    tags(name) {
        this.operation.tags(name);
        return "";
    }
    hasOutput(hasOutput) {
        this.operation.hasOutput(hasOutput);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}

const TableType = ["table", "view", "incremental", "inline"];
const DistStyleType = ["even", "key", "all"];
const SortStyleType = ["compound", "interleaved"];
const IRedshiftOptionsProperties = () => strictKeysOf()(["distKey", "distStyle", "sortKeys", "sortStyle"]);
const ISnowflakeOptionsProperties = () => strictKeysOf()(["secure", "transient", "clusterBy"]);
const ISQLDataWarehouseOptionsProperties = () => strictKeysOf()(["distribution"]);
const IBigQueryOptionsProperties = () => strictKeysOf()([
    "partitionBy",
    "clusterBy",
    "updatePartitionFilter",
    "labels",
    "partitionExpirationDays",
    "requirePartitionFilter",
    "additionalOptions"
]);
const IPrestoOptionsProperties = () => strictKeysOf()(["partitionBy"]);
const ITableAssertionsProperties = () => strictKeysOf()(["uniqueKey", "uniqueKeys", "nonNull", "rowConditions"]);
const ITableConfigProperties = () => strictKeysOf()([
    "type",
    "disabled",
    "protected",
    "name",
    "redshift",
    "bigquery",
    "snowflake",
    "sqldatawarehouse",
    "presto",
    "tags",
    "uniqueKey",
    "dependencies",
    "hermetic",
    "schema",
    "assertions",
    "database",
    "columns",
    "description",
    "materialized"
]);
class Table {
    constructor() {
        this.proto = dataform.Table.create({
            type: "view",
            disabled: false,
            tags: []
        });
        this.contextablePreOps = [];
        this.contextablePostOps = [];
        this.uniqueKeyAssertions = [];
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, ITableConfigProperties(), "table config");
        if (config.type) {
            this.type(config.type);
        }
        if (config.dependencies) {
            this.dependencies(config.dependencies);
        }
        if (config.hermetic !== undefined) {
            this.hermetic(config.hermetic);
        }
        if (config.disabled) {
            this.disabled();
        }
        if (config.protected) {
            this.protected();
        }
        if (config.redshift) {
            this.redshift(config.redshift);
        }
        if (config.bigquery) {
            this.bigquery(config.bigquery);
        }
        if (config.snowflake) {
            this.snowflake(config.snowflake);
        }
        if (config.sqldatawarehouse) {
            this.sqldatawarehouse(config.sqldatawarehouse);
        }
        if (config.presto) {
            this.presto(config.presto);
        }
        if (config.tags) {
            this.tags(config.tags);
        }
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        if (config.database) {
            this.database(config.database);
        }
        if (config.schema) {
            this.schema(config.schema);
        }
        if (config.assertions) {
            this.assertions(config.assertions);
        }
        if (config.uniqueKey) {
            this.uniqueKey(config.uniqueKey);
        }
        if (config.materialized) {
            this.materialized(config.materialized);
        }
        return this;
    }
    type(type) {
        this.proto.type = type;
        return this;
    }
    query(query) {
        this.contextableQuery = query;
        return this;
    }
    where(where) {
        this.contextableWhere = where;
        return this;
    }
    preOps(pres) {
        this.contextablePreOps.push(pres);
        return this;
    }
    postOps(posts) {
        this.contextablePostOps.push(posts);
        return this;
    }
    disabled() {
        var _a;
        this.proto.disabled = true;
        this.uniqueKeyAssertions.forEach(assertion => assertion.disabled());
        (_a = this.rowConditionsAssertion) === null || _a === void 0 ? void 0 : _a.disabled();
        return this;
    }
    protected() {
        this.proto.protected = true;
        return this;
    }
    uniqueKey(uniqueKey) {
        this.proto.uniqueKey = uniqueKey;
    }
    materialized(materialized) {
        this.proto.materialized = materialized;
    }
    snowflake(snowflake) {
        checkExcessProperties((e) => this.session.compileError(e), snowflake, ISnowflakeOptionsProperties(), "snowflake config");
        this.proto.snowflake = dataform.SnowflakeOptions.create(snowflake);
        return this;
    }
    sqldatawarehouse(sqlDataWarehouse) {
        checkExcessProperties((e) => this.session.compileError(e), sqlDataWarehouse, ISQLDataWarehouseOptionsProperties(), "sqldatawarehouse config");
        this.proto.sqlDataWarehouse = dataform.SQLDataWarehouseOptions.create(sqlDataWarehouse);
        return this;
    }
    redshift(redshift) {
        checkExcessProperties((e) => this.session.compileError(e), redshift, IRedshiftOptionsProperties(), "redshift config");
        this.proto.redshift = dataform.RedshiftOptions.create(redshift);
        return this;
    }
    bigquery(bigquery) {
        checkExcessProperties((e) => this.session.compileError(e), bigquery, IBigQueryOptionsProperties(), "bigquery config");
        this.proto.bigquery = dataform.BigQueryOptions.create(bigquery);
        if (!!bigquery.labels) {
            if (!this.proto.actionDescriptor) {
                this.proto.actionDescriptor = {};
            }
            this.proto.actionDescriptor.bigqueryLabels = bigquery.labels;
        }
        return this;
    }
    presto(presto) {
        checkExcessProperties((e) => this.session.compileError(e), presto, IPrestoOptionsProperties(), "presto config");
        this.proto.presto = dataform.PrestoOptions.create(presto);
        return this;
    }
    dependencies(value) {
        const newDependencies = Array.isArray(value) ? value : [value];
        newDependencies.forEach(resolvable => {
            this.proto.dependencyTargets.push(resolvableAsTarget(resolvable));
        });
        return this;
    }
    hermetic(hermetic) {
        this.proto.hermeticity = hermetic
            ? dataform.ActionHermeticity.HERMETIC
            : dataform.ActionHermeticity.NON_HERMETIC;
    }
    tags(value) {
        var _a;
        const newTags = typeof value === "string" ? [value] : value;
        newTags.forEach(t => {
            this.proto.tags.push(t);
        });
        this.uniqueKeyAssertions.forEach(assertion => assertion.tags(value));
        (_a = this.rowConditionsAssertion) === null || _a === void 0 ? void 0 : _a.tags(value);
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    database(database) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, this.proto.target.schema, database);
        return this;
    }
    schema(schema) {
        setNameAndTarget(this.session, this.proto, this.proto.target.name, schema, this.proto.target.database);
        return this;
    }
    assertions(assertions) {
        checkExcessProperties((e) => this.session.compileError(e), assertions, ITableAssertionsProperties(), "assertions config");
        if (!!assertions.uniqueKey && !!assertions.uniqueKeys) {
            this.session.compileError(new Error("Specify at most one of 'assertions.uniqueKey' and 'assertions.uniqueKeys'."));
        }
        let uniqueKeys = assertions.uniqueKeys;
        if (!!assertions.uniqueKey) {
            uniqueKeys =
                typeof assertions.uniqueKey === "string"
                    ? [[assertions.uniqueKey]]
                    : [assertions.uniqueKey];
        }
        if (uniqueKeys) {
            uniqueKeys.forEach((uniqueKey, index) => {
                const uniqueKeyAssertion = this.session.assert(`${this.proto.target.schema}_${this.proto.target.name}_assertions_uniqueKey_${index}`, ctx => this.session.adapter().indexAssertion(ctx.ref(this.proto.target), uniqueKey));
                if (this.proto.tags) {
                    uniqueKeyAssertion.tags(this.proto.tags);
                }
                uniqueKeyAssertion.proto.parentAction = this.proto.target;
                if (this.proto.disabled) {
                    uniqueKeyAssertion.disabled();
                }
                this.uniqueKeyAssertions.push(uniqueKeyAssertion);
            });
        }
        const mergedRowConditions = assertions.rowConditions || [];
        if (!!assertions.nonNull) {
            const nonNullCols = typeof assertions.nonNull === "string" ? [assertions.nonNull] : assertions.nonNull;
            nonNullCols.forEach(nonNullCol => mergedRowConditions.push(`${nonNullCol} IS NOT NULL`));
        }
        if (!!mergedRowConditions && mergedRowConditions.length > 0) {
            this.rowConditionsAssertion = this.session.assert(`${this.proto.target.schema}_${this.proto.target.name}_assertions_rowConditions`, ctx => this.session
                .adapter()
                .rowConditionsAssertion(ctx.ref(this.proto.target), mergedRowConditions));
            this.rowConditionsAssertion.proto.parentAction = this.proto.target;
            if (this.proto.disabled) {
                this.rowConditionsAssertion.disabled();
            }
            if (this.proto.tags) {
                this.rowConditionsAssertion.tags(this.proto.tags);
            }
        }
        return this;
    }
    compile() {
        const context = new TableContext(this);
        const incrementalContext = new TableContext(this, true);
        this.proto.query = context.apply(this.contextableQuery);
        if (this.proto.type === "incremental") {
            this.proto.incrementalQuery = incrementalContext.apply(this.contextableQuery);
            this.proto.incrementalPreOps = this.contextifyOps(this.contextablePreOps, incrementalContext);
            this.proto.incrementalPostOps = this.contextifyOps(this.contextablePostOps, incrementalContext);
        }
        if (this.contextableWhere) {
            this.proto.where = context.apply(this.contextableWhere);
        }
        this.proto.preOps = this.contextifyOps(this.contextablePreOps, context).filter(op => !!op.trim());
        this.proto.postOps = this.contextifyOps(this.contextablePostOps, context).filter(op => !!op.trim());
        validateQueryString(this.session, this.proto.query, this.proto.fileName);
        validateQueryString(this.session, this.proto.incrementalQuery, this.proto.fileName);
        return this.proto;
    }
    contextifyOps(contextableOps, currentContext) {
        let protoOps = [];
        contextableOps.forEach(contextableOp => {
            const appliedOps = currentContext.apply(contextableOp);
            protoOps = protoOps.concat(typeof appliedOps === "string" ? [appliedOps] : appliedOps);
        });
        return protoOps;
    }
}
Table.IGNORED_PROPS = {
    inline: [
        "bigquery",
        "redshift",
        "snowflake",
        "sqlDataWarehouse",
        "presto",
        "preOps",
        "postOps",
        "actionDescriptor",
        "disabled",
        "where"
    ]
};
class TableContext {
    constructor(table, isIncremental = false) {
        this.table = table;
        this.isIncremental = isIncremental;
    }
    config(config) {
        this.table.config(config);
        return "";
    }
    self() {
        return this.resolve(this.table.proto.target);
    }
    name() {
        return this.table.session.finalizeName(this.table.proto.target.name);
    }
    ref(ref, ...rest) {
        ref = toResolvable(ref, rest);
        if (!resolvableAsTarget(ref)) {
            this.table.session.compileError(new Error(`Action name is not specified`));
            return "";
        }
        this.table.dependencies(ref);
        return this.resolve(ref);
    }
    resolve(ref, ...rest) {
        return this.table.session.resolve(ref, ...rest);
    }
    schema() {
        return this.table.session.finalizeSchema(this.table.proto.target.schema);
    }
    database() {
        if (!this.table.proto.target.database) {
            this.table.session.compileError(new Error(`Warehouse does not support multiple databases`));
            return "";
        }
        return this.table.session.finalizeDatabase(this.table.proto.target.database);
    }
    type(type) {
        this.table.type(type);
        return "";
    }
    where(where) {
        this.table.where(where);
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    incremental() {
        return !!this.isIncremental;
    }
    preOps(statement) {
        this.table.preOps(statement);
        return "";
    }
    postOps(statement) {
        this.table.postOps(statement);
        return "";
    }
    disabled() {
        this.table.disabled();
        return "";
    }
    redshift(redshift) {
        this.table.redshift(redshift);
        return "";
    }
    bigquery(bigquery) {
        this.table.bigquery(bigquery);
        return "";
    }
    presto(presto) {
        this.table.presto(presto);
        return "";
    }
    dependencies(res) {
        this.table.dependencies(res);
        return "";
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
    tags(tags) {
        this.table.tags(tags);
        return "";
    }
}

const LEXER_STATE_NAMES = {
    SQL: "sql",
    JS_BLOCK: "jsBlock",
    JS_TEMPLATE_STRING: "jsTemplateString",
    INNER_SQL_BLOCK: "innerSqlBlock",
    SQL_SINGLE_QUOTE_STRING: "innerSingleQuote",
    SQL_DOUBLE_QUOTE_STRING: "innerDoubleQuote"
};
const SQL_LEXER_TOKEN_NAMES = {
    START_CONFIG: LEXER_STATE_NAMES.SQL + "_startConfig",
    START_JS: LEXER_STATE_NAMES.SQL + "_startJs",
    START_INCREMENTAL: LEXER_STATE_NAMES.SQL + "_startIncremental",
    START_PRE_OPERATIONS: LEXER_STATE_NAMES.SQL + "_startPreOperations",
    START_POST_OPERATIONS: LEXER_STATE_NAMES.SQL + "_startPostOperations",
    START_INPUT: LEXER_STATE_NAMES.SQL + "_startInput",
    STATEMENT_SEPERATOR: LEXER_STATE_NAMES.SQL + "_statementSeparator",
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.SQL + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.SQL + "_multiLineComment",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL + "_startJsPlaceholder",
    BACKTICK: LEXER_STATE_NAMES.SQL + "_backtick",
    START_QUOTE_SINGLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteSingle",
    START_QUOTE_DOUBLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL + "_captureEverythingElse"
};
const JS_BLOCK_LEXER_TOKEN_NAMES = {
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.JS_BLOCK + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.JS_BLOCK + "_multiLineComment",
    SINGLE_QUOTE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_singleQuoteString",
    DOUBLE_QUOTE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_doubleQuoteString",
    START_JS_TEMPLATE_STRING: LEXER_STATE_NAMES.JS_BLOCK + "_startJsTemplateString",
    START_JS_BLOCK: LEXER_STATE_NAMES.JS_BLOCK + "_startJsBlock",
    CLOSE_BLOCK: LEXER_STATE_NAMES.JS_BLOCK + "_closeBlock",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.JS_BLOCK + "_captureEverythingElse"
};
const JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_escapedBackslash",
    ESCAPED_DOLLAR_BRACE: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_escapedDollarBrace",
    START_JS_BLOCK: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_startJsBlock",
    CLOSE_STRING: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_closeString",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.JS_TEMPLATE_STRING + "_captureEverythingElse"
};
const INNER_SQL_BLOCK_LEXER_TOKEN_NAMES = {
    STATEMENT_SEPERATOR: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_statementSeparator",
    SINGLE_LINE_COMMENT: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_singleLineComment",
    MULTI_LINE_COMMENT: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_multiLineComment",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startJsPlaceholder",
    CLOSE_BLOCK: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_closeBlock",
    BACKTICK: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_backtick",
    START_QUOTE_SINGLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteSingle",
    START_QUOTE_DOUBLE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_startQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.INNER_SQL_BLOCK + "_captureEverythingElse"
};
const SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_escapedBackslash",
    ESCAPED_QUOTE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_escapedQuoteSingle",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_startJsPlaceholder",
    CLOSE_QUOTE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_closeQuoteSingle",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING + "_captureEverythingElse"
};
const SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES = {
    ESCAPED_BACKSLASH: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_escapedBackslash",
    ESCAPED_QUOTE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_escapedQuoteDouble",
    START_JS_PLACEHOLDER: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_startJsPlaceholder",
    CLOSE_QUOTE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_closeQuoteDouble",
    CAPTURE_EVERYTHING_ELSE: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING + "_captureEverythingElse"
};
const lexer = moo.states(buildSqlxLexer());
var SyntaxTreeNodeType;
(function (SyntaxTreeNodeType) {
    SyntaxTreeNodeType[SyntaxTreeNodeType["JAVASCRIPT"] = 0] = "JAVASCRIPT";
    SyntaxTreeNodeType[SyntaxTreeNodeType["JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER"] = 1] = "JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL"] = 2] = "SQL";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_COMMENT"] = 3] = "SQL_COMMENT";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_LITERAL_STRING"] = 4] = "SQL_LITERAL_STRING";
    SyntaxTreeNodeType[SyntaxTreeNodeType["SQL_STATEMENT_SEPARATOR"] = 5] = "SQL_STATEMENT_SEPARATOR";
})(SyntaxTreeNodeType || (SyntaxTreeNodeType = {}));
const START_TOKEN_NODE_MAPPINGS = new Map([
    [SQL_LEXER_TOKEN_NAMES.START_CONFIG, SyntaxTreeNodeType.JAVASCRIPT],
    [SQL_LEXER_TOKEN_NAMES.START_INCREMENTAL, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_INPUT, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_JS, SyntaxTreeNodeType.JAVASCRIPT],
    [
        SQL_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [SQL_LEXER_TOKEN_NAMES.START_POST_OPERATIONS, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_PRE_OPERATIONS, SyntaxTreeNodeType.SQL],
    [SQL_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [SQL_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_BLOCK, SyntaxTreeNodeType.JAVASCRIPT],
    [JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.START_JS_BLOCK, SyntaxTreeNodeType.JAVASCRIPT],
    [
        INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE, SyntaxTreeNodeType.SQL_LITERAL_STRING],
    [
        SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ],
    [
        SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER,
        SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER
    ]
]);
const CLOSE_TOKEN_TYPES = new Set([
    JS_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK,
    INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK,
    SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE,
    SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE
]);
const WHOLE_TOKEN_NODE_MAPPINGS = new Map([
    [SQL_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [SQL_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [SQL_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR, SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT, SyntaxTreeNodeType.SQL_COMMENT],
    [
        INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR,
        SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR
    ]
]);
class SyntaxTreeNode {
    constructor(type, allChildren = []) {
        this.type = type;
        this.allChildren = allChildren;
    }
    static create(code) {
        const parentNode = new SyntaxTreeNode(SyntaxTreeNodeType.SQL);
        let currentNode = parentNode;
        const nodeStack = [currentNode];
        lexer.reset(code);
        for (const token of lexer) {
            if (START_TOKEN_NODE_MAPPINGS.has(token.type)) {
                const childType = START_TOKEN_NODE_MAPPINGS.get(token.type);
                if (childType === SyntaxTreeNodeType.SQL && currentNode.type !== SyntaxTreeNodeType.SQL) {
                    throw new Error("SQL syntax tree nodes may only be children of other SQL nodes.");
                }
                const newCurrentNode = new SyntaxTreeNode(childType, [token.value]);
                nodeStack.push(newCurrentNode);
                currentNode.push(newCurrentNode);
                currentNode = newCurrentNode;
            }
            else if (CLOSE_TOKEN_TYPES.has(token.type)) {
                currentNode.push(token.value);
                nodeStack.pop();
                currentNode = nodeStack[nodeStack.length - 1];
            }
            else if (WHOLE_TOKEN_NODE_MAPPINGS.has(token.type)) {
                currentNode.push(new SyntaxTreeNode(WHOLE_TOKEN_NODE_MAPPINGS.get(token.type)).push(token.value));
            }
            else {
                currentNode.push(token.value);
            }
        }
        return parentNode;
    }
    static isSyntaxTreeNode(node) {
        return typeof node !== "string";
    }
    children() {
        return this.allChildren.slice();
    }
    concatenate(mutators) {
        const mutator = (mutators === null || mutators === void 0 ? void 0 : mutators.has(this.type)) ? mutators.get(this.type) : (str) => str;
        return this.allChildren
            .map(child => {
            if (typeof child === "string") {
                return mutator(child);
            }
            return child.concatenate();
        })
            .join("");
    }
    push(child) {
        if (this.allChildren.length > 0 &&
            typeof child === "string" &&
            typeof this.allChildren[this.allChildren.length - 1] === "string") {
            this.allChildren[this.allChildren.length - 1] =
                this.allChildren[this.allChildren.length - 1] + child;
            return;
        }
        this.allChildren.push(child);
        return this;
    }
    equals(other) {
        if (this.type !== other.type) {
            return false;
        }
        if (this.allChildren.length !== other.children().length) {
            return false;
        }
        const areEqual = (first, second) => {
            if (typeof first !== typeof second) {
                return false;
            }
            if (typeof first === "string" || typeof second === "string") {
                return first === second;
            }
            return first.equals(second);
        };
        if (this.allChildren.some((child, index) => !areEqual(child, other.children()[index]))) {
            return false;
        }
        return true;
    }
}
function buildSqlxLexer() {
    const sqlLexer = {};
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_CONFIG] = {
        match: "config {",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_JS] = {
        match: "js {",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_INCREMENTAL] = {
        match: "incremental_where {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_PRE_OPERATIONS] = {
        match: "pre_operations {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_POST_OPERATIONS] = {
        match: "post_operations {",
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_INPUT] = {
        match: /input "[a-zA-Z0-9_-]+"(?:,\s*"[a-zA-Z0-9_-]+")* {/,
        push: LEXER_STATE_NAMES.INNER_SQL_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR] = /[^\S\r\n]*---[^\S\r\n]*$/;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /--.*?$/;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.BACKTICK] = "`";
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE] = {
        match: "'",
        push: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE] = {
        match: '"',
        push: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING
    };
    sqlLexer[SQL_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const jsBlockLexer = {};
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /\/\/.*?$/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.SINGLE_QUOTE_STRING] = /'(?:\\['\\]|[^\n'\\])*'/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.DOUBLE_QUOTE_STRING] = /"(?:\\["\\]|[^\n"\\])*"/;
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_TEMPLATE_STRING] = {
        match: "`",
        push: LEXER_STATE_NAMES.JS_TEMPLATE_STRING
    };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.START_JS_BLOCK] = {
        match: "{",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK] = { match: "}", pop: 1 };
    jsBlockLexer[JS_BLOCK_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const jsTemplateStringLexer = {};
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = /\\\\/;
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.ESCAPED_DOLLAR_BRACE] = /\\\${`/;
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.START_JS_BLOCK] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.CLOSE_STRING] = { match: "`", pop: 1 };
    jsTemplateStringLexer[JS_TEMPLATE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerSqlBlockLexer = {};
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.STATEMENT_SEPERATOR] = /[^\S\r\n]*---[^\S\r\n]*$/;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.SINGLE_LINE_COMMENT] = /--.*?$/;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.MULTI_LINE_COMMENT] = /\/\*[\s\S]*?\*\//;
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CLOSE_BLOCK] = {
        match: "}",
        pop: 1
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.BACKTICK] = "`";
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_SINGLE] = {
        match: "'",
        push: LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.START_QUOTE_DOUBLE] = {
        match: '"',
        push: LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING
    };
    innerSqlBlockLexer[INNER_SQL_BLOCK_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerSingleQuoteLexer = {};
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = "\\\\";
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_QUOTE] = "\\'";
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE] = {
        match: "'",
        pop: 1
    };
    innerSingleQuoteLexer[SQL_SINGLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const innerDoubleQuoteLexer = {};
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_BACKSLASH] = "\\\\";
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.ESCAPED_QUOTE] = {
        match: '\\"'
    };
    innerSingleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.START_JS_PLACEHOLDER] = {
        match: "${",
        push: LEXER_STATE_NAMES.JS_BLOCK
    };
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CLOSE_QUOTE] = {
        match: '"',
        pop: 1
    };
    innerDoubleQuoteLexer[SQL_DOUBLE_QUOTE_STRING_LEXER_TOKEN_NAMES.CAPTURE_EVERYTHING_ELSE] = {
        match: /[\s\S]+?/,
        lineBreaks: true
    };
    const lexerStates = {};
    lexerStates[LEXER_STATE_NAMES.SQL] = sqlLexer;
    lexerStates[LEXER_STATE_NAMES.JS_BLOCK] = jsBlockLexer;
    lexerStates[LEXER_STATE_NAMES.JS_TEMPLATE_STRING] = jsTemplateStringLexer;
    lexerStates[LEXER_STATE_NAMES.INNER_SQL_BLOCK] = innerSqlBlockLexer;
    lexerStates[LEXER_STATE_NAMES.SQL_SINGLE_QUOTE_STRING] = innerSingleQuoteLexer;
    lexerStates[LEXER_STATE_NAMES.SQL_DOUBLE_QUOTE_STRING] = innerDoubleQuoteLexer;
    return lexerStates;
}

function compile(code, path) {
    if (path.endsWith(".sqlx")) {
        return compileSqlx(SyntaxTreeNode.create(code), path);
    }
    if (path.endsWith(".assert.sql")) {
        return compileAssertionSql(code, path);
    }
    if (path.endsWith(".ops.sql")) {
        return compileOperationSql(code, path);
    }
    if (path.endsWith(".sql")) {
        return compileTableSql(code, path);
    }
    return code;
}
function safelyBindCtxFunction(name) {
    return `ctx.${name} ? ctx.${name}.bind(ctx) : undefined`;
}
function compileTableSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = getFunctionPropertyNames(TableContext.prototype).map(name => `const ${name} = ${safelyBindCtxFunction(name)};`);
    return `
  publish("${baseFilename(path)}").query(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`;
  })`;
}
function compileOperationSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = getFunctionPropertyNames(OperationContext.prototype).map(name => `const ${name} = ${safelyBindCtxFunction(name)};`);
    return `
  operate("${baseFilename(path)}").queries(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`.split("\\n---\\n");
  })`;
}
function compileAssertionSql(code, path) {
    const { sql, js } = extractJsBlocks(code);
    const functionsBindings = getFunctionPropertyNames(AssertionContext.prototype).map(name => `const ${name} = ${safelyBindCtxFunction(name)};`);
    return `
  assert("${baseFilename(path)}").query(ctx => {
    ${functionsBindings.join("\n")}
    ${js}
    return \`${sql}\`;
  })`;
}
function extractJsBlocks(code) {
    const JS_REGEX = /^\s*\/\*[jJ][sS]\s*[\r\n]+((?:[^*]|[\r\n]|(?:\*+(?:[^*/]|[\r\n])))*)\*+\/|^\s*\-\-[jJ][sS]\s(.*)/gm;
    const RAW_BACKTICKS_REGEX = /([^\\])`/g;
    const jsBlocks = [];
    const cleanSql = code
        .replace(JS_REGEX, (_, group1, group2) => {
        if (group1) {
            jsBlocks.push(group1);
        }
        if (group2) {
            jsBlocks.push(group2);
        }
        return "";
    })
        .replace(RAW_BACKTICKS_REGEX, (_, group1) => group1 + "\\`");
    return {
        sql: cleanSql.trim(),
        js: jsBlocks.map(block => block.trim()).join("\n")
    };
}
function compileStandaloneSqlxQuery(code) {
    const { config, js, sql, incremental, preOperations, postOperations, inputs } = extractSqlxParts(SyntaxTreeNode.create(code));
    if (config) {
        throw new Error(`Standalone SQLX queries may not define 'config' code blocks.`);
    }
    if (incremental) {
        throw new Error(`Standalone SQLX queries may not define 'incremental_where' code blocks.`);
    }
    if (preOperations.length > 0) {
        throw new Error(`Standalone SQLX queries may not define 'pre_operations' code blocks.`);
    }
    if (postOperations.length > 0) {
        throw new Error(`Standalone SQLX queries may not define 'post_operations' code blocks.`);
    }
    if (inputs.length > 0) {
        throw new Error(`Standalone SQLX queries may not define 'input' code blocks.`);
    }
    return `
    const ref = dataform.resolve.bind(dataform);
    const resolve = dataform.resolve.bind(dataform);
    ${js}
    return \`${sql}\`;
  `;
}
function compileSqlx(rootNode, path) {
    const { config, js, sql, incremental, preOperations, postOperations, inputs } = extractSqlxParts(rootNode);
    const contextFunctions = ["self", "ref", "resolve", "name", "when", "incremental"]
        .map(name => `const ${name} = ctx.${name} ? ctx.${name}.bind(ctx) : undefined;`)
        .join("\n");
    return `dataform.sqlxAction({
  sqlxConfig: {
    name: "${baseFilename(path)}",
    type: "operations",
    ...${config || "{}"}
  },
  sqlStatementCount: ${sql.length},
  sqlContextable: (ctx) => {
    ${contextFunctions}
    ${js}
    return [${sql.map(sqlOp => `\`${sqlOp}\``)}];
  },
  incrementalWhereContextable: ${!!incremental
        ? `(ctx) => {
    ${contextFunctions}
    ${js}
    return \`${incremental}\`
  }`
        : "undefined"},
  preOperationsContextable: ${preOperations.length > 0
        ? `(ctx) => {
    ${contextFunctions}
    ${js}
    return [${preOperations.map(preOpSql => `\`${preOpSql}\``)}];
  }`
        : "undefined"},
  postOperationsContextable: ${postOperations.length > 0
        ? `(ctx) => {
    ${contextFunctions}
    ${js}
    return [${postOperations.map(postOpSql => `\`${postOpSql}\``)}];
  }`
        : "undefined"},
  inputContextables: [
    ${inputs
        .map(({ labelParts, value }) => `{
            refName: [${labelParts.map(labelPart => `"${labelPart}"`).join(", ")}],
            contextable: (ctx) => {
              ${js}
              return \`${value}\`;
            }
          }`)
        .join(",")}
  ]
});
`;
}
function extractSqlxParts(rootNode) {
    let config = "";
    let js = "";
    rootNode
        .children()
        .filter(SyntaxTreeNode.isSyntaxTreeNode)
        .filter(node => node.type === SyntaxTreeNodeType.JAVASCRIPT)
        .forEach(node => {
        const concatenated = node.concatenate();
        if (concatenated.startsWith("config")) {
            config = concatenated.slice("config ".length);
        }
        else {
            js += concatenated.slice("js {".length, "}".length * -1);
        }
    });
    const sql = createEscapedStatements(rootNode
        .children()
        .filter(node => typeof node === "string" ||
        [
            SyntaxTreeNodeType.JAVASCRIPT_TEMPLATE_STRING_PLACEHOLDER,
            SyntaxTreeNodeType.SQL_COMMENT,
            SyntaxTreeNodeType.SQL_LITERAL_STRING,
            SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR
        ].includes(node.type)));
    let incremental = "";
    let preOperations = [];
    let postOperations = [];
    const inputs = [];
    rootNode
        .children()
        .filter(SyntaxTreeNode.isSyntaxTreeNode)
        .filter(node => node.type === SyntaxTreeNodeType.SQL)
        .forEach(node => {
        const firstChild = node.children()[0];
        const lastChild = node.children().slice(-1)[0];
        const sqlCodeBlockWithoutOuterBraces = node.children().length === 1
            ? new SyntaxTreeNode(SyntaxTreeNodeType.SQL, [
                firstChild.slice(firstChild.indexOf("{") + 1, firstChild.lastIndexOf("}"))
            ])
            : new SyntaxTreeNode(SyntaxTreeNodeType.SQL, [
                firstChild.slice(firstChild.indexOf("{") + 1),
                ...node.children().slice(1, -1),
                lastChild.slice(0, lastChild.lastIndexOf("}"))
            ]);
        const statements = createEscapedStatements(sqlCodeBlockWithoutOuterBraces.children());
        if (firstChild.startsWith("incremental_where")) {
            if (statements.length > 1) {
                throw new Error("'incremental_where' code blocks may only contain a single SQL statement.");
            }
            incremental = statements[0];
        }
        else if (firstChild.startsWith("pre_operations")) {
            preOperations = statements;
        }
        else if (firstChild.startsWith("post_operations")) {
            postOperations = statements;
        }
        else if (firstChild.startsWith("input")) {
            if (statements.length > 1) {
                throw new Error("'input' code blocks may only contain a single SQL statement.");
            }
            const labelParts = firstChild
                .slice(firstChild.indexOf('"'), firstChild.lastIndexOf('"') + 1)
                .split(",")
                .map(label => label.trim().slice(1, -1));
            inputs.push({
                labelParts,
                value: statements[0]
            });
        }
    });
    return {
        config,
        js,
        sql,
        incremental,
        preOperations,
        postOperations,
        inputs
    };
}
function getFunctionPropertyNames(prototype) {
    return [
        ...new Set(Object.getOwnPropertyNames(prototype).filter(propertyName => {
            if (typeof prototype[propertyName] !== "function") {
                return false;
            }
            if (propertyName === "constructor") {
                return false;
            }
            return true;
        }))
    ];
}
function createEscapedStatements(nodes) {
    const results = [""];
    nodes.forEach(node => {
        if (typeof node !== "string" && node.type === SyntaxTreeNodeType.SQL_STATEMENT_SEPARATOR) {
            results.push("");
            return;
        }
        results[results.length - 1] += escapeNode(node);
    });
    return results;
}
const SQL_STATEMENT_ESCAPERS = new Map([
    [
        SyntaxTreeNodeType.SQL_COMMENT,
        (str) => str.replace(/`/g, "\\`").replace(/\${/g, "\\${")
    ],
    [
        SyntaxTreeNodeType.SQL_LITERAL_STRING,
        (str) => str.replace(/\\/g, "\\\\").replace(/\`/g, "\\`")
    ]
]);
function escapeNode(node) {
    if (typeof node === "string") {
        return SQL_STATEMENT_ESCAPERS.get(SyntaxTreeNodeType.SQL_LITERAL_STRING)(node);
    }
    return node.concatenate(SQL_STATEMENT_ESCAPERS);
}

function encode64(protoType, value = {}) {
    return toBase64(protoType.encode(protoType.create(value)).finish());
}
function decode64(protoType, encodedValue) {
    if (!encodedValue) {
        return protoType.create();
    }
    return protoType.decode(fromBase64(encodedValue));
}
function toBase64(value) {
    return protobufjs.util.base64.encode(value, 0, value.length);
}
function fromBase64(value) {
    const buf = new Uint8Array(protobufjs.util.base64.length(value));
    protobufjs.util.base64.decode(value, buf, 0);
    return buf;
}

function genIndex(base64EncodedConfig) {
    const config = decode64(dataform.GenerateIndexConfig, base64EncodedConfig);
    const includeRequires = config.includePaths
        .map(path => {
        return `
      try { global.${baseFilename(path)} = require("./${path}"); } catch (e) {
        session.compileError(e, "${path}");
      }`;
    })
        .join("\n");
    const definitionRequires = config.definitionPaths
        .map(path => {
        return `
      try { require("./${path}"); } catch (e) {
        session.compileError(e, "${path}");
      }`;
    })
        .join("\n");
    const projectOverridesJsonString = JSON.stringify(dataform.ProjectConfig.create(config.compileConfig.projectConfigOverride).toJSON());
    return `
// Read the project config.
const originalProjectConfig = require("./dataform.json");

// Stop using the deprecated 'gcloudProjectId' field.
if (!originalProjectConfig.defaultDatabase) {
  originalProjectConfig.defaultDatabase = originalProjectConfig.gcloudProjectId;
}
delete originalProjectConfig.gcloudProjectId;

let projectConfig = { ...originalProjectConfig };

// Merge in general project config overrides.
projectConfig = { ...projectConfig, ...${projectOverridesJsonString}, vars: { ...projectConfig.vars, ...${projectOverridesJsonString}.vars } };

// Initialize the compilation session.
const session = require("@dataform/core").session;
session.init("${config.compileConfig.projectDir.replace(/\\/g, "\\\\")}", projectConfig, originalProjectConfig);

// Allow "includes" files to use the current session object.
global.dataform = session;

// Require "includes" *.js files.
${includeRequires}

// Bind various @dataform/core APIs to the 'global' object.
global.publish = session.publish.bind(session);
global.operate = session.operate.bind(session);
global.assert = session.assert.bind(session);
global.declare = session.declare.bind(session);
global.test = session.test.bind(session);

// Require all "definitions" files (attaching them to the session).
${definitionRequires}

// Return a base64 encoded proto via NodeVM. Returning a Uint8Array directly causes issues.
return session.compileToBase64();`;
}

class JSONObjectStringifier {
    static create() {
        return new JSONObjectStringifier();
    }
    stringify(value) {
        return JSON.stringify(Object.keys(value)
            .sort()
            .reduce((acc, curr) => (Object.assign(Object.assign({}, acc), { [curr]: value[curr] })), {}));
    }
    parse(value) {
        return JSON.parse(value);
    }
}
class StringifiedMap {
    constructor(stringifier, entries) {
        this.stringifier = stringifier;
        if (entries) {
            this.map = new Map(entries.map(([key, value]) => [stringifier.stringify(key), value]));
        }
        else {
            this.map = new Map();
        }
    }
    get [Symbol.toStringTag]() {
        return StringifiedMap.name;
    }
    get size() {
        return this.map.size;
    }
    clear() {
        return this.map.clear();
    }
    delete(key) {
        return this.map.delete(this.stringifier.stringify(key));
    }
    forEach(callbackfn, thisArg) {
        return this.map.forEach((value, key, _) => callbackfn(value, this.stringifier.parse(key), null), thisArg);
    }
    get(key) {
        return this.map.get(this.stringifier.stringify(key));
    }
    has(key) {
        return this.map.has(this.stringifier.stringify(key));
    }
    set(key, value) {
        this.map.set(this.stringifier.stringify(key), value);
        return this;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        const stringifier = this.stringifier;
        const innerIterator = this.map[Symbol.iterator]();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? [stringifier.parse(next.value[0]), next.value[1]] : undefined,
                    done: next.done
                };
            }
        })();
    }
    keys() {
        const stringifier = this.stringifier;
        const innerIterator = this.map.keys();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
    values() {
        return this.map.values();
    }
}
class StringifiedSet {
    constructor(stringifier, values) {
        this.stringifier = stringifier;
        if (values) {
            this.set = new Set(values.map(value => stringifier.stringify(value)));
        }
        else {
            this.set = new Set();
        }
    }
    get size() {
        return this.set.size;
    }
    get [Symbol.toStringTag]() {
        return StringifiedSet.name;
    }
    add(value) {
        this.set.add(this.stringifier.stringify(value));
        return this;
    }
    clear() {
        return this.set.clear();
    }
    delete(value) {
        return this.set.delete(this.stringifier.stringify(value));
    }
    forEach(callbackfn, thisArg) {
        return this.set.forEach((value, value2, _) => callbackfn(this.stringifier.parse(value), this.stringifier.parse(value2), null), thisArg);
    }
    has(value) {
        return this.set.has(this.stringifier.stringify(value));
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    entries() {
        const stringifier = this.stringifier;
        const innerIterator = this.set[Symbol.iterator]();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? [stringifier.parse(next.value[0]), next.value[1]] : undefined,
                    done: next.done
                };
            }
        })();
    }
    keys() {
        const stringifier = this.stringifier;
        const innerIterator = this.set.keys();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
    values() {
        const stringifier = this.stringifier;
        const innerIterator = this.set.values();
        return new (class Iter {
            [Symbol.iterator]() {
                return this;
            }
            next() {
                const next = innerIterator.next();
                return {
                    value: !next.done ? stringifier.parse(next.value) : undefined,
                    done: next.done
                };
            }
        })();
    }
}

const IDeclarationConfigProperties = strictKeysOf()([
    "columns",
    "database",
    "description",
    "name",
    "schema",
    "type"
]);
class Declaration {
    constructor() {
        this.proto = dataform.Declaration.create();
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, IDeclarationConfigProperties, "declaration config");
        if (config.description) {
            this.description(config.description);
        }
        if (config.columns) {
            this.columns(config.columns);
        }
        return this;
    }
    description(description) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.description = description;
        return this;
    }
    columns(columns) {
        if (!this.proto.actionDescriptor) {
            this.proto.actionDescriptor = {};
        }
        this.proto.actionDescriptor.columns = ColumnDescriptors.mapToColumnProtoArray(columns, (e) => this.session.compileError(e));
        return this;
    }
    compile() {
        return this.proto;
    }
}

const targetStringifier = JSONObjectStringifier.create();
function targetAsReadableString(target) {
    const nameParts = [target.name, target.schema];
    if (!!target.database) {
        nameParts.push(target.database);
    }
    return nameParts.reverse().join(".");
}

const ITestConfigProperties = strictKeysOf()(["type", "dataset", "name"]);
class Test {
    constructor() {
        this.proto = dataform.Test.create();
        this.contextableInputs = new StringifiedMap(targetStringifier);
    }
    config(config) {
        checkExcessProperties((e) => this.session.compileError(e), config, ITestConfigProperties, "test config");
        if (config.dataset) {
            this.dataset(config.dataset);
        }
        return this;
    }
    dataset(ref) {
        this.datasetToTest = ref;
        return this;
    }
    input(refName, contextableQuery) {
        this.contextableInputs.set(resolvableAsTarget(toResolvable(refName)), contextableQuery);
        return this;
    }
    expect(contextableQuery) {
        this.contextableQuery = contextableQuery;
        return this;
    }
    compile() {
        const testContext = new TestContext(this);
        if (!this.datasetToTest) {
            this.session.compileError(new Error("Tests must operate upon a specified dataset."), this.proto.fileName);
        }
        else {
            const allResolved = this.session.indexedActions.find(resolvableAsTarget(this.datasetToTest));
            if (allResolved.length > 1) {
                this.session.compileError(new Error(ambiguousActionNameMsg(this.datasetToTest, allResolved)), this.proto.fileName);
            }
            const dataset = allResolved.length > 0 ? allResolved[0] : undefined;
            if (!(dataset && dataset instanceof Table)) {
                this.session.compileError(new Error(`Dataset ${stringifyResolvable(this.datasetToTest)} could not be found.`), this.proto.fileName);
            }
            else if (dataset.proto.type === "incremental") {
                this.session.compileError(new Error("Running tests on incremental datasets is not yet supported."), this.proto.fileName);
            }
            else {
                const refReplacingContext = new RefReplacingContext(testContext);
                this.proto.testQuery = refReplacingContext.apply(dataset.contextableQuery);
            }
        }
        this.proto.expectedOutputQuery = testContext.apply(this.contextableQuery);
        return this.proto;
    }
}
class TestContext {
    constructor(test) {
        this.test = test;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
}
class RefReplacingContext {
    constructor(testContext) {
        this.testContext = testContext;
    }
    ref(ref, ...rest) {
        return this.resolve(ref, ...rest);
    }
    resolve(ref, ...rest) {
        const target = resolvableAsTarget(toResolvable(ref, rest));
        if (!this.testContext.test.contextableInputs.has(target)) {
            this.testContext.test.session.compileError(new Error(`Input for dataset "${JSON.stringify(target)}" has not been provided. Provided inputs: ${Array.from(this.testContext.test.contextableInputs.keys()).map(providedTarget => JSON.stringify(providedTarget))}`));
            return "";
        }
        return `(${this.testContext.apply(this.testContext.test.contextableInputs.get(target))})`;
    }
    apply(value) {
        if (typeof value === "function") {
            return value(this);
        }
        else {
            return value;
        }
    }
    config(config) {
        return "";
    }
    self() {
        return "";
    }
    name() {
        return "";
    }
    type(type) {
        return "";
    }
    schema() {
        return "";
    }
    database() {
        return "";
    }
    where(where) {
        return "";
    }
    when(cond, trueCase, falseCase = "") {
        return cond ? trueCase : falseCase;
    }
    incremental() {
        return false;
    }
    preOps(statement) {
        return "";
    }
    postOps(statement) {
        return "";
    }
    disabled() {
        return "";
    }
    redshift(redshift) {
        return "";
    }
    bigquery(bigquery) {
        return "";
    }
    dependencies(name) {
        return "";
    }
    tags(tags) {
        return "";
    }
}

const version = "2.3.2";

const SQL_DATA_WAREHOUSE_DIST_HASH_REGEXP = new RegExp("HASH\\s*\\(\\s*\\w*\\s*\\)\\s*");
const DEFAULT_CONFIG = {
    defaultSchema: "dataform",
    assertionSchema: "dataform_assertions"
};
class Session {
    constructor(rootDir, projectConfig, originalProjectConfig) {
        this.init(rootDir, projectConfig, originalProjectConfig);
    }
    init(rootDir, projectConfig, originalProjectConfig) {
        this.rootDir = rootDir;
        this.config = projectConfig || DEFAULT_CONFIG;
        this.canonicalConfig = getCanonicalProjectConfig(originalProjectConfig || projectConfig || DEFAULT_CONFIG);
        this.actions = [];
        this.tests = {};
        this.graphErrors = { compilationErrors: [] };
    }
    get projectConfig() {
        return Object.freeze({
            warehouse: this.config.warehouse,
            defaultDatabase: this.config.defaultDatabase,
            defaultSchema: this.config.defaultSchema,
            assertionSchema: this.config.assertionSchema,
            databaseSuffix: this.config.databaseSuffix,
            schemaSuffix: this.config.schemaSuffix,
            tablePrefix: this.config.tablePrefix,
            vars: Object.freeze(Object.assign({}, this.config.vars))
        });
    }
    adapter() {
        return create(this.config, version);
    }
    sqlxAction(actionOptions) {
        const { sqlxConfig } = actionOptions;
        if (actionOptions.sqlStatementCount > 1 && sqlxConfig.type !== "operations") {
            this.compileError("Actions may only contain more than one SQL statement if they are of type 'operations'.");
        }
        if (sqlxConfig.hasOwnProperty("protected") && sqlxConfig.type !== "incremental") {
            this.compileError("Actions may only specify 'protected: true' if they are of type 'incremental'.");
        }
        if (actionOptions.incrementalWhereContextable && sqlxConfig.type !== "incremental") {
            this.compileError("Actions may only include incremental_where if they are of type 'incremental'.");
        }
        if (!sqlxConfig.hasOwnProperty("schema") && sqlxConfig.type === "declaration") {
            this.compileError("Actions of type 'declaration' must specify a value for 'schema'.");
        }
        if (actionOptions.inputContextables.length > 0 && sqlxConfig.type !== "test") {
            this.compileError("Actions may only include input blocks if they are of type 'test'.");
        }
        if (actionOptions.preOperationsContextable && !definesDataset(sqlxConfig.type)) {
            this.compileError("Actions may only include pre_operations if they create a dataset.");
        }
        if (actionOptions.postOperationsContextable && !definesDataset(sqlxConfig.type)) {
            this.compileError("Actions may only include post_operations if they create a dataset.");
        }
        if (!!sqlxConfig.hasOwnProperty("sqldatawarehouse") &&
            !["bigquery", "snowflake"].includes(this.config.warehouse)) {
            this.compileError("Actions may only specify 'database' in projects whose warehouse is 'BigQuery' or 'Snowflake'.");
        }
        switch (sqlxConfig.type) {
            case "view":
            case "table":
            case "inline":
            case "incremental":
                const table = this.publish(sqlxConfig.name)
                    .config(sqlxConfig)
                    .query(ctx => actionOptions.sqlContextable(ctx)[0]);
                if (actionOptions.incrementalWhereContextable) {
                    table.where(actionOptions.incrementalWhereContextable);
                }
                if (actionOptions.preOperationsContextable) {
                    table.preOps(actionOptions.preOperationsContextable);
                }
                if (actionOptions.postOperationsContextable) {
                    table.postOps(actionOptions.postOperationsContextable);
                }
                break;
            case "assertion":
                this.assert(sqlxConfig.name)
                    .config(sqlxConfig)
                    .query(ctx => actionOptions.sqlContextable(ctx)[0]);
                break;
            case "operations":
                this.operate(sqlxConfig.name)
                    .config(sqlxConfig)
                    .queries(actionOptions.sqlContextable);
                break;
            case "declaration":
                this.declare({
                    database: sqlxConfig.database,
                    schema: sqlxConfig.schema,
                    name: sqlxConfig.name
                }).config(sqlxConfig);
                break;
            case "test":
                const testCase = this.test(sqlxConfig.name)
                    .config(sqlxConfig)
                    .expect(ctx => actionOptions.sqlContextable(ctx)[0]);
                actionOptions.inputContextables.forEach(({ refName, contextable }) => {
                    testCase.input(refName, contextable);
                });
                break;
            default:
                throw new Error(`Unrecognized action type: ${sqlxConfig.type}`);
        }
    }
    resolve(ref, ...rest) {
        ref = toResolvable(ref, rest);
        const allResolved = this.indexedActions.find(resolvableAsTarget(ref));
        if (allResolved.length > 1) {
            this.compileError(new Error(ambiguousActionNameMsg(ref, allResolved)));
        }
        const resolved = allResolved.length > 0 ? allResolved[0] : undefined;
        if (resolved && resolved instanceof Table && resolved.proto.type === "inline") {
            return `(${resolved.proto.query})`;
        }
        if (resolved && resolved instanceof Operation && !resolved.proto.hasOutput) {
            this.compileError(new Error("Actions cannot resolve operations which do not produce output."));
        }
        if (resolved) {
            if (resolved instanceof Declaration) {
                return this.adapter().resolveTarget(resolved.proto.target);
            }
            return this.adapter().resolveTarget(Object.assign(Object.assign({}, resolved.proto.target), { database: resolved.proto.target.database &&
                    this.finalizeDatabase(resolved.proto.target.database), schema: this.finalizeSchema(resolved.proto.target.schema), name: this.finalizeName(resolved.proto.target.name) }));
        }
        if (typeof ref === "string") {
            return this.adapter().resolveTarget(target(this.adapter(), this.config, this.finalizeName(ref), this.finalizeSchema(this.config.defaultSchema), this.config.defaultDatabase &&
                this.finalizeDatabase(this.config.defaultDatabase)));
        }
        return this.adapter().resolveTarget(target(this.adapter(), this.config, this.finalizeName(ref.name), this.finalizeSchema(ref.schema), ref.database && this.finalizeName(ref.database)));
    }
    operate(name, queries) {
        const operation = new Operation();
        operation.session = this;
        setNameAndTarget(this, operation.proto, name);
        if (queries) {
            operation.queries(queries);
        }
        operation.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(operation);
        return operation;
    }
    publish(name, queryOrConfig) {
        const newTable = new Table();
        newTable.session = this;
        setNameAndTarget(this, newTable.proto, name);
        if (!!queryOrConfig) {
            if (typeof queryOrConfig === "object") {
                newTable.config(queryOrConfig);
            }
            else {
                newTable.query(queryOrConfig);
            }
        }
        newTable.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(newTable);
        return newTable;
    }
    assert(name, query) {
        const assertion = new Assertion();
        assertion.session = this;
        setNameAndTarget(this, assertion.proto, name, this.config.assertionSchema);
        if (query) {
            assertion.query(query);
        }
        assertion.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(assertion);
        return assertion;
    }
    declare(dataset) {
        const declaration = new Declaration();
        declaration.session = this;
        setNameAndTarget(this, declaration.proto, dataset.name, dataset.schema, dataset.database);
        declaration.proto.fileName = getCallerFile(this.rootDir);
        this.actions.push(declaration);
        return declaration;
    }
    test(name) {
        const newTest = new Test();
        newTest.session = this;
        newTest.proto.name = name;
        newTest.proto.fileName = getCallerFile(this.rootDir);
        this.tests[name] = newTest;
        return newTest;
    }
    compileError(err, path, actionTarget) {
        const fileName = path || getCallerFile(this.rootDir) || __filename;
        const compileError = dataform.CompilationError.create({
            fileName,
            actionName: !!actionTarget ? targetAsReadableString(actionTarget) : undefined,
            actionTarget
        });
        if (typeof err === "string") {
            compileError.message = err;
        }
        else {
            compileError.message = err.message;
            compileError.stack = err.stack;
        }
        this.graphErrors.compilationErrors.push(compileError);
    }
    compile() {
        this.indexedActions = new ActionIndex(this.adapter(), this.actions);
        if (this.config.warehouse === "bigquery" && !this.config.defaultLocation) {
            this.compileError("A defaultLocation is required for BigQuery. This can be configured in dataform.json.", "dataform.json");
        }
        const compiledGraph = dataform.CompiledGraph.create({
            projectConfig: this.config,
            tables: this.compileGraphChunk(this.actions.filter(action => action instanceof Table), dataform.Table.verify),
            operations: this.compileGraphChunk(this.actions.filter(action => action instanceof Operation), dataform.Operation.verify),
            assertions: this.compileGraphChunk(this.actions.filter(action => action instanceof Assertion), dataform.Assertion.verify),
            declarations: this.compileGraphChunk(this.actions.filter(action => action instanceof Declaration), dataform.Declaration.verify),
            tests: this.compileGraphChunk(Object.values(this.tests), dataform.Test.verify),
            graphErrors: this.graphErrors,
            dataformCoreVersion: version,
            targets: this.actions.map(action => action.proto.target)
        });
        this.fullyQualifyDependencies([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations));
        this.alterActionName([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations), [].concat(compiledGraph.declarations.map(declaration => declaration.target)));
        this.removeNonUniqueActionsFromCompiledGraph(compiledGraph);
        this.checkTestNameUniqueness(compiledGraph.tests);
        this.checkTableConfigValidity(compiledGraph.tables);
        this.checkCircularity([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations));
        if (this.config.useRunCache) {
            this.checkRunCachingCorrectness([].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations.filter(operation => operation.hasOutput)));
        }
        throwIfInvalid(compiledGraph, dataform.CompiledGraph.verify);
        return compiledGraph;
    }
    compileToBase64() {
        return encode64(dataform.CompiledGraph, this.compile());
    }
    finalizeDatabase(database) {
        return this.adapter().normalizeIdentifier(`${database}${this.getDatabaseSuffixWithUnderscore()}`);
    }
    finalizeSchema(schema) {
        return this.adapter().normalizeIdentifier(`${schema}${this.getSchemaSuffixWithUnderscore()}`);
    }
    finalizeName(name) {
        return this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${name}`);
    }
    getDatabaseSuffixWithUnderscore() {
        return !!this.config.databaseSuffix ? `_${this.config.databaseSuffix}` : "";
    }
    getSchemaSuffixWithUnderscore() {
        return !!this.config.schemaSuffix ? `_${this.config.schemaSuffix}` : "";
    }
    getTablePrefixWithUnderscore() {
        return !!this.config.tablePrefix ? `${this.config.tablePrefix}_` : "";
    }
    compileGraphChunk(actions, verify) {
        const compiledChunks = [];
        actions.forEach(action => {
            try {
                const compiledChunk = action.compile();
                throwIfInvalid(compiledChunk, verify);
                compiledChunks.push(compiledChunk);
            }
            catch (e) {
                this.compileError(e, action.proto.fileName, action.proto.target);
            }
        });
        return compiledChunks;
    }
    fullyQualifyDependencies(actions) {
        actions.forEach(action => {
            const fullyQualifiedDependencies = {};
            for (const dependency of action.dependencyTargets) {
                const possibleDeps = this.indexedActions.find(dependency);
                if (possibleDeps.length === 0) {
                    this.compileError(new Error(`Missing dependency detected: Action "${targetAsReadableString(action.target)}" depends on "${stringifyResolvable(dependency)}" which does not exist`), action.fileName, action.target);
                }
                else if (possibleDeps.length === 1) {
                    const protoDep = possibleDeps[0].proto;
                    if (protoDep instanceof dataform.Table && protoDep.type === "inline") {
                        protoDep.dependencyTargets.forEach(inlineDep => action.dependencyTargets.push(inlineDep));
                    }
                    else {
                        fullyQualifiedDependencies[targetAsReadableString(protoDep.target)] = protoDep.target;
                    }
                }
                else {
                    this.compileError(new Error(ambiguousActionNameMsg(dependency, possibleDeps)), action.fileName, action.target);
                }
            }
            action.dependencyTargets = Object.values(fullyQualifiedDependencies);
        });
    }
    alterActionName(actions, declarationTargets) {
        const { tablePrefix, schemaSuffix, databaseSuffix } = this.config;
        if (!tablePrefix && !schemaSuffix && !databaseSuffix) {
            return;
        }
        const newTargetByOriginalTarget = new StringifiedMap(targetStringifier);
        declarationTargets.forEach(declarationTarget => newTargetByOriginalTarget.set(declarationTarget, declarationTarget));
        actions.forEach(action => {
            newTargetByOriginalTarget.set(action.target, Object.assign(Object.assign({}, action.target), { database: action.target.database &&
                    this.adapter().normalizeIdentifier(`${action.target.database}${this.getDatabaseSuffixWithUnderscore()}`), schema: this.adapter().normalizeIdentifier(`${action.target.schema}${this.getSchemaSuffixWithUnderscore()}`), name: this.adapter().normalizeIdentifier(`${this.getTablePrefixWithUnderscore()}${action.target.name}`) }));
            action.target = newTargetByOriginalTarget.get(action.target);
        });
        const getUpdatedTarget = (originalTarget) => {
            if (!newTargetByOriginalTarget.has(originalTarget)) {
                return originalTarget;
            }
            return newTargetByOriginalTarget.get(originalTarget);
        };
        actions.forEach(action => {
            action.dependencyTargets = (action.dependencyTargets || []).map(getUpdatedTarget);
            if (!!action.parentAction) {
                action.parentAction = getUpdatedTarget(action.parentAction);
            }
        });
    }
    checkTableConfigValidity(tables) {
        tables.forEach(table => {
            var _a, _b;
            if (!!table.type && !TableType.includes(table.type)) {
                this.compileError(`Wrong type of table detected. Should only use predefined types: ${joinQuoted(TableType)}`, table.fileName, table.target);
            }
            if (!!table.materialized) {
                if (table.type !== "view" ||
                    (this.config.warehouse !== "snowflake" && this.config.warehouse !== "bigquery")) {
                    this.compileError(new Error(`The 'materialized' option is only valid for Snowflake and BigQuery views`), table.fileName, table.target);
                }
            }
            if (!!table.snowflake) {
                if (table.snowflake.secure && table.type !== "view") {
                    this.compileError(new Error(`The 'secure' option is only valid for Snowflake views`), table.fileName, table.target);
                }
                if (table.snowflake.transient && table.type !== "table") {
                    this.compileError(new Error(`The 'transient' option is only valid for Snowflake tables`), table.fileName, table.target);
                }
                if (((_a = table.snowflake.clusterBy) === null || _a === void 0 ? void 0 : _a.length) > 0 &&
                    table.type !== "table" &&
                    table.type !== "incremental") {
                    this.compileError(new Error(`The 'clusterBy' option is only valid for Snowflake tables`), table.fileName, table.target);
                }
            }
            if (!!table.sqlDataWarehouse) {
                if (!!table.uniqueKey && table.uniqueKey.length > 0) {
                    this.compileError(new Error(`Merging using unique keys for SQLDataWarehouse has not yet been implemented`), table.fileName, table.target);
                }
                if (table.sqlDataWarehouse.distribution) {
                    const distribution = table.sqlDataWarehouse.distribution.toUpperCase();
                    if (distribution !== "REPLICATE" &&
                        distribution !== "ROUND_ROBIN" &&
                        !SQL_DATA_WAREHOUSE_DIST_HASH_REGEXP.test(distribution)) {
                        this.compileError(new Error(`Invalid value for sqldatawarehouse distribution: ${distribution}`), table.fileName, table.target);
                    }
                }
            }
            if (!!table.redshift) {
                const validatePropertyDefined = (opts, prop) => {
                    const value = opts[prop];
                    if (!opts.hasOwnProperty(prop)) {
                        this.compileError(`Property "${prop}" is not defined`, table.fileName, table.target);
                    }
                    else if (value instanceof Array) {
                        if (value.length === 0) {
                            this.compileError(`Property "${prop}" is not defined`, table.fileName, table.target);
                        }
                    }
                };
                const validatePropertiesDefined = (opts, props) => props.forEach(prop => validatePropertyDefined(opts, prop));
                const validatePropertyValueInValues = (opts, prop, values) => {
                    if (!!opts[prop] && !values.includes(opts[prop])) {
                        this.compileError(`Wrong value of "${prop}" property. Should only use predefined values: ${joinQuoted(values)}`, table.fileName, table.target);
                    }
                };
                if (table.redshift.distStyle || table.redshift.distKey) {
                    validatePropertiesDefined(table.redshift, ["distStyle", "distKey"]);
                    validatePropertyValueInValues(table.redshift, "distStyle", DistStyleType);
                }
                if (table.redshift.sortStyle ||
                    (table.redshift.sortKeys && table.redshift.sortKeys.length)) {
                    validatePropertiesDefined(table.redshift, ["sortStyle", "sortKeys"]);
                    validatePropertyValueInValues(table.redshift, "sortStyle", SortStyleType);
                }
            }
            if (!!table.bigquery) {
                if ((table.bigquery.partitionBy || ((_b = table.bigquery.clusterBy) === null || _b === void 0 ? void 0 : _b.length) ||
                    table.bigquery.partitionExpirationDays ||
                    table.bigquery.requirePartitionFilter) &&
                    table.type === "view") {
                    this.compileError(`partitionBy/clusterBy/requirePartitionFilter/partitionExpirationDays are not valid for BigQuery views; they are only valid for tables`, table.fileName, table.target);
                }
                else if (!table.bigquery.partitionBy &&
                    (table.bigquery.partitionExpirationDays || table.bigquery.requirePartitionFilter) &&
                    table.type === "table") {
                    this.compileError(`requirePartitionFilter/partitionExpirationDays are not valid for non partitioned BigQuery tables`, table.fileName, table.target);
                }
                else if (table.bigquery.additionalOptions) {
                    if (table.bigquery.partitionExpirationDays &&
                        table.bigquery.additionalOptions.partition_expiration_days) {
                        this.compileError(`partitionExpirationDays has been declared twice`, table.fileName, table.target);
                    }
                    if (table.bigquery.requirePartitionFilter &&
                        table.bigquery.additionalOptions.require_partition_filter) {
                        this.compileError(`requirePartitionFilter has been declared twice`, table.fileName, table.target);
                    }
                }
            }
            if (!!Table.IGNORED_PROPS[table.type]) {
                Table.IGNORED_PROPS[table.type].forEach(ignoredProp => {
                    if (objectExistsOrIsNonEmpty(table[ignoredProp])) {
                        this.compileError(`Unused property was detected: "${ignoredProp}". This property is not used for tables with type "${table.type}" and will be ignored`, table.fileName, table.target);
                    }
                });
            }
        });
    }
    checkTestNameUniqueness(tests) {
        const allNames = [];
        tests.forEach(testProto => {
            if (allNames.includes(testProto.name)) {
                this.compileError(new Error(`Duplicate test name detected: "${testProto.name}"`), testProto.fileName);
            }
            allNames.push(testProto.name);
        });
    }
    checkCircularity(actions) {
        const allActionsByStringifiedTarget = new Map(actions.map(action => [targetStringifier.stringify(action.target), action]));
        const tarjanGraph = new TarjanGraphConstructor();
        actions.forEach(action => {
            const cleanedDependencies = (action.dependencyTargets || []).filter(dependency => !!allActionsByStringifiedTarget.get(targetStringifier.stringify(dependency)));
            tarjanGraph.add(targetStringifier.stringify(action.target), cleanedDependencies.map(target => targetStringifier.stringify(target)));
        });
        const cycles = tarjanGraph.getCycles();
        cycles.forEach(cycle => {
            const firstActionInCycle = allActionsByStringifiedTarget.get(cycle[0].name);
            const message = `Circular dependency detected in chain: [${cycle
                .map(vertex => vertex.name)
                .join(" > ")} > ${targetAsReadableString(firstActionInCycle.target)}]`;
            this.compileError(new Error(message), firstActionInCycle.fileName, firstActionInCycle.target);
        });
    }
    checkRunCachingCorrectness(actionsWithOutput) {
        actionsWithOutput.forEach(action => {
            var _a;
            if (((_a = action.dependencyTargets) === null || _a === void 0 ? void 0 : _a.length) > 0) {
                return;
            }
            if ([dataform.ActionHermeticity.HERMETIC, dataform.ActionHermeticity.NON_HERMETIC].includes(action.hermeticity)) {
                return;
            }
            this.compileError(new Error("Zero-dependency actions which create datasets are required to explicitly declare 'hermetic: (true|false)' when run caching is turned on."), action.fileName, action.target);
        });
    }
    removeNonUniqueActionsFromCompiledGraph(compiledGraph) {
        function getNonUniqueTargets(targets) {
            const allTargets = new StringifiedSet(targetStringifier);
            const nonUniqueTargets = new StringifiedSet(targetStringifier);
            targets.forEach(target => {
                if (allTargets.has(target)) {
                    nonUniqueTargets.add(target);
                }
                allTargets.add(target);
            });
            return nonUniqueTargets;
        }
        const actions = [].concat(compiledGraph.tables, compiledGraph.assertions, compiledGraph.operations, compiledGraph.declarations);
        const nonUniqueActionsTargets = getNonUniqueTargets(actions.map(action => action.target));
        const nonUniqueActionsCanonicalTargets = getNonUniqueTargets(actions.map(action => action.canonicalTarget));
        const isUniqueAction = (action) => {
            const isNonUniqueTarget = nonUniqueActionsTargets.has(action.target);
            const isNonUniqueCanonicalTarget = nonUniqueActionsCanonicalTargets.has(action.canonicalTarget);
            if (isNonUniqueTarget) {
                this.compileError(new Error(`Duplicate action name detected. Names within a schema must be unique across tables, declarations, assertions, and operations`), action.fileName, action.target);
            }
            if (isNonUniqueCanonicalTarget) {
                this.compileError(new Error(`Duplicate canonical target detected. Canonical targets must be unique across tables, declarations, assertions, and operations:\n"${JSON.stringify(action.canonicalTarget)}"`), action.fileName, action.target);
            }
            return !isNonUniqueTarget && !isNonUniqueCanonicalTarget;
        };
        compiledGraph.tables = compiledGraph.tables.filter(isUniqueAction);
        compiledGraph.operations = compiledGraph.operations.filter(isUniqueAction);
        compiledGraph.declarations = compiledGraph.declarations.filter(isUniqueAction);
        compiledGraph.assertions = compiledGraph.assertions.filter(isUniqueAction);
    }
}
function definesDataset(type) {
    return type === "view" || type === "table" || type === "inline" || type === "incremental";
}
function getCanonicalProjectConfig(originalProjectConfig) {
    return {
        warehouse: originalProjectConfig.warehouse,
        defaultSchema: originalProjectConfig.defaultSchema,
        defaultDatabase: originalProjectConfig.defaultDatabase,
        assertionSchema: originalProjectConfig.assertionSchema
    };
}
function joinQuoted(values) {
    return values.map((value) => `"${value}"`).join(" | ");
}
function objectExistsOrIsNonEmpty(prop) {
    if (!prop) {
        return false;
    }
    return ((Array.isArray(prop) && !!prop.length) ||
        (!Array.isArray(prop) && typeof prop === "object" && !!Object.keys(prop).length) ||
        typeof prop !== "object");
}
class ActionIndex {
    constructor(adapter, actions) {
        this.adapter = adapter;
        this.byName = new Map();
        this.bySchemaAndName = new Map();
        this.byDatabaseAndName = new Map();
        this.byDatabaseSchemaAndName = new Map();
        for (const action of actions) {
            if (!this.byName.has(action.proto.target.name)) {
                this.byName.set(action.proto.target.name, []);
            }
            this.byName.get(action.proto.target.name).push(action);
            if (!this.bySchemaAndName.has(action.proto.target.schema)) {
                this.bySchemaAndName.set(action.proto.target.schema, new Map());
            }
            const forSchema = this.bySchemaAndName.get(action.proto.target.schema);
            if (!forSchema.has(action.proto.target.name)) {
                forSchema.set(action.proto.target.name, []);
            }
            forSchema.get(action.proto.target.name).push(action);
            if (!!action.proto.target.database) {
                if (!this.byDatabaseAndName.has(action.proto.target.database)) {
                    this.byDatabaseAndName.set(action.proto.target.database, new Map());
                }
                const forDatabaseNoSchema = this.byDatabaseAndName.get(action.proto.target.database);
                if (!forDatabaseNoSchema.has(action.proto.target.name)) {
                    forDatabaseNoSchema.set(action.proto.target.name, []);
                }
                forDatabaseNoSchema.get(action.proto.target.name).push(action);
                if (!this.byDatabaseSchemaAndName.has(action.proto.target.database)) {
                    this.byDatabaseSchemaAndName.set(action.proto.target.database, new Map());
                }
                const forDatabase = this.byDatabaseSchemaAndName.get(action.proto.target.database);
                if (!forDatabase.has(action.proto.target.schema)) {
                    forDatabase.set(action.proto.target.schema, new Map());
                }
                const forDatabaseAndSchema = forDatabase.get(action.proto.target.schema);
                if (!forDatabaseAndSchema.has(action.proto.target.name)) {
                    forDatabaseAndSchema.set(action.proto.target.name, []);
                }
                forDatabaseAndSchema.get(action.proto.target.name).push(action);
            }
        }
    }
    find(target) {
        if (!!target.database) {
            if (!!target.schema) {
                return (this.byDatabaseSchemaAndName
                    .get(this.adapter.normalizeIdentifier(target.database))
                    .get(this.adapter.normalizeIdentifier(target.schema))
                    .get(this.adapter.normalizeIdentifier(target.name)) || []);
            }
            return (this.byDatabaseAndName
                .get(this.adapter.normalizeIdentifier(target.database))
                .get(this.adapter.normalizeIdentifier(target.name)) || []);
        }
        if (!!target.schema) {
            return (this.bySchemaAndName
                .get(this.adapter.normalizeIdentifier(target.schema))
                .get(this.adapter.normalizeIdentifier(target.name)) || []);
        }
        return this.byName.get(this.adapter.normalizeIdentifier(target.name)) || [];
    }
}

function main(encodedCoreExecutionRequest) {
    var _a;
    const globalAny = global;
    const request = decode64(dataform.CoreExecutionRequest, encodedCoreExecutionRequest);
    const compileRequest = request.compile;
    const originalProjectConfig = require("dataform.json");
    const projectConfigOverride = (_a = compileRequest.compileConfig.projectConfigOverride) !== null && _a !== void 0 ? _a : {};
    if (!originalProjectConfig.defaultDatabase) {
        originalProjectConfig.defaultDatabase = originalProjectConfig.gcloudProjectId;
    }
    delete originalProjectConfig.gcloudProjectId;
    let projectConfig = Object.assign({}, originalProjectConfig);
    projectConfig = Object.assign(Object.assign(Object.assign({}, projectConfig), projectConfigOverride), { vars: Object.assign(Object.assign({}, projectConfig.vars), projectConfigOverride.vars) });
    const session = require("@dataform/core").session;
    session.init(compileRequest.compileConfig.projectDir, projectConfig, originalProjectConfig);
    globalAny.dataform = session;
    compileRequest.compileConfig.filePaths
        .filter(path => path.startsWith("includes/"))
        .filter(path => path.endsWith(".js"))
        .forEach(includePath => {
        try {
            globalAny[baseFilename(includePath)] = require(includePath);
        }
        catch (e) {
            session.compileError(e, includePath);
        }
    });
    globalAny.publish = session.publish.bind(session);
    globalAny.operate = session.operate.bind(session);
    globalAny.assert = session.assert.bind(session);
    globalAny.declare = session.declare.bind(session);
    globalAny.test = session.test.bind(session);
    compileRequest.compileConfig.filePaths
        .filter(path => path.startsWith("definitions/"))
        .filter(path => path.endsWith(".js") || path.endsWith(".sqlx"))
        .forEach(definitionPath => {
        try {
            require(definitionPath);
        }
        catch (e) {
            session.compileError(e, definitionPath);
        }
    });
    return encode64(dataform.CoreExecutionResponse, dataform.CoreExecutionResponse.create({ compile: { compiledGraph: session.compile() } }));
}

const indexFileGenerator = genIndex;
const compiler = compile;
function globalSession() {
    if (!global._DF_SESSION) {
        global._DF_SESSION = new Session();
    }
    return global._DF_SESSION;
}
const session = globalSession();
const compileStandaloneSqlxQuery$1 = compileStandaloneSqlxQuery;

exports.adapters = index;
exports.compileStandaloneSqlxQuery = compileStandaloneSqlxQuery$1;
exports.compiler = compiler;
exports.indexFileGenerator = indexFileGenerator;
exports.main = main;
exports.session = session;
